
/*
***************************************************************************
*  Copyright 2007 Impinj, Inc.
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
***************************************************************************
*/


/*
***************************************************************************
*
*  This code is generated by Impinj LLRP .Net generator. Modification is
*  not recommended.
*
***************************************************************************
*/

/*
***************************************************************************
* File Name:       LLRPParam.cs
*
* Version:         1.0
* Author:          Impinj
* Organization:    Impinj
* Date:            Jan. 18, 2008
*
* Description:     This file contains LLRP parameter definitions
***************************************************************************
*/

using System;
using System.IO;
using System.Text;
using System.Collections;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Runtime.InteropServices;

using LLRP.DataType;

namespace LLRP
{
    #region Custom Parameter Interface

    public interface IRegulatoryCapabilities_Custom_Param : ICustom_Parameter { }

    public interface IAISpec_Custom_Param : ICustom_Parameter { }

    public interface IInventoryParameterSpec_Custom_Param : ICustom_Parameter { }

    public interface IRFSurveySpec_Custom_Param : ICustom_Parameter { }

    public interface IAccessSpec_Custom_Param : ICustom_Parameter { }

    public interface IAccessCommand_Custom_Param : ICustom_Parameter { }

    public interface IROReportSpec_Custom_Param : ICustom_Parameter { }

    public interface ITagReportData_Custom_Param : ICustom_Parameter { }

    public interface IRFSurveyReportData_Custom_Param : ICustom_Parameter { }

    public interface IReaderEventNotificationData_Custom_Param : ICustom_Parameter { }

    public interface IReaderExceptionEvent_Custom_Param : ICustom_Parameter { }

    public interface IC1G2InventoryCommand_Custom_Param : ICustom_Parameter { }

    #endregion


    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_SpecParameter : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AccessCommandOpSpec : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AccessCommandOpSpecResult : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_EPCParameter : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_Timestamp : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolLLRPCapabilities : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolUHFRFModeTable : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolInventoryCommandSettings : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolTagSpec : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolEPCMemorySelector : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolTagData : ParamArrayList { }

    ///<summary>
    ///Allowed types: 
    ///</summary>
    public class UNION_AirProtocolSingulationDetails : ParamArrayList { }

    /// <summary>
    ///  The timestamps in LLRP messages or parameters can be either the uptime or the UTC time [UTC]. If a Reader has an UTC clock, all timestamps reported by the Reader SHALL use an UTC timestamp parameter. If a Reader has no UTC clock capability, all timestamps reported by the Reader. SHALL use the uptime parameter. 
    /// </summary>
    public class PARAM_UTCTimestamp : Parameter
    {
        public PARAM_UTCTimestamp()
        {
            typeID = 128;

        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_UTCTimestamp FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_UTCTimestamp param = new PARAM_UTCTimestamp();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<UTCTimestamp>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</UTCTimestamp>";
            return xml_str;
        }

        public static PARAM_UTCTimestamp FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_UTCTimestamp param = new PARAM_UTCTimestamp();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    ///  The timestamps in LLRP messages or parameters can be either the uptime or the UTC time [UTC]. If a Reader has an UTC clock, all timestamps reported by the Reader SHALL use an UTC timestamp parameter. If a Reader has no UTC clock capability, all timestamps reported by the Reader SHALL use the uptime parameter.
    /// </summary>
    public class PARAM_Uptime : Parameter
    {
        public PARAM_Uptime()
        {
            typeID = 129;

        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_Uptime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Uptime param = new PARAM_Uptime();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<Uptime>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</Uptime>";
            return xml_str;
        }

        public static PARAM_Uptime FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_Uptime param = new PARAM_Uptime();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the general capabilities of the device like supported air protocols, version of the Reader firmware, device hardware and software information, and receive sensitivity table. 
    /// </summary>
    public class PARAM_GeneralDeviceCapabilities : Parameter
    {
        public PARAM_GeneralDeviceCapabilities()
        {
            typeID = 137;

        }


        public UInt16 MaxNumberOfAntennaSupported = 0;
        private Int16 MaxNumberOfAntennaSupported_len = 0;

        public bool CanSetAntennaProperties = false;
        private Int16 CanSetAntennaProperties_len = 0;

        public bool HasUTCClockCapability = false;
        private Int16 HasUTCClockCapability_len = 0;

        private const UInt16 param_reserved_len = 14;

        public UInt32 DeviceManufacturerName = 0;
        private Int16 DeviceManufacturerName_len = 0;

        public UInt32 ModelName = 0;
        private Int16 ModelName_len = 0;

        public string ReaderFirmwareVersion = string.Empty;
        private Int16 ReaderFirmwareVersion_len;

        public PARAM_ReceiveSensitivityTableEntry[] ReceiveSensitivityTableEntry;

        public PARAM_PerAntennaReceiveSensitivityRange[] PerAntennaReceiveSensitivityRange;

        public PARAM_GPIOCapabilities GPIOCapabilities;

        public PARAM_PerAntennaAirProtocol[] PerAntennaAirProtocol;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (MaxNumberOfAntennaSupported != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumberOfAntennaSupported, MaxNumberOfAntennaSupported_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CanSetAntennaProperties != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanSetAntennaProperties, CanSetAntennaProperties_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (HasUTCClockCapability != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HasUTCClockCapability, HasUTCClockCapability_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (DeviceManufacturerName != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DeviceManufacturerName, DeviceManufacturerName_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ModelName != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ModelName, ModelName_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReaderFirmwareVersion != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderFirmwareVersion.Length), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderFirmwareVersion, ReaderFirmwareVersion_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }

            if (ReceiveSensitivityTableEntry != null)
            {

                len = ReceiveSensitivityTableEntry.Length;
                for (int i = 0; i < len; i++)
                    ReceiveSensitivityTableEntry[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (PerAntennaReceiveSensitivityRange != null)
            {

                len = PerAntennaReceiveSensitivityRange.Length;
                for (int i = 0; i < len; i++)
                    PerAntennaReceiveSensitivityRange[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (GPIOCapabilities != null)
            {
                GPIOCapabilities.ToBitArray(ref bit_array, ref cursor);

            }

            if (PerAntennaAirProtocol != null)
            {

                len = PerAntennaAirProtocol.Length;
                for (int i = 0; i < len; i++)
                    PerAntennaAirProtocol[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GeneralDeviceCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GeneralDeviceCapabilities param = new PARAM_GeneralDeviceCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.MaxNumberOfAntennaSupported = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanSetAntennaProperties = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.HasUTCClockCapability = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DeviceManufacturerName = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ModelName = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            param.ReaderFirmwareVersion = (string)obj_val;

            param_list = new ArrayList();
            PARAM_ReceiveSensitivityTableEntry _param_ReceiveSensitivityTableEntry = PARAM_ReceiveSensitivityTableEntry.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_ReceiveSensitivityTableEntry != null)
            {
                param_list.Add(_param_ReceiveSensitivityTableEntry);
                while ((_param_ReceiveSensitivityTableEntry = PARAM_ReceiveSensitivityTableEntry.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_ReceiveSensitivityTableEntry);
                if (param_list.Count > 0)
                {
                    param.ReceiveSensitivityTableEntry = new PARAM_ReceiveSensitivityTableEntry[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.ReceiveSensitivityTableEntry[i] = (PARAM_ReceiveSensitivityTableEntry)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_PerAntennaReceiveSensitivityRange _param_PerAntennaReceiveSensitivityRange = PARAM_PerAntennaReceiveSensitivityRange.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_PerAntennaReceiveSensitivityRange != null)
            {
                param_list.Add(_param_PerAntennaReceiveSensitivityRange);
                while ((_param_PerAntennaReceiveSensitivityRange = PARAM_PerAntennaReceiveSensitivityRange.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_PerAntennaReceiveSensitivityRange);
                if (param_list.Count > 0)
                {
                    param.PerAntennaReceiveSensitivityRange = new PARAM_PerAntennaReceiveSensitivityRange[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.PerAntennaReceiveSensitivityRange[i] = (PARAM_PerAntennaReceiveSensitivityRange)param_list[i];
                }
            }

            param.GPIOCapabilities = PARAM_GPIOCapabilities.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_PerAntennaAirProtocol _param_PerAntennaAirProtocol = PARAM_PerAntennaAirProtocol.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_PerAntennaAirProtocol != null)
            {
                param_list.Add(_param_PerAntennaAirProtocol);
                while ((_param_PerAntennaAirProtocol = PARAM_PerAntennaAirProtocol.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_PerAntennaAirProtocol);
                if (param_list.Count > 0)
                {
                    param.PerAntennaAirProtocol = new PARAM_PerAntennaAirProtocol[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.PerAntennaAirProtocol[i] = (PARAM_PerAntennaAirProtocol)param_list[i];
                }
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GeneralDeviceCapabilities>";

            if (MaxNumberOfAntennaSupported != null)
            {

                xml_str += "<MaxNumberOfAntennaSupported>" + MaxNumberOfAntennaSupported.ToString() + "</MaxNumberOfAntennaSupported>";

            }

            if (CanSetAntennaProperties != null)
            {

                xml_str += "<CanSetAntennaProperties>" + CanSetAntennaProperties.ToString() + "</CanSetAntennaProperties>";

            }

            if (HasUTCClockCapability != null)
            {

                xml_str += "<HasUTCClockCapability>" + HasUTCClockCapability.ToString() + "</HasUTCClockCapability>";

            }

            if (DeviceManufacturerName != null)
            {

                xml_str += "<DeviceManufacturerName>" + DeviceManufacturerName.ToString() + "</DeviceManufacturerName>";

            }

            if (ModelName != null)
            {

                xml_str += "<ModelName>" + ModelName.ToString() + "</ModelName>";

            }

            if (ReaderFirmwareVersion != null)
            {

                xml_str += "<ReaderFirmwareVersion>" + ReaderFirmwareVersion.ToString() + "</ReaderFirmwareVersion>";

            }

            if (ReceiveSensitivityTableEntry != null)
            {

                len = ReceiveSensitivityTableEntry.Length;
                for (int i = 0; i < len; i++)
                    xml_str += ReceiveSensitivityTableEntry[i].ToString();

            }

            if (PerAntennaReceiveSensitivityRange != null)
            {

                len = PerAntennaReceiveSensitivityRange.Length;
                for (int i = 0; i < len; i++)
                    xml_str += PerAntennaReceiveSensitivityRange[i].ToString();

            }

            if (GPIOCapabilities != null)
            {

                xml_str += GPIOCapabilities.ToString();

            }

            if (PerAntennaAirProtocol != null)
            {

                len = PerAntennaAirProtocol.Length;
                for (int i = 0; i < len; i++)
                    xml_str += PerAntennaAirProtocol[i].ToString();

            }

            xml_str += "</GeneralDeviceCapabilities>";
            return xml_str;
        }

        public static PARAM_GeneralDeviceCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GeneralDeviceCapabilities param = new PARAM_GeneralDeviceCapabilities();


            val = XmlUtil.GetNodeValue(node, "MaxNumberOfAntennaSupported");

            param.MaxNumberOfAntennaSupported = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "CanSetAntennaProperties");

            param.CanSetAntennaProperties = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "HasUTCClockCapability");

            param.HasUTCClockCapability = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "DeviceManufacturerName");

            param.DeviceManufacturerName = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "ModelName");

            param.ModelName = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "ReaderFirmwareVersion");

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReceiveSensitivityTableEntry");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.ReceiveSensitivityTableEntry = new PARAM_ReceiveSensitivityTableEntry[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.ReceiveSensitivityTableEntry[i] = PARAM_ReceiveSensitivityTableEntry.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "PerAntennaReceiveSensitivityRange");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.PerAntennaReceiveSensitivityRange = new PARAM_PerAntennaReceiveSensitivityRange[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.PerAntennaReceiveSensitivityRange[i] = PARAM_PerAntennaReceiveSensitivityRange.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIOCapabilities");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.GPIOCapabilities = PARAM_GPIOCapabilities.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "PerAntennaAirProtocol");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.PerAntennaAirProtocol = new PARAM_PerAntennaAirProtocol[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.PerAntennaAirProtocol[i] = PARAM_PerAntennaAirProtocol.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter specifies the index into the Receive Sensitivity Table for a receive sensitivity value. The receive sensitivity is expressed in dB and the value is relative to the maximum sensitivity. If the Reader does not allow control of receive sensitivity, a table of one entry is returned, the entry having the value of zero.If the Reader allows control of receive sensitivity and the Reader also supports multiple antennas where the antennas can have different receive sensitivity values, then the Receive Sensitivity Table should be a set of values representing the union of sensitivity values for all antennas.
    /// </summary>
    public class PARAM_ReceiveSensitivityTableEntry : Parameter
    {
        public PARAM_ReceiveSensitivityTableEntry()
        {
            typeID = 139;

        }


        public UInt16 Index = 0;
        private Int16 Index_len = 0;

        public Int16 ReceiveSensitivityValue = 0;
        private Int16 ReceiveSensitivityValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Index != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Index, Index_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReceiveSensitivityValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReceiveSensitivityValue, ReceiveSensitivityValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReceiveSensitivityTableEntry FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReceiveSensitivityTableEntry param = new PARAM_ReceiveSensitivityTableEntry();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.Index = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(Int16), field_len);
            param.ReceiveSensitivityValue = (Int16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReceiveSensitivityTableEntry>";

            if (Index != null)
            {

                xml_str += "<Index>" + Index.ToString() + "</Index>";

            }

            if (ReceiveSensitivityValue != null)
            {

                xml_str += "<ReceiveSensitivityValue>" + ReceiveSensitivityValue.ToString() + "</ReceiveSensitivityValue>";

            }

            xml_str += "</ReceiveSensitivityTableEntry>";
            return xml_str;
        }

        public static PARAM_ReceiveSensitivityTableEntry FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReceiveSensitivityTableEntry param = new PARAM_ReceiveSensitivityTableEntry();


            val = XmlUtil.GetNodeValue(node, "Index");

            param.Index = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ReceiveSensitivityValue");

            param.ReceiveSensitivityValue = Convert.ToInt16(val);

            return param;
        }

    }

    /// <summary>
    /// For a particular antenna, this parameter specifies the Reader's valid index range in the Receive Sensitivity Table.  A Reader should report this parameter if the Reader allows control of receive sensitivity (i.e., the Reader reports a Receive Sensitivity Table with more than one entry) and the Reader supports multiple antennas where the antennas can have different receive sensitivity values.If this parameter is omitted, then the Client SHALL assume that for all of the Reader's antennas the index range is the same as in the Receive Sensitivity Table.
    /// </summary>
    public class PARAM_PerAntennaReceiveSensitivityRange : Parameter
    {
        public PARAM_PerAntennaReceiveSensitivityRange()
        {
            typeID = 149;

        }


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public UInt16 ReceiveSensitivityIndexMin = 0;
        private Int16 ReceiveSensitivityIndexMin_len = 0;

        public UInt16 ReceiveSensitivityIndexMax = 0;
        private Int16 ReceiveSensitivityIndexMax_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReceiveSensitivityIndexMin != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReceiveSensitivityIndexMin, ReceiveSensitivityIndexMin_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReceiveSensitivityIndexMax != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReceiveSensitivityIndexMax, ReceiveSensitivityIndexMax_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_PerAntennaReceiveSensitivityRange FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_PerAntennaReceiveSensitivityRange param = new PARAM_PerAntennaReceiveSensitivityRange();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ReceiveSensitivityIndexMin = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ReceiveSensitivityIndexMax = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<PerAntennaReceiveSensitivityRange>";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (ReceiveSensitivityIndexMin != null)
            {

                xml_str += "<ReceiveSensitivityIndexMin>" + ReceiveSensitivityIndexMin.ToString() + "</ReceiveSensitivityIndexMin>";

            }

            if (ReceiveSensitivityIndexMax != null)
            {

                xml_str += "<ReceiveSensitivityIndexMax>" + ReceiveSensitivityIndexMax.ToString() + "</ReceiveSensitivityIndexMax>";

            }

            xml_str += "</PerAntennaReceiveSensitivityRange>";
            return xml_str;
        }

        public static PARAM_PerAntennaReceiveSensitivityRange FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_PerAntennaReceiveSensitivityRange param = new PARAM_PerAntennaReceiveSensitivityRange();


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ReceiveSensitivityIndexMin");

            param.ReceiveSensitivityIndexMin = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ReceiveSensitivityIndexMax");

            param.ReceiveSensitivityIndexMax = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Describes the air-protocols supporter on a per-antenna basis.
    /// </summary>
    public class PARAM_PerAntennaAirProtocol : Parameter
    {
        public PARAM_PerAntennaAirProtocol()
        {
            typeID = 140;

        }


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public ByteArray ProtocolID;
        private Int16 ProtocolID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ProtocolID != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ProtocolID.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ProtocolID, ProtocolID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_PerAntennaAirProtocol FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_PerAntennaAirProtocol param = new PARAM_PerAntennaAirProtocol();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            param.ProtocolID = (ByteArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<PerAntennaAirProtocol>";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (ProtocolID != null)
            {

                xml_str += "<ProtocolID>" + ProtocolID.ToString() + "</ProtocolID>";

            }

            xml_str += "</PerAntennaAirProtocol>";
            return xml_str;
        }

        public static PARAM_PerAntennaAirProtocol FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_PerAntennaAirProtocol param = new PARAM_PerAntennaAirProtocol();


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ProtocolID");

            param.ProtocolID = (ByteArray)Enum.Parse(typeof(ByteArray), val);

            return param;
        }

    }

    /// <summary>
    /// This parameter describes the GPIO capabilities of the Reader. A value of zero for NumGPIs indicates that the Reader does not have general purpose inputs. A value of zero for NumGPOs indicates that the Reader does not have general purpose outputs.
    /// </summary>
    public class PARAM_GPIOCapabilities : Parameter
    {
        public PARAM_GPIOCapabilities()
        {
            typeID = 141;

        }


        public UInt16 NumGPIs = 0;
        private Int16 NumGPIs_len = 0;

        public UInt16 NumGPOs = 0;
        private Int16 NumGPOs_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (NumGPIs != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumGPIs, NumGPIs_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NumGPOs != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumGPOs, NumGPOs_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GPIOCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPIOCapabilities param = new PARAM_GPIOCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumGPIs = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumGPOs = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GPIOCapabilities>";

            if (NumGPIs != null)
            {

                xml_str += "<NumGPIs>" + NumGPIs.ToString() + "</NumGPIs>";

            }

            if (NumGPOs != null)
            {

                xml_str += "<NumGPOs>" + NumGPOs.ToString() + "</NumGPOs>";

            }

            xml_str += "</GPIOCapabilities>";
            return xml_str;
        }

        public static PARAM_GPIOCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GPIOCapabilities param = new PARAM_GPIOCapabilities();


            val = XmlUtil.GetNodeValue(node, "NumGPIs");

            param.NumGPIs = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NumGPOs");

            param.NumGPOs = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter describes the LLRP protocol capabilities of the Reader. These include optional LLRP commands and parameters, capacities of data structures used in LLRP operations, and air protocol specific capabilities used by LLRP.Readers MAY support RFSurvey, MAY support tag inventory state aware singulation, MAY support UTC clocks, MAY support buffer fill warning reports, MAY support EventAndReportHolding upon reconnect, and MAY support ClientRequestOpspec. Readers SHALL support at least one ROSpec, one AISpec per ROSpec, one InventoryParameterSpec per AISpec, one AccessSpec, and one OpSpec per AccessSpec.
    /// </summary>
    public class PARAM_LLRPCapabilities : Parameter
    {
        public PARAM_LLRPCapabilities()
        {
            typeID = 142;

        }


        public bool CanDoRFSurvey = false;
        private Int16 CanDoRFSurvey_len = 0;

        public bool CanReportBufferFillWarning = false;
        private Int16 CanReportBufferFillWarning_len = 0;

        public bool SupportsClientRequestOpSpec = false;
        private Int16 SupportsClientRequestOpSpec_len = 0;

        public bool CanDoTagInventoryStateAwareSingulation = false;
        private Int16 CanDoTagInventoryStateAwareSingulation_len = 0;

        public bool SupportsEventAndReportHolding = false;
        private Int16 SupportsEventAndReportHolding_len = 0;

        private const UInt16 param_reserved_len = 3;

        public byte MaxNumPriorityLevelsSupported = 0;
        private Int16 MaxNumPriorityLevelsSupported_len = 0;

        public UInt16 ClientRequestOpSpecTimeout = 0;
        private Int16 ClientRequestOpSpecTimeout_len = 0;

        public UInt32 MaxNumROSpecs = 0;
        private Int16 MaxNumROSpecs_len = 0;

        public UInt32 MaxNumSpecsPerROSpec = 0;
        private Int16 MaxNumSpecsPerROSpec_len = 0;

        public UInt32 MaxNumInventoryParameterSpecsPerAISpec = 0;
        private Int16 MaxNumInventoryParameterSpecsPerAISpec_len = 0;

        public UInt32 MaxNumAccessSpecs = 0;
        private Int16 MaxNumAccessSpecs_len = 0;

        public UInt32 MaxNumOpSpecsPerAccessSpec = 0;
        private Int16 MaxNumOpSpecsPerAccessSpec_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (CanDoRFSurvey != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanDoRFSurvey, CanDoRFSurvey_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CanReportBufferFillWarning != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanReportBufferFillWarning, CanReportBufferFillWarning_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (SupportsClientRequestOpSpec != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SupportsClientRequestOpSpec, SupportsClientRequestOpSpec_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CanDoTagInventoryStateAwareSingulation != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanDoTagInventoryStateAwareSingulation, CanDoTagInventoryStateAwareSingulation_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (SupportsEventAndReportHolding != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SupportsEventAndReportHolding, SupportsEventAndReportHolding_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (MaxNumPriorityLevelsSupported != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumPriorityLevelsSupported, MaxNumPriorityLevelsSupported_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ClientRequestOpSpecTimeout != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ClientRequestOpSpecTimeout, ClientRequestOpSpecTimeout_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxNumROSpecs != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumROSpecs, MaxNumROSpecs_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxNumSpecsPerROSpec != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumSpecsPerROSpec, MaxNumSpecsPerROSpec_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxNumInventoryParameterSpecsPerAISpec != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumInventoryParameterSpecsPerAISpec, MaxNumInventoryParameterSpecsPerAISpec_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxNumAccessSpecs != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumAccessSpecs, MaxNumAccessSpecs_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxNumOpSpecsPerAccessSpec != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumOpSpecsPerAccessSpec, MaxNumOpSpecsPerAccessSpec_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_LLRPCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_LLRPCapabilities param = new PARAM_LLRPCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanDoRFSurvey = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanReportBufferFillWarning = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.SupportsClientRequestOpSpec = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanDoTagInventoryStateAwareSingulation = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.SupportsEventAndReportHolding = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            param.MaxNumPriorityLevelsSupported = (byte)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ClientRequestOpSpecTimeout = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxNumROSpecs = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxNumSpecsPerROSpec = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxNumInventoryParameterSpecsPerAISpec = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxNumAccessSpecs = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxNumOpSpecsPerAccessSpec = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<LLRPCapabilities>";

            if (CanDoRFSurvey != null)
            {

                xml_str += "<CanDoRFSurvey>" + CanDoRFSurvey.ToString() + "</CanDoRFSurvey>";

            }

            if (CanReportBufferFillWarning != null)
            {

                xml_str += "<CanReportBufferFillWarning>" + CanReportBufferFillWarning.ToString() + "</CanReportBufferFillWarning>";

            }

            if (SupportsClientRequestOpSpec != null)
            {

                xml_str += "<SupportsClientRequestOpSpec>" + SupportsClientRequestOpSpec.ToString() + "</SupportsClientRequestOpSpec>";

            }

            if (CanDoTagInventoryStateAwareSingulation != null)
            {

                xml_str += "<CanDoTagInventoryStateAwareSingulation>" + CanDoTagInventoryStateAwareSingulation.ToString() + "</CanDoTagInventoryStateAwareSingulation>";

            }

            if (SupportsEventAndReportHolding != null)
            {

                xml_str += "<SupportsEventAndReportHolding>" + SupportsEventAndReportHolding.ToString() + "</SupportsEventAndReportHolding>";

            }

            if (MaxNumPriorityLevelsSupported != null)
            {

                xml_str += "<MaxNumPriorityLevelsSupported>" + MaxNumPriorityLevelsSupported.ToString() + "</MaxNumPriorityLevelsSupported>";

            }

            if (ClientRequestOpSpecTimeout != null)
            {

                xml_str += "<ClientRequestOpSpecTimeout>" + ClientRequestOpSpecTimeout.ToString() + "</ClientRequestOpSpecTimeout>";

            }

            if (MaxNumROSpecs != null)
            {

                xml_str += "<MaxNumROSpecs>" + MaxNumROSpecs.ToString() + "</MaxNumROSpecs>";

            }

            if (MaxNumSpecsPerROSpec != null)
            {

                xml_str += "<MaxNumSpecsPerROSpec>" + MaxNumSpecsPerROSpec.ToString() + "</MaxNumSpecsPerROSpec>";

            }

            if (MaxNumInventoryParameterSpecsPerAISpec != null)
            {

                xml_str += "<MaxNumInventoryParameterSpecsPerAISpec>" + MaxNumInventoryParameterSpecsPerAISpec.ToString() + "</MaxNumInventoryParameterSpecsPerAISpec>";

            }

            if (MaxNumAccessSpecs != null)
            {

                xml_str += "<MaxNumAccessSpecs>" + MaxNumAccessSpecs.ToString() + "</MaxNumAccessSpecs>";

            }

            if (MaxNumOpSpecsPerAccessSpec != null)
            {

                xml_str += "<MaxNumOpSpecsPerAccessSpec>" + MaxNumOpSpecsPerAccessSpec.ToString() + "</MaxNumOpSpecsPerAccessSpec>";

            }

            xml_str += "</LLRPCapabilities>";
            return xml_str;
        }

        public static PARAM_LLRPCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_LLRPCapabilities param = new PARAM_LLRPCapabilities();


            val = XmlUtil.GetNodeValue(node, "CanDoRFSurvey");

            param.CanDoRFSurvey = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "CanReportBufferFillWarning");

            param.CanReportBufferFillWarning = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "SupportsClientRequestOpSpec");

            param.SupportsClientRequestOpSpec = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "CanDoTagInventoryStateAwareSingulation");

            param.CanDoTagInventoryStateAwareSingulation = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "SupportsEventAndReportHolding");

            param.SupportsEventAndReportHolding = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumPriorityLevelsSupported");

            param.MaxNumPriorityLevelsSupported = Convert.ToByte(val);

            val = XmlUtil.GetNodeValue(node, "ClientRequestOpSpecTimeout");

            param.ClientRequestOpSpecTimeout = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumROSpecs");

            param.MaxNumROSpecs = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumSpecsPerROSpec");

            param.MaxNumSpecsPerROSpec = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumInventoryParameterSpecsPerAISpec");

            param.MaxNumInventoryParameterSpecsPerAISpec = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumAccessSpecs");

            param.MaxNumAccessSpecs = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumOpSpecsPerAccessSpec");

            param.MaxNumOpSpecsPerAccessSpec = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the RF regulation specific attributes. They include regulatory standard, frequency band information, power levels supported, frequencies supported, and any air protocol specific values that are determined based on regulatory restriction.  The regulatory standard is encoded using two Integer fields, (Country Code, Communications standard) and it specifies the current operational regulatory mode of the device.  This should not be used to reflect the ability to operate in regulatory environments which require configuration different from the current. This version of the LLRP protocol will have support for only the UHF band. 
    /// </summary>
    public class PARAM_RegulatoryCapabilities : Parameter
    {
        public PARAM_RegulatoryCapabilities()
        {
            typeID = 143;

        }


        public UInt16 CountryCode = 0;
        private Int16 CountryCode_len = 0;

        public
      ENUM_CommunicationsStandard CommunicationsStandard;
        private Int16 CommunicationsStandard_len = 16;
        public PARAM_UHFBandCapabilities UHFBandCapabilities;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IRegulatoryCapabilities_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (CountryCode != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CountryCode, CountryCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CommunicationsStandard != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CommunicationsStandard, CommunicationsStandard_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (UHFBandCapabilities != null)
            {
                UHFBandCapabilities.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RegulatoryCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RegulatoryCapabilities param = new PARAM_RegulatoryCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.CountryCode = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.CommunicationsStandard = (
        ENUM_CommunicationsStandard)(UInt32)obj_val;

            param.UHFBandCapabilities = PARAM_UHFBandCapabilities.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RegulatoryCapabilities>";

            if (CountryCode != null)
            {

                xml_str += "<CountryCode>" + CountryCode.ToString() + "</CountryCode>";

            }

            if (CommunicationsStandard != null)
            {

                xml_str += "<CommunicationsStandard>" + CommunicationsStandard.ToString() + "</CommunicationsStandard>";

            }

            if (UHFBandCapabilities != null)
            {

                xml_str += UHFBandCapabilities.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</RegulatoryCapabilities>";
            return xml_str;
        }

        public static PARAM_RegulatoryCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RegulatoryCapabilities param = new PARAM_RegulatoryCapabilities();


            val = XmlUtil.GetNodeValue(node, "CountryCode");

            param.CountryCode = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "CommunicationsStandard");

            param.CommunicationsStandard = (
      ENUM_CommunicationsStandard)Enum.Parse(typeof(
      ENUM_CommunicationsStandard), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "UHFBandCapabilities");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.UHFBandCapabilities = PARAM_UHFBandCapabilities.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Describes the frequency, power, and air-protocol capabilities for the regulatory region.
    /// </summary>
    public class PARAM_UHFBandCapabilities : Parameter
    {
        public PARAM_UHFBandCapabilities()
        {
            typeID = 144;

        }


        public PARAM_TransmitPowerLevelTableEntry[] TransmitPowerLevelTableEntry;

        public PARAM_FrequencyInformation FrequencyInformation;

        public UNION_AirProtocolUHFRFModeTable AirProtocolUHFRFModeTable = new UNION_AirProtocolUHFRFModeTable();

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (TransmitPowerLevelTableEntry != null)
            {

                len = TransmitPowerLevelTableEntry.Length;
                for (int i = 0; i < len; i++)
                    TransmitPowerLevelTableEntry[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (FrequencyInformation != null)
            {
                FrequencyInformation.ToBitArray(ref bit_array, ref cursor);

            }

            len = AirProtocolUHFRFModeTable.Count;
            for (int i = 0; i < len; i++) AirProtocolUHFRFModeTable[i].ToBitArray(ref bit_array, ref cursor);


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_UHFBandCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_UHFBandCapabilities param = new PARAM_UHFBandCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param_list = new ArrayList();
            PARAM_TransmitPowerLevelTableEntry _param_TransmitPowerLevelTableEntry = PARAM_TransmitPowerLevelTableEntry.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_TransmitPowerLevelTableEntry != null)
            {
                param_list.Add(_param_TransmitPowerLevelTableEntry);
                while ((_param_TransmitPowerLevelTableEntry = PARAM_TransmitPowerLevelTableEntry.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_TransmitPowerLevelTableEntry);
                if (param_list.Count > 0)
                {
                    param.TransmitPowerLevelTableEntry = new PARAM_TransmitPowerLevelTableEntry[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.TransmitPowerLevelTableEntry[i] = (PARAM_TransmitPowerLevelTableEntry)param_list[i];
                }
            }

            param.FrequencyInformation = PARAM_FrequencyInformation.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_C1G2UHFRFModeTable _param_C1G2UHFRFModeTable = PARAM_C1G2UHFRFModeTable.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2UHFRFModeTable != null)
            {
                param.AirProtocolUHFRFModeTable.Add(_param_C1G2UHFRFModeTable);
                while ((_param_C1G2UHFRFModeTable = PARAM_C1G2UHFRFModeTable.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolUHFRFModeTable.Add(_param_C1G2UHFRFModeTable);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<UHFBandCapabilities>";

            if (TransmitPowerLevelTableEntry != null)
            {

                len = TransmitPowerLevelTableEntry.Length;
                for (int i = 0; i < len; i++)
                    xml_str += TransmitPowerLevelTableEntry[i].ToString();

            }

            if (FrequencyInformation != null)
            {

                xml_str += FrequencyInformation.ToString();

            }

            if (AirProtocolUHFRFModeTable != null)
            {
                len = AirProtocolUHFRFModeTable.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolUHFRFModeTable[i].ToString();
            }

            xml_str += "</UHFBandCapabilities>";
            return xml_str;
        }

        public static PARAM_UHFBandCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_UHFBandCapabilities param = new PARAM_UHFBandCapabilities();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TransmitPowerLevelTableEntry");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.TransmitPowerLevelTableEntry = new PARAM_TransmitPowerLevelTableEntry[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.TransmitPowerLevelTableEntry[i] = PARAM_TransmitPowerLevelTableEntry.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FrequencyInformation");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FrequencyInformation = PARAM_FrequencyInformation.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                param.AirProtocolUHFRFModeTable = new UNION_AirProtocolUHFRFModeTable();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2UHFRFModeTable");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolUHFRFModeTable.Add(PARAM_C1G2UHFRFModeTable.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            return param;
        }

    }

    /// <summary>
    /// This parameter specifies the index into the TransmitPowerLevelTable for a transmit power value. The transmit power is expressed in dBm*100 to allow fractional dBm representation and is the conducted power at the connector of the Reader.
    /// </summary>
    public class PARAM_TransmitPowerLevelTableEntry : Parameter
    {
        public PARAM_TransmitPowerLevelTableEntry()
        {
            typeID = 145;

        }


        public UInt16 Index = 0;
        private Int16 Index_len = 0;

        public Int16 TransmitPowerValue = 0;
        private Int16 TransmitPowerValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Index != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Index, Index_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TransmitPowerValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TransmitPowerValue, TransmitPowerValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_TransmitPowerLevelTableEntry FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TransmitPowerLevelTableEntry param = new PARAM_TransmitPowerLevelTableEntry();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.Index = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(Int16), field_len);
            param.TransmitPowerValue = (Int16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<TransmitPowerLevelTableEntry>";

            if (Index != null)
            {

                xml_str += "<Index>" + Index.ToString() + "</Index>";

            }

            if (TransmitPowerValue != null)
            {

                xml_str += "<TransmitPowerValue>" + TransmitPowerValue.ToString() + "</TransmitPowerValue>";

            }

            xml_str += "</TransmitPowerLevelTableEntry>";
            return xml_str;
        }

        public static PARAM_TransmitPowerLevelTableEntry FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_TransmitPowerLevelTableEntry param = new PARAM_TransmitPowerLevelTableEntry();


            val = XmlUtil.GetNodeValue(node, "Index");

            param.Index = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "TransmitPowerValue");

            param.TransmitPowerValue = Convert.ToInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Describes the fixed frequency or hopping frequencies supported in this UHFBand.
    /// </summary>
    public class PARAM_FrequencyInformation : Parameter
    {
        public PARAM_FrequencyInformation()
        {
            typeID = 146;

        }


        public bool Hopping = false;
        private Int16 Hopping_len = 0;

        private const UInt16 param_reserved_len = 7;

        public PARAM_FrequencyHopTable[] FrequencyHopTable;

        public PARAM_FixedFrequencyTable FixedFrequencyTable;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Hopping != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Hopping, Hopping_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (FrequencyHopTable != null)
            {

                len = FrequencyHopTable.Length;
                for (int i = 0; i < len; i++)
                    FrequencyHopTable[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (FixedFrequencyTable != null)
            {
                FixedFrequencyTable.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FrequencyInformation FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FrequencyInformation param = new PARAM_FrequencyInformation();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.Hopping = (bool)obj_val;

            cursor += param_reserved_len;

            param_list = new ArrayList();
            PARAM_FrequencyHopTable _param_FrequencyHopTable = PARAM_FrequencyHopTable.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_FrequencyHopTable != null)
            {
                param_list.Add(_param_FrequencyHopTable);
                while ((_param_FrequencyHopTable = PARAM_FrequencyHopTable.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_FrequencyHopTable);
                if (param_list.Count > 0)
                {
                    param.FrequencyHopTable = new PARAM_FrequencyHopTable[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.FrequencyHopTable[i] = (PARAM_FrequencyHopTable)param_list[i];
                }
            }

            param.FixedFrequencyTable = PARAM_FixedFrequencyTable.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FrequencyInformation>";

            if (Hopping != null)
            {

                xml_str += "<Hopping>" + Hopping.ToString() + "</Hopping>";

            }

            if (FrequencyHopTable != null)
            {

                len = FrequencyHopTable.Length;
                for (int i = 0; i < len; i++)
                    xml_str += FrequencyHopTable[i].ToString();

            }

            if (FixedFrequencyTable != null)
            {

                xml_str += FixedFrequencyTable.ToString();

            }

            xml_str += "</FrequencyInformation>";
            return xml_str;
        }

        public static PARAM_FrequencyInformation FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FrequencyInformation param = new PARAM_FrequencyInformation();


            val = XmlUtil.GetNodeValue(node, "Hopping");

            param.Hopping = Convert.ToBoolean(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FrequencyHopTable");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.FrequencyHopTable = new PARAM_FrequencyHopTable[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.FrequencyHopTable[i] = PARAM_FrequencyHopTable.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FixedFrequencyTable");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FixedFrequencyTable = PARAM_FixedFrequencyTable.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the frequency hop table parameters. This is used for Readers operating in regions with frequency hopping regulatory requirements. If the Reader is capable of storing multiple hop tables, the Reader may send all of them to the Client.
    /// </summary>
    public class PARAM_FrequencyHopTable : Parameter
    {
        public PARAM_FrequencyHopTable()
        {
            typeID = 147;

        }


        public byte HopTableID = 0;
        private Int16 HopTableID_len = 0;

        private const UInt16 param_reserved_len = 8;

        public UInt32Array Frequency = new UInt32Array();
        private Int16 Frequency_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (HopTableID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HopTableID, HopTableID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (Frequency != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(Frequency.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(Frequency, Frequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FrequencyHopTable FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FrequencyHopTable param = new PARAM_FrequencyHopTable();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            param.HopTableID = (byte)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32Array), field_len);
            param.Frequency = (UInt32Array)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FrequencyHopTable>";

            if (HopTableID != null)
            {

                xml_str += "<HopTableID>" + HopTableID.ToString() + "</HopTableID>";

            }

            if (Frequency != null)
            {

                xml_str += "<Frequency>" + Frequency.ToString() + "</Frequency>";

            }

            xml_str += "</FrequencyHopTable>";
            return xml_str;
        }

        public static PARAM_FrequencyHopTable FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FrequencyHopTable param = new PARAM_FrequencyHopTable();


            val = XmlUtil.GetNodeValue(node, "HopTableID");

            param.HopTableID = Convert.ToByte(val);

            val = XmlUtil.GetNodeValue(node, "Frequency");

            param.Frequency = UInt32Array.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the fixed frequency list that can be used by the Reader. The one-based position of a frequency in the list is defined as its ChannelIndex (i.e. the first frequency is referred to as ChannelIndex one).
    /// </summary>
    public class PARAM_FixedFrequencyTable : Parameter
    {
        public PARAM_FixedFrequencyTable()
        {
            typeID = 148;

        }


        public UInt32Array Frequency = new UInt32Array();
        private Int16 Frequency_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Frequency != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(Frequency.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(Frequency, Frequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FixedFrequencyTable FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FixedFrequencyTable param = new PARAM_FixedFrequencyTable();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32Array), field_len);
            param.Frequency = (UInt32Array)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FixedFrequencyTable>";

            if (Frequency != null)
            {

                xml_str += "<Frequency>" + Frequency.ToString() + "</Frequency>";

            }

            xml_str += "</FixedFrequencyTable>";
            return xml_str;
        }

        public static PARAM_FixedFrequencyTable FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FixedFrequencyTable param = new PARAM_FixedFrequencyTable();


            val = XmlUtil.GetNodeValue(node, "Frequency");

            param.Frequency = UInt32Array.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the information of the Reader inventory and survey operation.
    /// </summary>
    public class PARAM_ROSpec : Parameter
    {
        public PARAM_ROSpec()
        {
            typeID = 177;

        }


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public byte Priority = 0;
        private Int16 Priority_len = 0;

        public
      ENUM_ROSpecState CurrentState;
        private Int16 CurrentState_len = 8;
        public PARAM_ROBoundarySpec ROBoundarySpec;

        public UNION_SpecParameter SpecParameter = new UNION_SpecParameter();

        public PARAM_ROReportSpec ROReportSpec;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Priority != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Priority, Priority_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CurrentState != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentState, CurrentState_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ROBoundarySpec != null)
            {
                ROBoundarySpec.ToBitArray(ref bit_array, ref cursor);

            }

            len = SpecParameter.Count;
            for (int i = 0; i < len; i++) SpecParameter[i].ToBitArray(ref bit_array, ref cursor);

            if (ROReportSpec != null)
            {
                ROReportSpec.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROSpec param = new PARAM_ROSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            param.Priority = (byte)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.CurrentState = (
        ENUM_ROSpecState)(UInt32)obj_val;

            param.ROBoundarySpec = PARAM_ROBoundarySpec.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_AISpec _param_AISpec = PARAM_AISpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AISpec != null)
            {
                param.SpecParameter.Add(_param_AISpec);
                while ((_param_AISpec = PARAM_AISpec.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.SpecParameter.Add(_param_AISpec);
            }

            PARAM_RFSurveySpec _param_RFSurveySpec = PARAM_RFSurveySpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_RFSurveySpec != null)
            {
                param.SpecParameter.Add(_param_RFSurveySpec);
                while ((_param_RFSurveySpec = PARAM_RFSurveySpec.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.SpecParameter.Add(_param_RFSurveySpec);
            }

            ICustom_Parameter sub_custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (sub_custom != null)
            {
                param.SpecParameter.Add(sub_custom);
                while ((sub_custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null)
                    param.SpecParameter.Add(sub_custom);
            }

            param.ROReportSpec = PARAM_ROReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROSpec>";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            if (Priority != null)
            {

                xml_str += "<Priority>" + Priority.ToString() + "</Priority>";

            }

            if (CurrentState != null)
            {

                xml_str += "<CurrentState>" + CurrentState.ToString() + "</CurrentState>";

            }

            if (ROBoundarySpec != null)
            {

                xml_str += ROBoundarySpec.ToString();

            }

            if (SpecParameter != null)
            {
                len = SpecParameter.Count;
                for (int i = 0; i < len; i++) xml_str += SpecParameter[i].ToString();
            }

            if (ROReportSpec != null)
            {

                xml_str += ROReportSpec.ToString();

            }

            xml_str += "</ROSpec>";
            return xml_str;
        }

        public static PARAM_ROSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROSpec param = new PARAM_ROSpec();


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "Priority");

            param.Priority = Convert.ToByte(val);

            val = XmlUtil.GetNodeValue(node, "CurrentState");

            param.CurrentState = (
      ENUM_ROSpecState)Enum.Parse(typeof(
      ENUM_ROSpecState), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROBoundarySpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROBoundarySpec = PARAM_ROBoundarySpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                param.SpecParameter = new UNION_SpecParameter();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AISpec");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.SpecParameter.Add(PARAM_AISpec.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFSurveySpec");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.SpecParameter.Add(PARAM_RFSurveySpec.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Custom");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                            {
                                ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter(xnl[i]);
                                if (custom != null) param.SpecParameter.Add(custom);
                            }
                        }
                    }

                }
                catch { }

            }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROReportSpec = PARAM_ROReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the lifetime of the command, ROStartTrigger and ROStopTrigger parameters.
    /// </summary>
    public class PARAM_ROBoundarySpec : Parameter
    {
        public PARAM_ROBoundarySpec()
        {
            typeID = 178;

        }


        public PARAM_ROSpecStartTrigger ROSpecStartTrigger;

        public PARAM_ROSpecStopTrigger ROSpecStopTrigger;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecStartTrigger != null)
            {
                ROSpecStartTrigger.ToBitArray(ref bit_array, ref cursor);

            }

            if (ROSpecStopTrigger != null)
            {
                ROSpecStopTrigger.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROBoundarySpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROBoundarySpec param = new PARAM_ROBoundarySpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param.ROSpecStartTrigger = PARAM_ROSpecStartTrigger.FromBitArray(ref bit_array, ref cursor, length);

            param.ROSpecStopTrigger = PARAM_ROSpecStopTrigger.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROBoundarySpec>";

            if (ROSpecStartTrigger != null)
            {

                xml_str += ROSpecStartTrigger.ToString();

            }

            if (ROSpecStopTrigger != null)
            {

                xml_str += ROSpecStopTrigger.ToString();

            }

            xml_str += "</ROBoundarySpec>";
            return xml_str;
        }

        public static PARAM_ROBoundarySpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROBoundarySpec param = new PARAM_ROBoundarySpec();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecStartTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecStartTrigger = PARAM_ROSpecStartTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecStopTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecStopTrigger = PARAM_ROSpecStopTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Describes the condition upon which the ROSpec will start execution.
    /// </summary>
    public class PARAM_ROSpecStartTrigger : Parameter
    {
        public PARAM_ROSpecStartTrigger()
        {
            typeID = 179;

        }


        public
      ENUM_ROSpecStartTriggerType ROSpecStartTriggerType;
        private Int16 ROSpecStartTriggerType_len = 8;
        public PARAM_PeriodicTriggerValue PeriodicTriggerValue;

        public PARAM_GPITriggerValue GPITriggerValue;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecStartTriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecStartTriggerType, ROSpecStartTriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (PeriodicTriggerValue != null)
            {
                PeriodicTriggerValue.ToBitArray(ref bit_array, ref cursor);

            }

            if (GPITriggerValue != null)
            {
                GPITriggerValue.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROSpecStartTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROSpecStartTrigger param = new PARAM_ROSpecStartTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecStartTriggerType = (
        ENUM_ROSpecStartTriggerType)(UInt32)obj_val;

            param.PeriodicTriggerValue = PARAM_PeriodicTriggerValue.FromBitArray(ref bit_array, ref cursor, length);

            param.GPITriggerValue = PARAM_GPITriggerValue.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROSpecStartTrigger>";

            if (ROSpecStartTriggerType != null)
            {

                xml_str += "<ROSpecStartTriggerType>" + ROSpecStartTriggerType.ToString() + "</ROSpecStartTriggerType>";

            }

            if (PeriodicTriggerValue != null)
            {

                xml_str += PeriodicTriggerValue.ToString();

            }

            if (GPITriggerValue != null)
            {

                xml_str += GPITriggerValue.ToString();

            }

            xml_str += "</ROSpecStartTrigger>";
            return xml_str;
        }

        public static PARAM_ROSpecStartTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROSpecStartTrigger param = new PARAM_ROSpecStartTrigger();


            val = XmlUtil.GetNodeValue(node, "ROSpecStartTriggerType");

            param.ROSpecStartTriggerType = (
      ENUM_ROSpecStartTriggerType)Enum.Parse(typeof(
      ENUM_ROSpecStartTriggerType), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "PeriodicTriggerValue");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.PeriodicTriggerValue = PARAM_PeriodicTriggerValue.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPITriggerValue");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.GPITriggerValue = PARAM_GPITriggerValue.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Periodic trigger is specified using UTC time, offset and period.For one-shot inventory, period is set to 0, and for periodic inventory operation period &gt; 0.If UTC time is not specified, the first start time is determined as (time of message receipt + offset), else, the first start time is determined as (UTC time + offset). Subsequent start times  = first start time + k * period (where, k &gt; 0).If the Reader does not support UTC clock (as indicated by HasUTCClockCapability), and it receives the UTC time as part of the PeriodicTriggerValue parameter from the Client, the Reader SHALL return an error.
    /// </summary>
    public class PARAM_PeriodicTriggerValue : Parameter
    {
        public PARAM_PeriodicTriggerValue()
        {
            typeID = 180;

        }


        public UInt32 Offset = 0;
        private Int16 Offset_len = 0;

        public UInt32 Period = 0;
        private Int16 Period_len = 0;

        public PARAM_UTCTimestamp UTCTimestamp;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Offset != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Offset, Offset_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Period != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Period, Period_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (UTCTimestamp != null)
            {
                UTCTimestamp.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_PeriodicTriggerValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_PeriodicTriggerValue param = new PARAM_PeriodicTriggerValue();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Offset = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Period = (UInt32)obj_val;

            param.UTCTimestamp = PARAM_UTCTimestamp.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<PeriodicTriggerValue>";

            if (Offset != null)
            {

                xml_str += "<Offset>" + Offset.ToString() + "</Offset>";

            }

            if (Period != null)
            {

                xml_str += "<Period>" + Period.ToString() + "</Period>";

            }

            if (UTCTimestamp != null)
            {

                xml_str += UTCTimestamp.ToString();

            }

            xml_str += "</PeriodicTriggerValue>";
            return xml_str;
        }

        public static PARAM_PeriodicTriggerValue FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_PeriodicTriggerValue param = new PARAM_PeriodicTriggerValue();


            val = XmlUtil.GetNodeValue(node, "Offset");

            param.Offset = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "Period");

            param.Period = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "UTCTimestamp");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.UTCTimestamp = PARAM_UTCTimestamp.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This trigger is tied to an event on the General Purpose Input (GPI) of the Reader. The event is represented as a boolean type, and it is up to the internal implementation of the Reader to map exact physical event to a boolean type. For example, a 0 to 1 and a 1 to 0 transition on an input pin of the Reader could be mapped to a boolean true and a  boolean false event respectively.This trigger parameter has a timeout value field. The timeout is useful for specifying a fail-safe timeout when this trigger is used as a stop trigger. When the timeout is 0, it indicates that there is no timeout. When used as a start trigger, the timeout value SHALL be ignored.Readers that do not support GPIs SHALL return zero for numGPIs in the capabilities discovery. If the Client sets up the GPI trigger for such a Reader, the Reader SHALL send an error message for the ADD_ROSPEC message and not add the ROSpec.
    /// </summary>
    public class PARAM_GPITriggerValue : Parameter
    {
        public PARAM_GPITriggerValue()
        {
            typeID = 181;

        }


        public UInt16 GPIPortNum = 0;
        private Int16 GPIPortNum_len = 0;

        public bool GPIEvent = false;
        private Int16 GPIEvent_len = 0;

        private const UInt16 param_reserved_len = 7;

        public UInt32 Timeout = 0;
        private Int16 Timeout_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (GPIPortNum != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIPortNum, GPIPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (GPIEvent != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIEvent, GPIEvent_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (Timeout != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Timeout, Timeout_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GPITriggerValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPITriggerValue param = new PARAM_GPITriggerValue();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.GPIPortNum = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.GPIEvent = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Timeout = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GPITriggerValue>";

            if (GPIPortNum != null)
            {

                xml_str += "<GPIPortNum>" + GPIPortNum.ToString() + "</GPIPortNum>";

            }

            if (GPIEvent != null)
            {

                xml_str += "<GPIEvent>" + GPIEvent.ToString() + "</GPIEvent>";

            }

            if (Timeout != null)
            {

                xml_str += "<Timeout>" + Timeout.ToString() + "</Timeout>";

            }

            xml_str += "</GPITriggerValue>";
            return xml_str;
        }

        public static PARAM_GPITriggerValue FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GPITriggerValue param = new PARAM_GPITriggerValue();


            val = XmlUtil.GetNodeValue(node, "GPIPortNum");

            param.GPIPortNum = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "GPIEvent");

            param.GPIEvent = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "Timeout");

            param.Timeout = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// Describes the condition upon which the ROSpec will stop.
    /// </summary>
    public class PARAM_ROSpecStopTrigger : Parameter
    {
        public PARAM_ROSpecStopTrigger()
        {
            typeID = 182;

        }


        public
      ENUM_ROSpecStopTriggerType ROSpecStopTriggerType;
        private Int16 ROSpecStopTriggerType_len = 8;
        public UInt32 DurationTriggerValue = 0;
        private Int16 DurationTriggerValue_len = 0;

        public PARAM_GPITriggerValue GPITriggerValue;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecStopTriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecStopTriggerType, ROSpecStopTriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (DurationTriggerValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DurationTriggerValue, DurationTriggerValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (GPITriggerValue != null)
            {
                GPITriggerValue.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROSpecStopTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROSpecStopTrigger param = new PARAM_ROSpecStopTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecStopTriggerType = (
        ENUM_ROSpecStopTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DurationTriggerValue = (UInt32)obj_val;

            param.GPITriggerValue = PARAM_GPITriggerValue.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROSpecStopTrigger>";

            if (ROSpecStopTriggerType != null)
            {

                xml_str += "<ROSpecStopTriggerType>" + ROSpecStopTriggerType.ToString() + "</ROSpecStopTriggerType>";

            }

            if (DurationTriggerValue != null)
            {

                xml_str += "<DurationTriggerValue>" + DurationTriggerValue.ToString() + "</DurationTriggerValue>";

            }

            if (GPITriggerValue != null)
            {

                xml_str += GPITriggerValue.ToString();

            }

            xml_str += "</ROSpecStopTrigger>";
            return xml_str;
        }

        public static PARAM_ROSpecStopTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROSpecStopTrigger param = new PARAM_ROSpecStopTrigger();


            val = XmlUtil.GetNodeValue(node, "ROSpecStopTriggerType");

            param.ROSpecStopTriggerType = (
      ENUM_ROSpecStopTriggerType)Enum.Parse(typeof(
      ENUM_ROSpecStopTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "DurationTriggerValue");

            param.DurationTriggerValue = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPITriggerValue");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.GPITriggerValue = PARAM_GPITriggerValue.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter defines antenna inventory operations.
    /// </summary>
    public class PARAM_AISpec : Parameter
    {
        public PARAM_AISpec()
        {
            typeID = 183;

        }


        public UInt16Array AntennaIDs = new UInt16Array();
        private Int16 AntennaIDs_len = 0;

        public PARAM_AISpecStopTrigger AISpecStopTrigger;

        public PARAM_InventoryParameterSpec[] InventoryParameterSpec;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IAISpec_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaIDs != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(AntennaIDs.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(AntennaIDs, AntennaIDs_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }

            if (AISpecStopTrigger != null)
            {
                AISpecStopTrigger.ToBitArray(ref bit_array, ref cursor);

            }

            if (InventoryParameterSpec != null)
            {

                len = InventoryParameterSpec.Length;
                for (int i = 0; i < len; i++)
                    InventoryParameterSpec[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AISpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AISpec param = new PARAM_AISpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            param.AntennaIDs = (UInt16Array)obj_val;

            param.AISpecStopTrigger = PARAM_AISpecStopTrigger.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_InventoryParameterSpec _param_InventoryParameterSpec = PARAM_InventoryParameterSpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_InventoryParameterSpec != null)
            {
                param_list.Add(_param_InventoryParameterSpec);
                while ((_param_InventoryParameterSpec = PARAM_InventoryParameterSpec.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_InventoryParameterSpec);
                if (param_list.Count > 0)
                {
                    param.InventoryParameterSpec = new PARAM_InventoryParameterSpec[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.InventoryParameterSpec[i] = (PARAM_InventoryParameterSpec)param_list[i];
                }
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AISpec>";

            if (AntennaIDs != null)
            {

                xml_str += "<AntennaIDs>" + AntennaIDs.ToString() + "</AntennaIDs>";

            }

            if (AISpecStopTrigger != null)
            {

                xml_str += AISpecStopTrigger.ToString();

            }

            if (InventoryParameterSpec != null)
            {

                len = InventoryParameterSpec.Length;
                for (int i = 0; i < len; i++)
                    xml_str += InventoryParameterSpec[i].ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</AISpec>";
            return xml_str;
        }

        public static PARAM_AISpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AISpec param = new PARAM_AISpec();


            val = XmlUtil.GetNodeValue(node, "AntennaIDs");

            param.AntennaIDs = UInt16Array.FromString(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AISpecStopTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AISpecStopTrigger = PARAM_AISpecStopTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "InventoryParameterSpec");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.InventoryParameterSpec = new PARAM_InventoryParameterSpec[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.InventoryParameterSpec[i] = PARAM_InventoryParameterSpec.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter defines the stop (i.e., terminating boundary) of an antenna inventory operation.
    /// </summary>
    public class PARAM_AISpecStopTrigger : Parameter
    {
        public PARAM_AISpecStopTrigger()
        {
            typeID = 184;

        }


        public
      ENUM_AISpecStopTriggerType AISpecStopTriggerType;
        private Int16 AISpecStopTriggerType_len = 8;
        public UInt32 DurationTrigger = 0;
        private Int16 DurationTrigger_len = 0;

        public PARAM_GPITriggerValue GPITriggerValue;

        public PARAM_TagObservationTrigger TagObservationTrigger;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AISpecStopTriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AISpecStopTriggerType, AISpecStopTriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (DurationTrigger != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DurationTrigger, DurationTrigger_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (GPITriggerValue != null)
            {
                GPITriggerValue.ToBitArray(ref bit_array, ref cursor);

            }

            if (TagObservationTrigger != null)
            {
                TagObservationTrigger.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AISpecStopTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AISpecStopTrigger param = new PARAM_AISpecStopTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AISpecStopTriggerType = (
        ENUM_AISpecStopTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DurationTrigger = (UInt32)obj_val;

            param.GPITriggerValue = PARAM_GPITriggerValue.FromBitArray(ref bit_array, ref cursor, length);

            param.TagObservationTrigger = PARAM_TagObservationTrigger.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AISpecStopTrigger>";

            if (AISpecStopTriggerType != null)
            {

                xml_str += "<AISpecStopTriggerType>" + AISpecStopTriggerType.ToString() + "</AISpecStopTriggerType>";

            }

            if (DurationTrigger != null)
            {

                xml_str += "<DurationTrigger>" + DurationTrigger.ToString() + "</DurationTrigger>";

            }

            if (GPITriggerValue != null)
            {

                xml_str += GPITriggerValue.ToString();

            }

            if (TagObservationTrigger != null)
            {

                xml_str += TagObservationTrigger.ToString();

            }

            xml_str += "</AISpecStopTrigger>";
            return xml_str;
        }

        public static PARAM_AISpecStopTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AISpecStopTrigger param = new PARAM_AISpecStopTrigger();


            val = XmlUtil.GetNodeValue(node, "AISpecStopTriggerType");

            param.AISpecStopTriggerType = (
      ENUM_AISpecStopTriggerType)Enum.Parse(typeof(
      ENUM_AISpecStopTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "DurationTrigger");

            param.DurationTrigger = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPITriggerValue");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.GPITriggerValue = PARAM_GPITriggerValue.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagObservationTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.TagObservationTrigger = PARAM_TagObservationTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Describes the boundary (stop) condition that is based on tag observations.
    /// </summary>
    public class PARAM_TagObservationTrigger : Parameter
    {
        public PARAM_TagObservationTrigger()
        {
            typeID = 185;

        }


        public
      ENUM_TagObservationTriggerType TriggerType;
        private Int16 TriggerType_len = 8;
        private const UInt16 param_reserved_len = 8;

        public UInt16 NumberOfTags = 0;
        private Int16 NumberOfTags_len = 0;

        public UInt16 NumberOfAttempts = 0;
        private Int16 NumberOfAttempts_len = 0;

        public UInt16 T = 0;
        private Int16 T_len = 0;

        public UInt32 Timeout = 0;
        private Int16 Timeout_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (TriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TriggerType, TriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (NumberOfTags != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumberOfTags, NumberOfTags_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NumberOfAttempts != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumberOfAttempts, NumberOfAttempts_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (T != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(T, T_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Timeout != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Timeout, Timeout_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_TagObservationTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TagObservationTrigger param = new PARAM_TagObservationTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.TriggerType = (
        ENUM_TagObservationTriggerType)(UInt32)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumberOfTags = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumberOfAttempts = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.T = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Timeout = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<TagObservationTrigger>";

            if (TriggerType != null)
            {

                xml_str += "<TriggerType>" + TriggerType.ToString() + "</TriggerType>";

            }

            if (NumberOfTags != null)
            {

                xml_str += "<NumberOfTags>" + NumberOfTags.ToString() + "</NumberOfTags>";

            }

            if (NumberOfAttempts != null)
            {

                xml_str += "<NumberOfAttempts>" + NumberOfAttempts.ToString() + "</NumberOfAttempts>";

            }

            if (T != null)
            {

                xml_str += "<T>" + T.ToString() + "</T>";

            }

            if (Timeout != null)
            {

                xml_str += "<Timeout>" + Timeout.ToString() + "</Timeout>";

            }

            xml_str += "</TagObservationTrigger>";
            return xml_str;
        }

        public static PARAM_TagObservationTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_TagObservationTrigger param = new PARAM_TagObservationTrigger();


            val = XmlUtil.GetNodeValue(node, "TriggerType");

            param.TriggerType = (
      ENUM_TagObservationTriggerType)Enum.Parse(typeof(
      ENUM_TagObservationTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "NumberOfTags");

            param.NumberOfTags = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NumberOfAttempts");

            param.NumberOfAttempts = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "T");

            param.T = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "Timeout");

            param.Timeout = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter defines the inventory operation to be performed at all antennas specified in the corresponding AISpec. This parameter is composed of an InventoryParameterSpecID, a ProtocolID, and zero or more optional antenna configuration parameters. Antenna configurations for antennas not indicated by the AntennaIDs within the AISpec are ignored by the reader.
    /// </summary>
    public class PARAM_InventoryParameterSpec : Parameter
    {
        public PARAM_InventoryParameterSpec()
        {
            typeID = 186;

        }


        public UInt16 InventoryParameterSpecID = 0;
        private Int16 InventoryParameterSpecID_len = 0;

        public
      ENUM_AirProtocols ProtocolID;
        private Int16 ProtocolID_len = 8;
        public PARAM_AntennaConfiguration[] AntennaConfiguration;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IInventoryParameterSpec_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (InventoryParameterSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(InventoryParameterSpecID, InventoryParameterSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ProtocolID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ProtocolID, ProtocolID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    AntennaConfiguration[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_InventoryParameterSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_InventoryParameterSpec param = new PARAM_InventoryParameterSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.InventoryParameterSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ProtocolID = (
        ENUM_AirProtocols)(UInt32)obj_val;

            param_list = new ArrayList();
            PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AntennaConfiguration != null)
            {
                param_list.Add(_param_AntennaConfiguration);
                while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AntennaConfiguration);
                if (param_list.Count > 0)
                {
                    param.AntennaConfiguration = new PARAM_AntennaConfiguration[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.AntennaConfiguration[i] = (PARAM_AntennaConfiguration)param_list[i];
                }
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<InventoryParameterSpec>";

            if (InventoryParameterSpecID != null)
            {

                xml_str += "<InventoryParameterSpecID>" + InventoryParameterSpecID.ToString() + "</InventoryParameterSpecID>";

            }

            if (ProtocolID != null)
            {

                xml_str += "<ProtocolID>" + ProtocolID.ToString() + "</ProtocolID>";

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AntennaConfiguration[i].ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</InventoryParameterSpec>";
            return xml_str;
        }

        public static PARAM_InventoryParameterSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_InventoryParameterSpec param = new PARAM_InventoryParameterSpec();


            val = XmlUtil.GetNodeValue(node, "InventoryParameterSpecID");

            param.InventoryParameterSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ProtocolID");

            param.ProtocolID = (
      ENUM_AirProtocols)Enum.Parse(typeof(
      ENUM_AirProtocols), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaConfiguration");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.AntennaConfiguration = new PARAM_AntennaConfiguration[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.AntennaConfiguration[i] = PARAM_AntennaConfiguration.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter defines RF Survey operations. RF Survey is an operation during which the Reader performs a scan and measures the power levels across a set of frequencies at an antenna. This parameter defines the identifier of the antenna where this survey is to be performed, the duration of the survey operation (specified via stop trigger), and the range of frequencies to measure power levels of.
    /// </summary>
    public class PARAM_RFSurveySpec : Parameter
    {
        public PARAM_RFSurveySpec()
        {
            typeID = 187;

        }


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public UInt32 StartFrequency = 0;
        private Int16 StartFrequency_len = 0;

        public UInt32 EndFrequency = 0;
        private Int16 EndFrequency_len = 0;

        public PARAM_RFSurveySpecStopTrigger RFSurveySpecStopTrigger;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IRFSurveySpec_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (StartFrequency != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StartFrequency, StartFrequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EndFrequency != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EndFrequency, EndFrequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (RFSurveySpecStopTrigger != null)
            {
                RFSurveySpecStopTrigger.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFSurveySpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFSurveySpec param = new PARAM_RFSurveySpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.StartFrequency = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EndFrequency = (UInt32)obj_val;

            param.RFSurveySpecStopTrigger = PARAM_RFSurveySpecStopTrigger.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFSurveySpec>";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (StartFrequency != null)
            {

                xml_str += "<StartFrequency>" + StartFrequency.ToString() + "</StartFrequency>";

            }

            if (EndFrequency != null)
            {

                xml_str += "<EndFrequency>" + EndFrequency.ToString() + "</EndFrequency>";

            }

            if (RFSurveySpecStopTrigger != null)
            {

                xml_str += RFSurveySpecStopTrigger.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</RFSurveySpec>";
            return xml_str;
        }

        public static PARAM_RFSurveySpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFSurveySpec param = new PARAM_RFSurveySpec();


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "StartFrequency");

            param.StartFrequency = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "EndFrequency");

            param.EndFrequency = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFSurveySpecStopTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.RFSurveySpecStopTrigger = PARAM_RFSurveySpecStopTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter defines the stop trigger for RF Survey operations.
    /// </summary>
    public class PARAM_RFSurveySpecStopTrigger : Parameter
    {
        public PARAM_RFSurveySpecStopTrigger()
        {
            typeID = 188;

        }


        public
      ENUM_RFSurveySpecStopTriggerType StopTriggerType;
        private Int16 StopTriggerType_len = 8;
        public UInt32 DurationPeriod = 0;
        private Int16 DurationPeriod_len = 0;

        public UInt32 N = 0;
        private Int16 N_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (StopTriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StopTriggerType, StopTriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (DurationPeriod != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DurationPeriod, DurationPeriod_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (N != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(N, N_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFSurveySpecStopTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFSurveySpecStopTrigger param = new PARAM_RFSurveySpecStopTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.StopTriggerType = (
        ENUM_RFSurveySpecStopTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DurationPeriod = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.N = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFSurveySpecStopTrigger>";

            if (StopTriggerType != null)
            {

                xml_str += "<StopTriggerType>" + StopTriggerType.ToString() + "</StopTriggerType>";

            }

            if (DurationPeriod != null)
            {

                xml_str += "<DurationPeriod>" + DurationPeriod.ToString() + "</DurationPeriod>";

            }

            if (N != null)
            {

                xml_str += "<N>" + N.ToString() + "</N>";

            }

            xml_str += "</RFSurveySpecStopTrigger>";
            return xml_str;
        }

        public static PARAM_RFSurveySpecStopTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFSurveySpecStopTrigger param = new PARAM_RFSurveySpecStopTrigger();


            val = XmlUtil.GetNodeValue(node, "StopTriggerType");

            param.StopTriggerType = (
      ENUM_RFSurveySpecStopTriggerType)Enum.Parse(typeof(
      ENUM_RFSurveySpecStopTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "DurationPeriod");

            param.DurationPeriod = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "N");

            param.N = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries information of the Reader access operation.
    /// </summary>
    public class PARAM_AccessSpec : Parameter
    {
        public PARAM_AccessSpec()
        {
            typeID = 207;

        }


        public UInt32 AccessSpecID = 0;
        private Int16 AccessSpecID_len = 0;

        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public
      ENUM_AirProtocols ProtocolID;
        private Int16 ProtocolID_len = 8;
        public
      ENUM_AccessSpecState CurrentState;
        private Int16 CurrentState_len = 1;
        private const UInt16 param_reserved_len = 7;

        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public PARAM_AccessSpecStopTrigger AccessSpecStopTrigger;

        public PARAM_AccessCommand AccessCommand;

        public PARAM_AccessReportSpec AccessReportSpec;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IAccessSpec_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AccessSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ProtocolID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ProtocolID, ProtocolID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CurrentState != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CurrentState, CurrentState_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessSpecStopTrigger != null)
            {
                AccessSpecStopTrigger.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessCommand != null)
            {
                AccessCommand.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessReportSpec != null)
            {
                AccessReportSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AccessSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AccessSpec param = new PARAM_AccessSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessSpecID = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ProtocolID = (
        ENUM_AirProtocols)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.CurrentState = (
        ENUM_AccessSpecState)(UInt32)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            param.AccessSpecStopTrigger = PARAM_AccessSpecStopTrigger.FromBitArray(ref bit_array, ref cursor, length);

            param.AccessCommand = PARAM_AccessCommand.FromBitArray(ref bit_array, ref cursor, length);

            param.AccessReportSpec = PARAM_AccessReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AccessSpec>";

            if (AccessSpecID != null)
            {

                xml_str += "<AccessSpecID>" + AccessSpecID.ToString() + "</AccessSpecID>";

            }

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (ProtocolID != null)
            {

                xml_str += "<ProtocolID>" + ProtocolID.ToString() + "</ProtocolID>";

            }

            if (CurrentState != null)
            {

                xml_str += "<CurrentState>" + CurrentState.ToString() + "</CurrentState>";

            }

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            if (AccessSpecStopTrigger != null)
            {

                xml_str += AccessSpecStopTrigger.ToString();

            }

            if (AccessCommand != null)
            {

                xml_str += AccessCommand.ToString();

            }

            if (AccessReportSpec != null)
            {

                xml_str += AccessReportSpec.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</AccessSpec>";
            return xml_str;
        }

        public static PARAM_AccessSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AccessSpec param = new PARAM_AccessSpec();


            val = XmlUtil.GetNodeValue(node, "AccessSpecID");

            param.AccessSpecID = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ProtocolID");

            param.ProtocolID = (
      ENUM_AirProtocols)Enum.Parse(typeof(
      ENUM_AirProtocols), val);

            val = XmlUtil.GetNodeValue(node, "CurrentState");

            param.CurrentState = (
      ENUM_AccessSpecState)Enum.Parse(typeof(
      ENUM_AccessSpecState), val);

            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpecStopTrigger");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AccessSpecStopTrigger = PARAM_AccessSpecStopTrigger.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessCommand");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AccessCommand = PARAM_AccessCommand.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AccessReportSpec = PARAM_AccessReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Defines the condition upon which an AccessSpec will be automatically deletedOperationCountValue:  A count to indicate the number of times this Spec is executed before it is deleted. If set to zero, this is equivalent to no stop trigger defined.
    /// </summary>
    public class PARAM_AccessSpecStopTrigger : Parameter
    {
        public PARAM_AccessSpecStopTrigger()
        {
            typeID = 208;

        }


        public
      ENUM_AccessSpecStopTriggerType AccessSpecStopTrigger;
        private Int16 AccessSpecStopTrigger_len = 8;
        public UInt16 OperationCountValue = 0;
        private Int16 OperationCountValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AccessSpecStopTrigger != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecStopTrigger, AccessSpecStopTrigger_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OperationCountValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OperationCountValue, OperationCountValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AccessSpecStopTrigger FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AccessSpecStopTrigger param = new PARAM_AccessSpecStopTrigger();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessSpecStopTrigger = (
        ENUM_AccessSpecStopTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OperationCountValue = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AccessSpecStopTrigger>";

            if (AccessSpecStopTrigger != null)
            {

                xml_str += "<AccessSpecStopTrigger>" + AccessSpecStopTrigger.ToString() + "</AccessSpecStopTrigger>";

            }

            if (OperationCountValue != null)
            {

                xml_str += "<OperationCountValue>" + OperationCountValue.ToString() + "</OperationCountValue>";

            }

            xml_str += "</AccessSpecStopTrigger>";
            return xml_str;
        }

        public static PARAM_AccessSpecStopTrigger FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AccessSpecStopTrigger param = new PARAM_AccessSpecStopTrigger();


            val = XmlUtil.GetNodeValue(node, "AccessSpecStopTrigger");

            param.AccessSpecStopTrigger = (
      ENUM_AccessSpecStopTriggerType)Enum.Parse(typeof(
      ENUM_AccessSpecStopTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "OperationCountValue");

            param.OperationCountValue = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter defines the air protocol access-specific settings. It contains a TagSpec and an OpSpec Parameter. The TagSpec specifies the tag filters in terms of air protocol specific memory capabilities (e.g., memory banks, pointer and length). The OpSpec specifies all the details of the operations required for the air protocol specific access operation commands. In case there are multiple AccessSpecs that get matched during a TagSpec lookup, the Reader SHALL only execute the first enabled AccessSpec that matches, where the ordering of the AccessSpecs is the order in which the AccessSpecs were created by the Client.The order of execution of OpSpecs within an AccessSpec is the order in which the OpSpecs were set up in the AccessSpec. If an OpSpec execution fails, the Reader SHALL stop the execution of the AccessSpec.
    /// </summary>
    public class PARAM_AccessCommand : Parameter
    {
        public PARAM_AccessCommand()
        {
            typeID = 209;

        }


        public UNION_AirProtocolTagSpec AirProtocolTagSpec = new UNION_AirProtocolTagSpec();

        public UNION_AccessCommandOpSpec AccessCommandOpSpec = new UNION_AccessCommandOpSpec();

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IAccessCommand_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            len = AirProtocolTagSpec.Count;
            for (int i = 0; i < len; i++) AirProtocolTagSpec[i].ToBitArray(ref bit_array, ref cursor);

            len = AccessCommandOpSpec.Count;
            for (int i = 0; i < len; i++) AccessCommandOpSpec[i].ToBitArray(ref bit_array, ref cursor);

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AccessCommand FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AccessCommand param = new PARAM_AccessCommand();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            PARAM_C1G2TagSpec _param_C1G2TagSpec = PARAM_C1G2TagSpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2TagSpec != null)
            {
                param.AirProtocolTagSpec.Add(_param_C1G2TagSpec);
                while ((_param_C1G2TagSpec = PARAM_C1G2TagSpec.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolTagSpec.Add(_param_C1G2TagSpec);
            }

            PARAM_C1G2Read _param_C1G2Read = PARAM_C1G2Read.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2Read != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2Read);
                while ((_param_C1G2Read = PARAM_C1G2Read.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2Read);
            }

            PARAM_C1G2Write _param_C1G2Write = PARAM_C1G2Write.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2Write != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2Write);
                while ((_param_C1G2Write = PARAM_C1G2Write.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2Write);
            }

            PARAM_C1G2Kill _param_C1G2Kill = PARAM_C1G2Kill.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2Kill != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2Kill);
                while ((_param_C1G2Kill = PARAM_C1G2Kill.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2Kill);
            }

            PARAM_C1G2Lock _param_C1G2Lock = PARAM_C1G2Lock.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2Lock != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2Lock);
                while ((_param_C1G2Lock = PARAM_C1G2Lock.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2Lock);
            }

            PARAM_C1G2BlockErase _param_C1G2BlockErase = PARAM_C1G2BlockErase.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2BlockErase != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2BlockErase);
                while ((_param_C1G2BlockErase = PARAM_C1G2BlockErase.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2BlockErase);
            }

            PARAM_C1G2BlockWrite _param_C1G2BlockWrite = PARAM_C1G2BlockWrite.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2BlockWrite != null)
            {
                param.AccessCommandOpSpec.Add(_param_C1G2BlockWrite);
                while ((_param_C1G2BlockWrite = PARAM_C1G2BlockWrite.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpec.Add(_param_C1G2BlockWrite);
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AccessCommand>";

            if (AirProtocolTagSpec != null)
            {
                len = AirProtocolTagSpec.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolTagSpec[i].ToString();
            }

            if (AccessCommandOpSpec != null)
            {
                len = AccessCommandOpSpec.Count;
                for (int i = 0; i < len; i++) xml_str += AccessCommandOpSpec[i].ToString();
            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</AccessCommand>";
            return xml_str;
        }

        public static PARAM_AccessCommand FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AccessCommand param = new PARAM_AccessCommand();


            {

                param.AirProtocolTagSpec = new UNION_AirProtocolTagSpec();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TagSpec");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolTagSpec.Add(PARAM_C1G2TagSpec.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            {

                param.AccessCommandOpSpec = new UNION_AccessCommandOpSpec();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2Read");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2Read.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2Write");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2Write.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2Kill");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2Kill.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2Lock");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2Lock.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2BlockErase");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2BlockErase.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2BlockWrite");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpec.Add(PARAM_C1G2BlockWrite.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter, LLRPConfigurationStateValue, is a 32-bit value which represents a Reader's entire LLRP configuration state including: LLRP configuration parameters, vendor extension configuration parameters, ROSpecs, and AccessSpecs.  A Reader SHALL change this value only:A Reader SHALL not change this value when the CurrentState of a ROSpec or AccessSpec changes.The mechanism used to compute the LLRP configuration state value is implementation dependent.  However, a good implementation will insure that there's a high probability that the value will change when the Reader's configuration state changes.It is expected that a Client will configure the Reader and then request the Reader's configuration state value.  The Client will then save this state value. If this value does not change between two requests for it, then a Client may assume that the above components of the LLRP configuration have also not changed.When requested by a Client, the Reader SHALL compute a state value based upon the Reader's current configuration state.  Upon each request, the Reader SHALL return the same state value provided a Client has not altered the Reader's configuration state between requests.  Aside from this requirement, the computation of the state value is implementation dependent.
    /// </summary>
    public class PARAM_LLRPConfigurationStateValue : Parameter
    {
        public PARAM_LLRPConfigurationStateValue()
        {
            typeID = 217;

        }


        public UInt32 LLRPConfigurationStateValue = 0;
        private Int16 LLRPConfigurationStateValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (LLRPConfigurationStateValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(LLRPConfigurationStateValue, LLRPConfigurationStateValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_LLRPConfigurationStateValue FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_LLRPConfigurationStateValue param = new PARAM_LLRPConfigurationStateValue();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.LLRPConfigurationStateValue = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<LLRPConfigurationStateValue>";

            if (LLRPConfigurationStateValue != null)
            {

                xml_str += "<LLRPConfigurationStateValue>" + LLRPConfigurationStateValue.ToString() + "</LLRPConfigurationStateValue>";

            }

            xml_str += "</LLRPConfigurationStateValue>";
            return xml_str;
        }

        public static PARAM_LLRPConfigurationStateValue FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_LLRPConfigurationStateValue param = new PARAM_LLRPConfigurationStateValue();


            val = XmlUtil.GetNodeValue(node, "LLRPConfigurationStateValue");

            param.LLRPConfigurationStateValue = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries an identification parameter that is unique within the local administration domain.  The identifier could be the Reader MAC address or EPC. The IDType defines the type of the identification value contained in this Parameter.If IDType=0, the MAC address SHALL be encoded as  EUI-64.[EUI64]
    /// </summary>
    public class PARAM_Identification : Parameter
    {
        public PARAM_Identification()
        {
            typeID = 218;

        }


        public
      ENUM_IdentificationType IDType;
        private Int16 IDType_len = 8;
        public ByteArray ReaderID = new ByteArray();
        private Int16 ReaderID_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (IDType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(IDType, IDType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReaderID != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReaderID.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReaderID, ReaderID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_Identification FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_Identification param = new PARAM_Identification();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.IDType = (
        ENUM_IdentificationType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            param.ReaderID = (ByteArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<Identification>";

            if (IDType != null)
            {

                xml_str += "<IDType>" + IDType.ToString() + "</IDType>";

            }

            if (ReaderID != null)
            {

                xml_str += "<ReaderID>" + ReaderID.ToHexString() + "</ReaderID>";

            }

            xml_str += "</Identification>";
            return xml_str;
        }

        public static PARAM_Identification FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_Identification param = new PARAM_Identification();


            val = XmlUtil.GetNodeValue(node, "IDType");

            param.IDType = (
      ENUM_IdentificationType)Enum.Parse(typeof(
      ENUM_IdentificationType), val);

            val = XmlUtil.GetNodeValue(node, "ReaderID");

            param.ReaderID = ByteArray.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the data pertinent to perform the write to a general purpose output port.Readers that do not support GPOs SHALL set NumGPOs in the GPIOCapabilities to zero. If such a Reader receives a SET_READER_CONFIG with GPOWriteData Parameter, the Reader SHALL return an error message and not process any of the parameters in that message.
    /// </summary>
    public class PARAM_GPOWriteData : Parameter
    {
        public PARAM_GPOWriteData()
        {
            typeID = 219;

        }


        public UInt16 GPOPortNumber = 0;
        private Int16 GPOPortNumber_len = 0;

        public bool GPOData = false;
        private Int16 GPOData_len = 0;

        private const UInt16 param_reserved_len = 7;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (GPOPortNumber != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPOPortNumber, GPOPortNumber_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (GPOData != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPOData, GPOData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GPOWriteData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPOWriteData param = new PARAM_GPOWriteData();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.GPOPortNumber = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.GPOData = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GPOWriteData>";

            if (GPOPortNumber != null)
            {

                xml_str += "<GPOPortNumber>" + GPOPortNumber.ToString() + "</GPOPortNumber>";

            }

            if (GPOData != null)
            {

                xml_str += "<GPOData>" + GPOData.ToString() + "</GPOData>";

            }

            xml_str += "</GPOWriteData>";
            return xml_str;
        }

        public static PARAM_GPOWriteData FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GPOWriteData param = new PARAM_GPOWriteData();


            val = XmlUtil.GetNodeValue(node, "GPOPortNumber");

            param.GPOPortNumber = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "GPOData");

            param.GPOData = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the specification for the keepalive message generation by the Reader. This includes the definition of the periodic trigger to send the keepalive message.
    /// </summary>
    public class PARAM_KeepaliveSpec : Parameter
    {
        public PARAM_KeepaliveSpec()
        {
            typeID = 220;

        }


        public
      ENUM_KeepaliveTriggerType KeepaliveTriggerType;
        private Int16 KeepaliveTriggerType_len = 8;
        public UInt32 PeriodicTriggerValue = 0;
        private Int16 PeriodicTriggerValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (KeepaliveTriggerType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KeepaliveTriggerType, KeepaliveTriggerType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (PeriodicTriggerValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PeriodicTriggerValue, PeriodicTriggerValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_KeepaliveSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_KeepaliveSpec param = new PARAM_KeepaliveSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.KeepaliveTriggerType = (
        ENUM_KeepaliveTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.PeriodicTriggerValue = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<KeepaliveSpec>";

            if (KeepaliveTriggerType != null)
            {

                xml_str += "<KeepaliveTriggerType>" + KeepaliveTriggerType.ToString() + "</KeepaliveTriggerType>";

            }

            if (PeriodicTriggerValue != null)
            {

                xml_str += "<PeriodicTriggerValue>" + PeriodicTriggerValue.ToString() + "</PeriodicTriggerValue>";

            }

            xml_str += "</KeepaliveSpec>";
            return xml_str;
        }

        public static PARAM_KeepaliveSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_KeepaliveSpec param = new PARAM_KeepaliveSpec();


            val = XmlUtil.GetNodeValue(node, "KeepaliveTriggerType");

            param.KeepaliveTriggerType = (
      ENUM_KeepaliveTriggerType)Enum.Parse(typeof(
      ENUM_KeepaliveTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "PeriodicTriggerValue");

            param.PeriodicTriggerValue = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries a single antenna's properties. The properties include the gain and the connectivity status of the antenna.The antenna gain is the composite gain and includes the loss of the associated cable from the Reader to the antenna. The gain is represented in dBi*100 to allow fractional dBi representation.
    /// </summary>
    public class PARAM_AntennaProperties : Parameter
    {
        public PARAM_AntennaProperties()
        {
            typeID = 221;

        }


        public bool AntennaConnected = false;
        private Int16 AntennaConnected_len = 0;

        private const UInt16 param_reserved_len = 7;

        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public Int16 AntennaGain = 0;
        private Int16 AntennaGain_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaConnected != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaConnected, AntennaConnected_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AntennaGain != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaGain, AntennaGain_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AntennaProperties FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaProperties param = new PARAM_AntennaProperties();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.AntennaConnected = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(Int16), field_len);
            param.AntennaGain = (Int16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AntennaProperties>";

            if (AntennaConnected != null)
            {

                xml_str += "<AntennaConnected>" + AntennaConnected.ToString() + "</AntennaConnected>";

            }

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (AntennaGain != null)
            {

                xml_str += "<AntennaGain>" + AntennaGain.ToString() + "</AntennaGain>";

            }

            xml_str += "</AntennaProperties>";
            return xml_str;
        }

        public static PARAM_AntennaProperties FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AntennaProperties param = new PARAM_AntennaProperties();


            val = XmlUtil.GetNodeValue(node, "AntennaConnected");

            param.AntennaConnected = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AntennaGain");

            param.AntennaGain = Convert.ToInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries a single antenna's configuration and it specifies the default values for the parameter set that are passed in this parameter block. The scope of the default values is the antenna. The default values are used for parameters during an operation on this antenna if the parameter was unspecified in the spec that describes the operation.
    /// </summary>
    public class PARAM_AntennaConfiguration : Parameter
    {
        public PARAM_AntennaConfiguration()
        {
            typeID = 222;

        }


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public PARAM_RFReceiver RFReceiver;

        public PARAM_RFTransmitter RFTransmitter;

        public UNION_AirProtocolInventoryCommandSettings AirProtocolInventoryCommandSettings = new UNION_AirProtocolInventoryCommandSettings();

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (RFReceiver != null)
            {
                RFReceiver.ToBitArray(ref bit_array, ref cursor);

            }

            if (RFTransmitter != null)
            {
                RFTransmitter.ToBitArray(ref bit_array, ref cursor);

            }

            len = AirProtocolInventoryCommandSettings.Count;
            for (int i = 0; i < len; i++) AirProtocolInventoryCommandSettings[i].ToBitArray(ref bit_array, ref cursor);


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AntennaConfiguration FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaConfiguration param = new PARAM_AntennaConfiguration();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            param.RFReceiver = PARAM_RFReceiver.FromBitArray(ref bit_array, ref cursor, length);

            param.RFTransmitter = PARAM_RFTransmitter.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_C1G2InventoryCommand _param_C1G2InventoryCommand = PARAM_C1G2InventoryCommand.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2InventoryCommand != null)
            {
                param.AirProtocolInventoryCommandSettings.Add(_param_C1G2InventoryCommand);
                while ((_param_C1G2InventoryCommand = PARAM_C1G2InventoryCommand.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolInventoryCommandSettings.Add(_param_C1G2InventoryCommand);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AntennaConfiguration>";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (RFReceiver != null)
            {

                xml_str += RFReceiver.ToString();

            }

            if (RFTransmitter != null)
            {

                xml_str += RFTransmitter.ToString();

            }

            if (AirProtocolInventoryCommandSettings != null)
            {
                len = AirProtocolInventoryCommandSettings.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolInventoryCommandSettings[i].ToString();
            }

            xml_str += "</AntennaConfiguration>";
            return xml_str;
        }

        public static PARAM_AntennaConfiguration FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AntennaConfiguration param = new PARAM_AntennaConfiguration();


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFReceiver");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.RFReceiver = PARAM_RFReceiver.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFTransmitter");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.RFTransmitter = PARAM_RFTransmitter.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                param.AirProtocolInventoryCommandSettings = new UNION_AirProtocolInventoryCommandSettings();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2InventoryCommand");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolInventoryCommandSettings.Add(PARAM_C1G2InventoryCommand.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            return param;
        }

    }

    /// <summary>
    /// This Parameter carries the RF receiver information. The Receiver Sensitivity defines the sensitivity setting at the receiver. The value is the index into the ReceiveSensitivityTable (section 9.2.1.1).
    /// </summary>
    public class PARAM_RFReceiver : Parameter
    {
        public PARAM_RFReceiver()
        {
            typeID = 223;

        }


        public UInt16 ReceiverSensitivity = 0;
        private Int16 ReceiverSensitivity_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ReceiverSensitivity != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReceiverSensitivity, ReceiverSensitivity_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFReceiver FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFReceiver param = new PARAM_RFReceiver();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ReceiverSensitivity = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFReceiver>";

            if (ReceiverSensitivity != null)
            {

                xml_str += "<ReceiverSensitivity>" + ReceiverSensitivity.ToString() + "</ReceiverSensitivity>";

            }

            xml_str += "</RFReceiver>";
            return xml_str;
        }

        public static PARAM_RFReceiver FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFReceiver param = new PARAM_RFReceiver();


            val = XmlUtil.GetNodeValue(node, "ReceiverSensitivity");

            param.ReceiverSensitivity = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This Parameter carries the RF transmitter information. The Transmit Power defines the transmit power for the antenna expressed as an index into the TransmitPowerTable (section 9.2.4.1.1). The HopTableID is the index of the frequency hop table to be used by the Reader (section 9.2.4.1.2.1) and is used when operating in frequency-hopping regulatory regions. This field is ignored in non-frequency-hopping regulatory regions. The ChannelIndex is the one-based channel index in the FixedFrequencyTable to use during transmission (section 9.2.4.1.2.2) and is used when operating in non-frequency-hopping regulatory regions. This field is ignored in frequency-hopping regulatory regions.
    /// </summary>
    public class PARAM_RFTransmitter : Parameter
    {
        public PARAM_RFTransmitter()
        {
            typeID = 224;

        }


        public UInt16 HopTableID = 0;
        private Int16 HopTableID_len = 0;

        public UInt16 ChannelIndex = 0;
        private Int16 ChannelIndex_len = 0;

        public UInt16 TransmitPower = 0;
        private Int16 TransmitPower_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (HopTableID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HopTableID, HopTableID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ChannelIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ChannelIndex, ChannelIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TransmitPower != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TransmitPower, TransmitPower_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFTransmitter FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFTransmitter param = new PARAM_RFTransmitter();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.HopTableID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ChannelIndex = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.TransmitPower = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFTransmitter>";

            if (HopTableID != null)
            {

                xml_str += "<HopTableID>" + HopTableID.ToString() + "</HopTableID>";

            }

            if (ChannelIndex != null)
            {

                xml_str += "<ChannelIndex>" + ChannelIndex.ToString() + "</ChannelIndex>";

            }

            if (TransmitPower != null)
            {

                xml_str += "<TransmitPower>" + TransmitPower.ToString() + "</TransmitPower>";

            }

            xml_str += "</RFTransmitter>";
            return xml_str;
        }

        public static PARAM_RFTransmitter FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFTransmitter param = new PARAM_RFTransmitter();


            val = XmlUtil.GetNodeValue(node, "HopTableID");

            param.HopTableID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ChannelIndex");

            param.ChannelIndex = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "TransmitPower");

            param.TransmitPower = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This Parameter carries the current configuration and state of a single GPI port.  In a SET_READER_CONFIG message, this parameter is used to enable or disable the GPI port using the GPIConfig field; the GPIState field is ignored by the reader.  In a GET_READER_CONFIG message, this parameter reports both the configuration and state of the GPI port.When a ROSpec or AISpec is configured on a GPI-capable reader with GPI start and/or stop triggers, those GPIs must be enabled by the client with a SET_READER_CONFIG message for the triggers to function.Readers that do not support GPIs SHALL set NumGPIs in the GPIOCapabilities to zero. If such a Reader receives a GET_READER_CONFIG with a GPIPortCurrentState Parameter, the Reader SHALL return an error message and not process any of the parameters in that message.
    /// </summary>
    public class PARAM_GPIPortCurrentState : Parameter
    {
        public PARAM_GPIPortCurrentState()
        {
            typeID = 225;

        }


        public UInt16 GPIPortNum = 0;
        private Int16 GPIPortNum_len = 0;

        public bool Config = false;
        private Int16 Config_len = 0;

        private const UInt16 param_reserved_len = 7;

        public
      ENUM_GPIPortState State;
        private Int16 State_len = 8;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (GPIPortNum != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIPortNum, GPIPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Config != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Config, Config_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (State != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(State, State_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GPIPortCurrentState FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPIPortCurrentState param = new PARAM_GPIPortCurrentState();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.GPIPortNum = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.Config = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.State = (
        ENUM_GPIPortState)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GPIPortCurrentState>";

            if (GPIPortNum != null)
            {

                xml_str += "<GPIPortNum>" + GPIPortNum.ToString() + "</GPIPortNum>";

            }

            if (Config != null)
            {

                xml_str += "<Config>" + Config.ToString() + "</Config>";

            }

            if (State != null)
            {

                xml_str += "<State>" + State.ToString() + "</State>";

            }

            xml_str += "</GPIPortCurrentState>";
            return xml_str;
        }

        public static PARAM_GPIPortCurrentState FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GPIPortCurrentState param = new PARAM_GPIPortCurrentState();


            val = XmlUtil.GetNodeValue(node, "GPIPortNum");

            param.GPIPortNum = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "Config");

            param.Config = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "State");

            param.State = (
      ENUM_GPIPortState)Enum.Parse(typeof(
      ENUM_GPIPortState), val);

            return param;
        }

    }

    /// <summary>
    /// This parameter controls the behavior of the Reader when a new LLRP connection is established. In a SET_READER_CONFIG message, this parameter is used to enable or disable the holding of events and reports upon connection using the HoldEventsAndReportsUponReconnect field. In a GET_READER_CONFIG message, this parameter reports the current configuration. If the HoldEventsAndReportsUponReconnect is true, the reader will not deliver any reports or events (except the ConnectionAttemptEvent) to the Client until the Client issues an ENABLE_EVENTS_AND_REPORTS message. Once the ENABLE_EVENTS_AND_REPORTS message is received the reader ceases its hold on events and reports for the duration of the connection.
    /// </summary>
    public class PARAM_EventsAndReports : Parameter
    {
        public PARAM_EventsAndReports()
        {
            typeID = 226;

        }


        public bool HoldEventsAndReportsUponReconnect = false;
        private Int16 HoldEventsAndReportsUponReconnect_len = 0;

        private const UInt16 param_reserved_len = 7;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (HoldEventsAndReportsUponReconnect != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HoldEventsAndReportsUponReconnect, HoldEventsAndReportsUponReconnect_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_EventsAndReports FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_EventsAndReports param = new PARAM_EventsAndReports();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.HoldEventsAndReportsUponReconnect = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<EventsAndReports>";

            if (HoldEventsAndReportsUponReconnect != null)
            {

                xml_str += "<HoldEventsAndReportsUponReconnect>" + HoldEventsAndReportsUponReconnect.ToString() + "</HoldEventsAndReportsUponReconnect>";

            }

            xml_str += "</EventsAndReports>";
            return xml_str;
        }

        public static PARAM_EventsAndReports FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_EventsAndReports param = new PARAM_EventsAndReports();


            val = XmlUtil.GetNodeValue(node, "HoldEventsAndReportsUponReconnect");

            param.HoldEventsAndReportsUponReconnect = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// This Parameter carries the Reader inventory and RF survey reporting definition for the antenna. This parameter describes the contents of the report sent by the Reader and defines the events that cause the report to be sent.The ROReportTrigger field defines the events that cause the report to be sent.The TagReportContentSelector parameter defines the desired contents of the report. The ROReportTrigger defines the event that causes the report to be sent by the Reader to the Client.See section 13.2.6.1 for details about the order that reports are to be sent with respect to Reader event notifications.
    /// </summary>
    public class PARAM_ROReportSpec : Parameter
    {
        public PARAM_ROReportSpec()
        {
            typeID = 237;

        }


        public
      ENUM_ROReportTriggerType ROReportTrigger;
        private Int16 ROReportTrigger_len = 8;
        public UInt16 N = 0;
        private Int16 N_len = 0;

        public PARAM_TagReportContentSelector TagReportContentSelector;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IROReportSpec_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROReportTrigger != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROReportTrigger, ROReportTrigger_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (N != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(N, N_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TagReportContentSelector != null)
            {
                TagReportContentSelector.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROReportSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROReportSpec param = new PARAM_ROReportSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROReportTrigger = (
        ENUM_ROReportTriggerType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.N = (UInt16)obj_val;

            param.TagReportContentSelector = PARAM_TagReportContentSelector.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROReportSpec>";

            if (ROReportTrigger != null)
            {

                xml_str += "<ROReportTrigger>" + ROReportTrigger.ToString() + "</ROReportTrigger>";

            }

            if (N != null)
            {

                xml_str += "<N>" + N.ToString() + "</N>";

            }

            if (TagReportContentSelector != null)
            {

                xml_str += TagReportContentSelector.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</ROReportSpec>";
            return xml_str;
        }

        public static PARAM_ROReportSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROReportSpec param = new PARAM_ROReportSpec();


            val = XmlUtil.GetNodeValue(node, "ROReportTrigger");

            param.ROReportTrigger = (
      ENUM_ROReportTriggerType)Enum.Parse(typeof(
      ENUM_ROReportTriggerType), val);

            val = XmlUtil.GetNodeValue(node, "N");

            param.N = Convert.ToUInt16(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagReportContentSelector");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.TagReportContentSelector = PARAM_TagReportContentSelector.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter is used to configure the contents that are of interest in TagReportData. If enabled, the field is reported along with the tag data in the TagReportData.
    /// </summary>
    public class PARAM_TagReportContentSelector : Parameter
    {
        public PARAM_TagReportContentSelector()
        {
            typeID = 238;

        }


        public bool EnableROSpecID = false;
        private Int16 EnableROSpecID_len = 0;

        public bool EnableSpecIndex = false;
        private Int16 EnableSpecIndex_len = 0;

        public bool EnableInventoryParameterSpecID = false;
        private Int16 EnableInventoryParameterSpecID_len = 0;

        public bool EnableAntennaID = false;
        private Int16 EnableAntennaID_len = 0;

        public bool EnableChannelIndex = false;
        private Int16 EnableChannelIndex_len = 0;

        public bool EnablePeakRSSI = false;
        private Int16 EnablePeakRSSI_len = 0;

        public bool EnableFirstSeenTimestamp = false;
        private Int16 EnableFirstSeenTimestamp_len = 0;

        public bool EnableLastSeenTimestamp = false;
        private Int16 EnableLastSeenTimestamp_len = 0;

        public bool EnableTagSeenCount = false;
        private Int16 EnableTagSeenCount_len = 0;

        public bool EnableAccessSpecID = false;
        private Int16 EnableAccessSpecID_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UNION_AirProtocolEPCMemorySelector AirProtocolEPCMemorySelector = new UNION_AirProtocolEPCMemorySelector();

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EnableROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableROSpecID, EnableROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableSpecIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableSpecIndex, EnableSpecIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableInventoryParameterSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableInventoryParameterSpecID, EnableInventoryParameterSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableAntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableAntennaID, EnableAntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableChannelIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableChannelIndex, EnableChannelIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnablePeakRSSI != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnablePeakRSSI, EnablePeakRSSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableFirstSeenTimestamp != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableFirstSeenTimestamp, EnableFirstSeenTimestamp_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableLastSeenTimestamp != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableLastSeenTimestamp, EnableLastSeenTimestamp_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableTagSeenCount != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableTagSeenCount, EnableTagSeenCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnableAccessSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableAccessSpecID, EnableAccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            len = AirProtocolEPCMemorySelector.Count;
            for (int i = 0; i < len; i++) AirProtocolEPCMemorySelector[i].ToBitArray(ref bit_array, ref cursor);


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_TagReportContentSelector FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TagReportContentSelector param = new PARAM_TagReportContentSelector();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableROSpecID = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableSpecIndex = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableInventoryParameterSpecID = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableAntennaID = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableChannelIndex = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnablePeakRSSI = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableFirstSeenTimestamp = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableLastSeenTimestamp = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableTagSeenCount = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableAccessSpecID = (bool)obj_val;

            cursor += param_reserved_len;

            PARAM_C1G2EPCMemorySelector _param_C1G2EPCMemorySelector = PARAM_C1G2EPCMemorySelector.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2EPCMemorySelector != null)
            {
                param.AirProtocolEPCMemorySelector.Add(_param_C1G2EPCMemorySelector);
                while ((_param_C1G2EPCMemorySelector = PARAM_C1G2EPCMemorySelector.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolEPCMemorySelector.Add(_param_C1G2EPCMemorySelector);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<TagReportContentSelector>";

            if (EnableROSpecID != null)
            {

                xml_str += "<EnableROSpecID>" + EnableROSpecID.ToString() + "</EnableROSpecID>";

            }

            if (EnableSpecIndex != null)
            {

                xml_str += "<EnableSpecIndex>" + EnableSpecIndex.ToString() + "</EnableSpecIndex>";

            }

            if (EnableInventoryParameterSpecID != null)
            {

                xml_str += "<EnableInventoryParameterSpecID>" + EnableInventoryParameterSpecID.ToString() + "</EnableInventoryParameterSpecID>";

            }

            if (EnableAntennaID != null)
            {

                xml_str += "<EnableAntennaID>" + EnableAntennaID.ToString() + "</EnableAntennaID>";

            }

            if (EnableChannelIndex != null)
            {

                xml_str += "<EnableChannelIndex>" + EnableChannelIndex.ToString() + "</EnableChannelIndex>";

            }

            if (EnablePeakRSSI != null)
            {

                xml_str += "<EnablePeakRSSI>" + EnablePeakRSSI.ToString() + "</EnablePeakRSSI>";

            }

            if (EnableFirstSeenTimestamp != null)
            {

                xml_str += "<EnableFirstSeenTimestamp>" + EnableFirstSeenTimestamp.ToString() + "</EnableFirstSeenTimestamp>";

            }

            if (EnableLastSeenTimestamp != null)
            {

                xml_str += "<EnableLastSeenTimestamp>" + EnableLastSeenTimestamp.ToString() + "</EnableLastSeenTimestamp>";

            }

            if (EnableTagSeenCount != null)
            {

                xml_str += "<EnableTagSeenCount>" + EnableTagSeenCount.ToString() + "</EnableTagSeenCount>";

            }

            if (EnableAccessSpecID != null)
            {

                xml_str += "<EnableAccessSpecID>" + EnableAccessSpecID.ToString() + "</EnableAccessSpecID>";

            }

            if (AirProtocolEPCMemorySelector != null)
            {
                len = AirProtocolEPCMemorySelector.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolEPCMemorySelector[i].ToString();
            }

            xml_str += "</TagReportContentSelector>";
            return xml_str;
        }

        public static PARAM_TagReportContentSelector FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_TagReportContentSelector param = new PARAM_TagReportContentSelector();


            val = XmlUtil.GetNodeValue(node, "EnableROSpecID");

            param.EnableROSpecID = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableSpecIndex");

            param.EnableSpecIndex = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableInventoryParameterSpecID");

            param.EnableInventoryParameterSpecID = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableAntennaID");

            param.EnableAntennaID = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableChannelIndex");

            param.EnableChannelIndex = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnablePeakRSSI");

            param.EnablePeakRSSI = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableFirstSeenTimestamp");

            param.EnableFirstSeenTimestamp = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableLastSeenTimestamp");

            param.EnableLastSeenTimestamp = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableTagSeenCount");

            param.EnableTagSeenCount = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnableAccessSpecID");

            param.EnableAccessSpecID = Convert.ToBoolean(val);

            {

                param.AirProtocolEPCMemorySelector = new UNION_AirProtocolEPCMemorySelector();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2EPCMemorySelector");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolEPCMemorySelector.Add(PARAM_C1G2EPCMemorySelector.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            return param;
        }

    }

    /// <summary>
    /// This parameter sets up the triggers for the Reader to send the access results to the Client. In addition, the Client can enable or disable reporting of ROSpec details in the access results.
    /// </summary>
    public class PARAM_AccessReportSpec : Parameter
    {
        public PARAM_AccessReportSpec()
        {
            typeID = 239;

        }


        public
      ENUM_AccessReportTriggerType AccessReportTrigger;
        private Int16 AccessReportTrigger_len = 8;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AccessReportTrigger != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessReportTrigger, AccessReportTrigger_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AccessReportSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AccessReportSpec param = new PARAM_AccessReportSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessReportTrigger = (
        ENUM_AccessReportTriggerType)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AccessReportSpec>";

            if (AccessReportTrigger != null)
            {

                xml_str += "<AccessReportTrigger>" + AccessReportTrigger.ToString() + "</AccessReportTrigger>";

            }

            xml_str += "</AccessReportSpec>";
            return xml_str;
        }

        public static PARAM_AccessReportSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AccessReportSpec param = new PARAM_AccessReportSpec();


            val = XmlUtil.GetNodeValue(node, "AccessReportTrigger");

            param.AccessReportTrigger = (
      ENUM_AccessReportTriggerType)Enum.Parse(typeof(
      ENUM_AccessReportTriggerType), val);

            return param;
        }

    }

    /// <summary>
    /// This report parameter is generated per tag per accumulation scope. The only mandatory portion of this parameter is the EPCData parameter. If there was an access operation performed on the tag, the results of the OpSpecs are mandatory in the report. The other sub-parameters in this report are optional. LLRP provides three ways to make the tag reporting efficient:A Reader MAY accumulate multiple tag reports into a single tag report.. If a Reader accumulates, the Reader SHALL follow the accumulation rules specified in this section. The following specifies the rules for accumulating multiple tag observations into a single TagReportData:
    /// </summary>
    public class PARAM_TagReportData : Parameter
    {
        public PARAM_TagReportData()
        {
            typeID = 240;

        }


        public UNION_EPCParameter EPCParameter = new UNION_EPCParameter();

        public PARAM_ROSpecID ROSpecID;

        public PARAM_SpecIndex SpecIndex;

        public PARAM_InventoryParameterSpecID InventoryParameterSpecID;

        public PARAM_AntennaID AntennaID;

        public PARAM_PeakRSSI PeakRSSI;

        public PARAM_ChannelIndex ChannelIndex;

        public PARAM_FirstSeenTimestampUTC FirstSeenTimestampUTC;

        public PARAM_FirstSeenTimestampUptime FirstSeenTimestampUptime;

        public PARAM_LastSeenTimestampUTC LastSeenTimestampUTC;

        public PARAM_LastSeenTimestampUptime LastSeenTimestampUptime;

        public PARAM_TagSeenCount TagSeenCount;

        public UNION_AirProtocolTagData AirProtocolTagData = new UNION_AirProtocolTagData();

        public PARAM_AccessSpecID AccessSpecID;

        public UNION_AccessCommandOpSpecResult AccessCommandOpSpecResult = new UNION_AccessCommandOpSpecResult();

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(ITagReportData_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            len = EPCParameter.Count;
            for (int i = 0; i < len; i++) EPCParameter[i].ToBitArray(ref bit_array, ref cursor);

            if (ROSpecID != null)
            {
                ROSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (SpecIndex != null)
            {
                SpecIndex.ToBitArray(ref bit_array, ref cursor);

            }

            if (InventoryParameterSpecID != null)
            {
                InventoryParameterSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaID != null)
            {
                AntennaID.ToBitArray(ref bit_array, ref cursor);

            }

            if (PeakRSSI != null)
            {
                PeakRSSI.ToBitArray(ref bit_array, ref cursor);

            }

            if (ChannelIndex != null)
            {
                ChannelIndex.ToBitArray(ref bit_array, ref cursor);

            }

            if (FirstSeenTimestampUTC != null)
            {
                FirstSeenTimestampUTC.ToBitArray(ref bit_array, ref cursor);

            }

            if (FirstSeenTimestampUptime != null)
            {
                FirstSeenTimestampUptime.ToBitArray(ref bit_array, ref cursor);

            }

            if (LastSeenTimestampUTC != null)
            {
                LastSeenTimestampUTC.ToBitArray(ref bit_array, ref cursor);

            }

            if (LastSeenTimestampUptime != null)
            {
                LastSeenTimestampUptime.ToBitArray(ref bit_array, ref cursor);

            }

            if (TagSeenCount != null)
            {
                TagSeenCount.ToBitArray(ref bit_array, ref cursor);

            }

            len = AirProtocolTagData.Count;
            for (int i = 0; i < len; i++) AirProtocolTagData[i].ToBitArray(ref bit_array, ref cursor);

            if (AccessSpecID != null)
            {
                AccessSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            len = AccessCommandOpSpecResult.Count;
            for (int i = 0; i < len; i++) AccessCommandOpSpecResult[i].ToBitArray(ref bit_array, ref cursor);

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_TagReportData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TagReportData param = new PARAM_TagReportData();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            PARAM_EPCData _param_EPCData = PARAM_EPCData.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_EPCData != null)
            {
                param.EPCParameter.Add(_param_EPCData);
                while ((_param_EPCData = PARAM_EPCData.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.EPCParameter.Add(_param_EPCData);
            }

            PARAM_EPC_96 _param_EPC_96 = PARAM_EPC_96.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_EPC_96 != null)
            {
                param.EPCParameter.Add(_param_EPC_96);
                while ((_param_EPC_96 = PARAM_EPC_96.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.EPCParameter.Add(_param_EPC_96);
            }

            param.ROSpecID = PARAM_ROSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.SpecIndex = PARAM_SpecIndex.FromBitArray(ref bit_array, ref cursor, length);

            param.InventoryParameterSpecID = PARAM_InventoryParameterSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.AntennaID = PARAM_AntennaID.FromBitArray(ref bit_array, ref cursor, length);

            param.PeakRSSI = PARAM_PeakRSSI.FromBitArray(ref bit_array, ref cursor, length);

            param.ChannelIndex = PARAM_ChannelIndex.FromBitArray(ref bit_array, ref cursor, length);

            param.FirstSeenTimestampUTC = PARAM_FirstSeenTimestampUTC.FromBitArray(ref bit_array, ref cursor, length);

            param.FirstSeenTimestampUptime = PARAM_FirstSeenTimestampUptime.FromBitArray(ref bit_array, ref cursor, length);

            param.LastSeenTimestampUTC = PARAM_LastSeenTimestampUTC.FromBitArray(ref bit_array, ref cursor, length);

            param.LastSeenTimestampUptime = PARAM_LastSeenTimestampUptime.FromBitArray(ref bit_array, ref cursor, length);

            param.TagSeenCount = PARAM_TagSeenCount.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_C1G2_PC _param_C1G2_PC = PARAM_C1G2_PC.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2_PC != null)
            {
                param.AirProtocolTagData.Add(_param_C1G2_PC);
                while ((_param_C1G2_PC = PARAM_C1G2_PC.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolTagData.Add(_param_C1G2_PC);
            }

            PARAM_C1G2_CRC _param_C1G2_CRC = PARAM_C1G2_CRC.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2_CRC != null)
            {
                param.AirProtocolTagData.Add(_param_C1G2_CRC);
                while ((_param_C1G2_CRC = PARAM_C1G2_CRC.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolTagData.Add(_param_C1G2_CRC);
            }

            param.AccessSpecID = PARAM_AccessSpecID.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_C1G2ReadOpSpecResult _param_C1G2ReadOpSpecResult = PARAM_C1G2ReadOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2ReadOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2ReadOpSpecResult);
                while ((_param_C1G2ReadOpSpecResult = PARAM_C1G2ReadOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2ReadOpSpecResult);
            }

            PARAM_C1G2WriteOpSpecResult _param_C1G2WriteOpSpecResult = PARAM_C1G2WriteOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2WriteOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2WriteOpSpecResult);
                while ((_param_C1G2WriteOpSpecResult = PARAM_C1G2WriteOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2WriteOpSpecResult);
            }

            PARAM_C1G2KillOpSpecResult _param_C1G2KillOpSpecResult = PARAM_C1G2KillOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2KillOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2KillOpSpecResult);
                while ((_param_C1G2KillOpSpecResult = PARAM_C1G2KillOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2KillOpSpecResult);
            }

            PARAM_C1G2LockOpSpecResult _param_C1G2LockOpSpecResult = PARAM_C1G2LockOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2LockOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2LockOpSpecResult);
                while ((_param_C1G2LockOpSpecResult = PARAM_C1G2LockOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2LockOpSpecResult);
            }

            PARAM_C1G2BlockEraseOpSpecResult _param_C1G2BlockEraseOpSpecResult = PARAM_C1G2BlockEraseOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2BlockEraseOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2BlockEraseOpSpecResult);
                while ((_param_C1G2BlockEraseOpSpecResult = PARAM_C1G2BlockEraseOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2BlockEraseOpSpecResult);
            }

            PARAM_C1G2BlockWriteOpSpecResult _param_C1G2BlockWriteOpSpecResult = PARAM_C1G2BlockWriteOpSpecResult.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2BlockWriteOpSpecResult != null)
            {
                param.AccessCommandOpSpecResult.Add(_param_C1G2BlockWriteOpSpecResult);
                while ((_param_C1G2BlockWriteOpSpecResult = PARAM_C1G2BlockWriteOpSpecResult.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AccessCommandOpSpecResult.Add(_param_C1G2BlockWriteOpSpecResult);
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<TagReportData>";

            if (EPCParameter != null)
            {
                len = EPCParameter.Count;
                for (int i = 0; i < len; i++) xml_str += EPCParameter[i].ToString();
            }

            if (ROSpecID != null)
            {

                xml_str += ROSpecID.ToString();

            }

            if (SpecIndex != null)
            {

                xml_str += SpecIndex.ToString();

            }

            if (InventoryParameterSpecID != null)
            {

                xml_str += InventoryParameterSpecID.ToString();

            }

            if (AntennaID != null)
            {

                xml_str += AntennaID.ToString();

            }

            if (PeakRSSI != null)
            {

                xml_str += PeakRSSI.ToString();

            }

            if (ChannelIndex != null)
            {

                xml_str += ChannelIndex.ToString();

            }

            if (FirstSeenTimestampUTC != null)
            {

                xml_str += FirstSeenTimestampUTC.ToString();

            }

            if (FirstSeenTimestampUptime != null)
            {

                xml_str += FirstSeenTimestampUptime.ToString();

            }

            if (LastSeenTimestampUTC != null)
            {

                xml_str += LastSeenTimestampUTC.ToString();

            }

            if (LastSeenTimestampUptime != null)
            {

                xml_str += LastSeenTimestampUptime.ToString();

            }

            if (TagSeenCount != null)
            {

                xml_str += TagSeenCount.ToString();

            }

            if (AirProtocolTagData != null)
            {
                len = AirProtocolTagData.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolTagData[i].ToString();
            }

            if (AccessSpecID != null)
            {

                xml_str += AccessSpecID.ToString();

            }

            if (AccessCommandOpSpecResult != null)
            {
                len = AccessCommandOpSpecResult.Count;
                for (int i = 0; i < len; i++) xml_str += AccessCommandOpSpecResult[i].ToString();
            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</TagReportData>";
            return xml_str;
        }

        public static PARAM_TagReportData FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_TagReportData param = new PARAM_TagReportData();


            {

                param.EPCParameter = new UNION_EPCParameter();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EPCData");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.EPCParameter.Add(PARAM_EPCData.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EPC_96");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.EPCParameter.Add(PARAM_EPC_96.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecID = PARAM_ROSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "SpecIndex");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.SpecIndex = PARAM_SpecIndex.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "InventoryParameterSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.InventoryParameterSpecID = PARAM_InventoryParameterSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AntennaID = PARAM_AntennaID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "PeakRSSI");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.PeakRSSI = PARAM_PeakRSSI.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ChannelIndex");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ChannelIndex = PARAM_ChannelIndex.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FirstSeenTimestampUTC");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FirstSeenTimestampUTC = PARAM_FirstSeenTimestampUTC.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FirstSeenTimestampUptime");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FirstSeenTimestampUptime = PARAM_FirstSeenTimestampUptime.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LastSeenTimestampUTC");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.LastSeenTimestampUTC = PARAM_LastSeenTimestampUTC.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LastSeenTimestampUptime");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.LastSeenTimestampUptime = PARAM_LastSeenTimestampUptime.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagSeenCount");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.TagSeenCount = PARAM_TagSeenCount.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                param.AirProtocolTagData = new UNION_AirProtocolTagData();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2_PC");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolTagData.Add(PARAM_C1G2_PC.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2_CRC");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolTagData.Add(PARAM_C1G2_CRC.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AccessSpecID = PARAM_AccessSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                param.AccessCommandOpSpecResult = new UNION_AccessCommandOpSpecResult();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2ReadOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2ReadOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2WriteOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2WriteOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2KillOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2KillOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2LockOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2LockOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2BlockEraseOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2BlockEraseOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2BlockWriteOpSpecResult");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AccessCommandOpSpecResult.Add(PARAM_C1G2BlockWriteOpSpecResult.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the EPC identifier information.
    /// </summary>
    public class PARAM_EPCData : Parameter
    {
        public PARAM_EPCData()
        {
            typeID = 241;

        }


        public LLRPBitArray EPC = new LLRPBitArray();
        private Int16 EPC_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EPC != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPC.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPC, EPC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_EPCData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_EPCData param = new PARAM_EPCData();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(LLRPBitArray), field_len);
            param.EPC = (LLRPBitArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<EPCData>";

            if (EPC != null)
            {

                xml_str += "<EPC>" + EPC.ToHexString() + "</EPC>";

            }

            xml_str += "</EPCData>";
            return xml_str;
        }

        public static PARAM_EPCData FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_EPCData param = new PARAM_EPCData();


            val = XmlUtil.GetNodeValue(node, "EPC");

            param.EPC = LLRPBitArray.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries 96-bit EPC identifier information.
    /// </summary>
    public class PARAM_EPC_96 : Parameter
    {
        public PARAM_EPC_96()
        {
            typeID = 13;
            tvCoding = true;
        }


        public LLRPBitArray EPC = new LLRPBitArray();
        private Int16 EPC_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EPC != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(EPC.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(EPC, EPC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_EPC_96 FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_EPC_96 param = new PARAM_EPC_96();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 96;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(LLRPBitArray), field_len);
            param.EPC = (LLRPBitArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<EPC_96>";

            if (EPC != null)
            {

                xml_str += "<EPC>" + EPC.ToHexString() + "</EPC>";

            }

            xml_str += "</EPC_96>";
            return xml_str;
        }

        public static PARAM_EPC_96 FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_EPC_96 param = new PARAM_EPC_96();


            val = XmlUtil.GetNodeValue(node, "EPC");

            param.EPC = LLRPBitArray.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the ROSpecID information.
    /// </summary>
    public class PARAM_ROSpecID : Parameter
    {
        public PARAM_ROSpecID()
        {
            typeID = 9;
            tvCoding = true;
        }


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROSpecID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROSpecID param = new PARAM_ROSpecID();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROSpecID>";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</ROSpecID>";
            return xml_str;
        }

        public static PARAM_ROSpecID FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROSpecID param = new PARAM_ROSpecID();


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the SpecIndex information. The SpecIndex indicates the item within the ROSpec that was being executed at the time the tag was observed.
    /// </summary>
    public class PARAM_SpecIndex : Parameter
    {
        public PARAM_SpecIndex()
        {
            typeID = 14;
            tvCoding = true;
        }


        public UInt16 SpecIndex = 0;
        private Int16 SpecIndex_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (SpecIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SpecIndex, SpecIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_SpecIndex FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_SpecIndex param = new PARAM_SpecIndex();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.SpecIndex = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<SpecIndex>";

            if (SpecIndex != null)
            {

                xml_str += "<SpecIndex>" + SpecIndex.ToString() + "</SpecIndex>";

            }

            xml_str += "</SpecIndex>";
            return xml_str;
        }

        public static PARAM_SpecIndex FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_SpecIndex param = new PARAM_SpecIndex();


            val = XmlUtil.GetNodeValue(node, "SpecIndex");

            param.SpecIndex = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the InventoryParameterSpecID information.
    /// </summary>
    public class PARAM_InventoryParameterSpecID : Parameter
    {
        public PARAM_InventoryParameterSpecID()
        {
            typeID = 10;
            tvCoding = true;
        }


        public UInt16 InventoryParameterSpecID = 0;
        private Int16 InventoryParameterSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (InventoryParameterSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(InventoryParameterSpecID, InventoryParameterSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_InventoryParameterSpecID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_InventoryParameterSpecID param = new PARAM_InventoryParameterSpecID();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.InventoryParameterSpecID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<InventoryParameterSpecID>";

            if (InventoryParameterSpecID != null)
            {

                xml_str += "<InventoryParameterSpecID>" + InventoryParameterSpecID.ToString() + "</InventoryParameterSpecID>";

            }

            xml_str += "</InventoryParameterSpecID>";
            return xml_str;
        }

        public static PARAM_InventoryParameterSpecID FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_InventoryParameterSpecID param = new PARAM_InventoryParameterSpecID();


            val = XmlUtil.GetNodeValue(node, "InventoryParameterSpecID");

            param.InventoryParameterSpecID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the AntennaID information.
    /// </summary>
    public class PARAM_AntennaID : Parameter
    {
        public PARAM_AntennaID()
        {
            typeID = 1;
            tvCoding = true;
        }


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AntennaID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaID param = new PARAM_AntennaID();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AntennaID>";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            xml_str += "</AntennaID>";
            return xml_str;
        }

        public static PARAM_AntennaID FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AntennaID param = new PARAM_AntennaID();


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the PeakRSSI information.PeakRSSI: The peak received power of the EPC backscatter in dBm.
    /// </summary>
    public class PARAM_PeakRSSI : Parameter
    {
        public PARAM_PeakRSSI()
        {
            typeID = 6;
            tvCoding = true;
        }


        public sbyte PeakRSSI = 0;
        private Int16 PeakRSSI_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (PeakRSSI != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PeakRSSI, PeakRSSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_PeakRSSI FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_PeakRSSI param = new PARAM_PeakRSSI();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(sbyte), field_len);
            param.PeakRSSI = (sbyte)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<PeakRSSI>";

            if (PeakRSSI != null)
            {

                xml_str += "<PeakRSSI>" + PeakRSSI.ToString() + "</PeakRSSI>";

            }

            xml_str += "</PeakRSSI>";
            return xml_str;
        }

        public static PARAM_PeakRSSI FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_PeakRSSI param = new PARAM_PeakRSSI();


            val = XmlUtil.GetNodeValue(node, "PeakRSSI");

            param.PeakRSSI = Convert.ToSByte(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the one-based ChannelIndex informationvalue.
    /// </summary>
    public class PARAM_ChannelIndex : Parameter
    {
        public PARAM_ChannelIndex()
        {
            typeID = 7;
            tvCoding = true;
        }


        public UInt16 ChannelIndex = 0;
        private Int16 ChannelIndex_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ChannelIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ChannelIndex, ChannelIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ChannelIndex FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ChannelIndex param = new PARAM_ChannelIndex();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ChannelIndex = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ChannelIndex>";

            if (ChannelIndex != null)
            {

                xml_str += "<ChannelIndex>" + ChannelIndex.ToString() + "</ChannelIndex>";

            }

            xml_str += "</ChannelIndex>";
            return xml_str;
        }

        public static PARAM_ChannelIndex FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ChannelIndex param = new PARAM_ChannelIndex();


            val = XmlUtil.GetNodeValue(node, "ChannelIndex");

            param.ChannelIndex = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the FirstSeenTimestamp information in UTC.Compliant Readers and Clients that have UTC clocks SHALL implement this parameter.This is the time elapsed since the Epoch (00:00:00 UTC, January 1, 1970) measured in microseconds.
    /// </summary>
    public class PARAM_FirstSeenTimestampUTC : Parameter
    {
        public PARAM_FirstSeenTimestampUTC()
        {
            typeID = 2;
            tvCoding = true;
        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FirstSeenTimestampUTC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FirstSeenTimestampUTC param = new PARAM_FirstSeenTimestampUTC();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FirstSeenTimestampUTC>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</FirstSeenTimestampUTC>";
            return xml_str;
        }

        public static PARAM_FirstSeenTimestampUTC FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FirstSeenTimestampUTC param = new PARAM_FirstSeenTimestampUTC();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the FirstSeenTimestamp information in Uptime.Compliant Readers and Clients that do not have UTC clocks SHALL implement this parameter. Compliant Readers and Clients that have UTC clocks MAY implement this parameter.
    /// </summary>
    public class PARAM_FirstSeenTimestampUptime : Parameter
    {
        public PARAM_FirstSeenTimestampUptime()
        {
            typeID = 3;
            tvCoding = true;
        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FirstSeenTimestampUptime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FirstSeenTimestampUptime param = new PARAM_FirstSeenTimestampUptime();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FirstSeenTimestampUptime>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</FirstSeenTimestampUptime>";
            return xml_str;
        }

        public static PARAM_FirstSeenTimestampUptime FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FirstSeenTimestampUptime param = new PARAM_FirstSeenTimestampUptime();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the LastSeenTimestamp information in UTC.This is the time elapsed since boot, measured in microseconds.
    /// </summary>
    public class PARAM_LastSeenTimestampUTC : Parameter
    {
        public PARAM_LastSeenTimestampUTC()
        {
            typeID = 4;
            tvCoding = true;
        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_LastSeenTimestampUTC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_LastSeenTimestampUTC param = new PARAM_LastSeenTimestampUTC();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<LastSeenTimestampUTC>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</LastSeenTimestampUTC>";
            return xml_str;
        }

        public static PARAM_LastSeenTimestampUTC FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_LastSeenTimestampUTC param = new PARAM_LastSeenTimestampUTC();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the LastSeenTimestamp information in UTC.This is the time elapsed since the Epoch (00:00:00 UTC, January 1, 1970) measured in microseconds.
    /// </summary>
    public class PARAM_LastSeenTimestampUptime : Parameter
    {
        public PARAM_LastSeenTimestampUptime()
        {
            typeID = 5;
            tvCoding = true;
        }


        public UInt64 Microseconds = 0;
        private Int16 Microseconds_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Microseconds != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Microseconds, Microseconds_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_LastSeenTimestampUptime FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_LastSeenTimestampUptime param = new PARAM_LastSeenTimestampUptime();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 64;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt64), field_len);
            param.Microseconds = (UInt64)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<LastSeenTimestampUptime>";

            if (Microseconds != null)
            {

                xml_str += "<Microseconds>" + Microseconds.ToString() + "</Microseconds>";

            }

            xml_str += "</LastSeenTimestampUptime>";
            return xml_str;
        }

        public static PARAM_LastSeenTimestampUptime FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_LastSeenTimestampUptime param = new PARAM_LastSeenTimestampUptime();


            val = XmlUtil.GetNodeValue(node, "Microseconds");

            param.Microseconds = Convert.ToUInt64(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the tag seen count information. If TagSeenCount &gt; 65535 for the report period, the reader SHALL report 65535.
    /// </summary>
    public class PARAM_TagSeenCount : Parameter
    {
        public PARAM_TagSeenCount()
        {
            typeID = 8;
            tvCoding = true;
        }


        public UInt16 TagCount = 0;
        private Int16 TagCount_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (TagCount != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagCount, TagCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_TagSeenCount FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_TagSeenCount param = new PARAM_TagSeenCount();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.TagCount = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<TagSeenCount>";

            if (TagCount != null)
            {

                xml_str += "<TagCount>" + TagCount.ToString() + "</TagCount>";

            }

            xml_str += "</TagSeenCount>";
            return xml_str;
        }

        public static PARAM_TagSeenCount FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_TagSeenCount param = new PARAM_TagSeenCount();


            val = XmlUtil.GetNodeValue(node, "TagCount");

            param.TagCount = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the AccessSpecID information.
    /// </summary>
    public class PARAM_AccessSpecID : Parameter
    {
        public PARAM_AccessSpecID()
        {
            typeID = 16;
            tvCoding = true;
        }


        public UInt32 AccessSpecID = 0;
        private Int16 AccessSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (AccessSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AccessSpecID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AccessSpecID param = new PARAM_AccessSpecID();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessSpecID = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AccessSpecID>";

            if (AccessSpecID != null)
            {

                xml_str += "<AccessSpecID>" + AccessSpecID.ToString() + "</AccessSpecID>";

            }

            xml_str += "</AccessSpecID>";
            return xml_str;
        }

        public static PARAM_AccessSpecID FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AccessSpecID param = new PARAM_AccessSpecID();


            val = XmlUtil.GetNodeValue(node, "AccessSpecID");

            param.AccessSpecID = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This describes the content of the RF Survey Report.
    /// </summary>
    public class PARAM_RFSurveyReportData : Parameter
    {
        public PARAM_RFSurveyReportData()
        {
            typeID = 242;

        }


        public PARAM_ROSpecID ROSpecID;

        public PARAM_SpecIndex SpecIndex;

        public PARAM_FrequencyRSSILevelEntry[] FrequencyRSSILevelEntry;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IRFSurveyReportData_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ROSpecID != null)
            {
                ROSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (SpecIndex != null)
            {
                SpecIndex.ToBitArray(ref bit_array, ref cursor);

            }

            if (FrequencyRSSILevelEntry != null)
            {

                len = FrequencyRSSILevelEntry.Length;
                for (int i = 0; i < len; i++)
                    FrequencyRSSILevelEntry[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFSurveyReportData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFSurveyReportData param = new PARAM_RFSurveyReportData();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param.ROSpecID = PARAM_ROSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.SpecIndex = PARAM_SpecIndex.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_FrequencyRSSILevelEntry _param_FrequencyRSSILevelEntry = PARAM_FrequencyRSSILevelEntry.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_FrequencyRSSILevelEntry != null)
            {
                param_list.Add(_param_FrequencyRSSILevelEntry);
                while ((_param_FrequencyRSSILevelEntry = PARAM_FrequencyRSSILevelEntry.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_FrequencyRSSILevelEntry);
                if (param_list.Count > 0)
                {
                    param.FrequencyRSSILevelEntry = new PARAM_FrequencyRSSILevelEntry[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.FrequencyRSSILevelEntry[i] = (PARAM_FrequencyRSSILevelEntry)param_list[i];
                }
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFSurveyReportData>";

            if (ROSpecID != null)
            {

                xml_str += ROSpecID.ToString();

            }

            if (SpecIndex != null)
            {

                xml_str += SpecIndex.ToString();

            }

            if (FrequencyRSSILevelEntry != null)
            {

                len = FrequencyRSSILevelEntry.Length;
                for (int i = 0; i < len; i++)
                    xml_str += FrequencyRSSILevelEntry[i].ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</RFSurveyReportData>";
            return xml_str;
        }

        public static PARAM_RFSurveyReportData FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFSurveyReportData param = new PARAM_RFSurveyReportData();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecID = PARAM_ROSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "SpecIndex");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.SpecIndex = PARAM_SpecIndex.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FrequencyRSSILevelEntry");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.FrequencyRSSILevelEntry = new PARAM_FrequencyRSSILevelEntry[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.FrequencyRSSILevelEntry[i] = PARAM_FrequencyRSSILevelEntry.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Description
    /// </summary>
    public class PARAM_FrequencyRSSILevelEntry : Parameter
    {
        public PARAM_FrequencyRSSILevelEntry()
        {
            typeID = 243;

        }


        public UInt32 Frequency = 0;
        private Int16 Frequency_len = 0;

        public UInt32 Bandwidth = 0;
        private Int16 Bandwidth_len = 0;

        public sbyte AverageRSSI = 0;
        private Int16 AverageRSSI_len = 0;

        public sbyte PeakRSSI = 0;
        private Int16 PeakRSSI_len = 0;

        public UNION_Timestamp Timestamp = new UNION_Timestamp();

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Frequency != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Frequency, Frequency_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Bandwidth != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Bandwidth, Bandwidth_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AverageRSSI != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AverageRSSI, AverageRSSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (PeakRSSI != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PeakRSSI, PeakRSSI_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            len = Timestamp.Count;
            for (int i = 0; i < len; i++) Timestamp[i].ToBitArray(ref bit_array, ref cursor);


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FrequencyRSSILevelEntry FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FrequencyRSSILevelEntry param = new PARAM_FrequencyRSSILevelEntry();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Frequency = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Bandwidth = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(sbyte), field_len);
            param.AverageRSSI = (sbyte)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(sbyte), field_len);
            param.PeakRSSI = (sbyte)obj_val;

            PARAM_UTCTimestamp _param_UTCTimestamp = PARAM_UTCTimestamp.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_UTCTimestamp != null)
            {
                param.Timestamp.Add(_param_UTCTimestamp);
                while ((_param_UTCTimestamp = PARAM_UTCTimestamp.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.Timestamp.Add(_param_UTCTimestamp);
            }

            PARAM_Uptime _param_Uptime = PARAM_Uptime.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_Uptime != null)
            {
                param.Timestamp.Add(_param_Uptime);
                while ((_param_Uptime = PARAM_Uptime.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.Timestamp.Add(_param_Uptime);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FrequencyRSSILevelEntry>";

            if (Frequency != null)
            {

                xml_str += "<Frequency>" + Frequency.ToString() + "</Frequency>";

            }

            if (Bandwidth != null)
            {

                xml_str += "<Bandwidth>" + Bandwidth.ToString() + "</Bandwidth>";

            }

            if (AverageRSSI != null)
            {

                xml_str += "<AverageRSSI>" + AverageRSSI.ToString() + "</AverageRSSI>";

            }

            if (PeakRSSI != null)
            {

                xml_str += "<PeakRSSI>" + PeakRSSI.ToString() + "</PeakRSSI>";

            }

            if (Timestamp != null)
            {
                len = Timestamp.Count;
                for (int i = 0; i < len; i++) xml_str += Timestamp[i].ToString();
            }

            xml_str += "</FrequencyRSSILevelEntry>";
            return xml_str;
        }

        public static PARAM_FrequencyRSSILevelEntry FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FrequencyRSSILevelEntry param = new PARAM_FrequencyRSSILevelEntry();


            val = XmlUtil.GetNodeValue(node, "Frequency");

            param.Frequency = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "Bandwidth");

            param.Bandwidth = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "AverageRSSI");

            param.AverageRSSI = Convert.ToSByte(val);

            val = XmlUtil.GetNodeValue(node, "PeakRSSI");

            param.PeakRSSI = Convert.ToSByte(val);

            {

                param.Timestamp = new UNION_Timestamp();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "UTCTimestamp");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.Timestamp.Add(PARAM_UTCTimestamp.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Uptime");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.Timestamp.Add(PARAM_Uptime.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            return param;
        }

    }

    /// <summary>
    /// This parameter is used by the Client to enable or disable notification of one or more Reader events. Notification of buffer overflow events and connection events (attempt/close) are mandatory, and not configurable.
    /// </summary>
    public class PARAM_ReaderEventNotificationSpec : Parameter
    {
        public PARAM_ReaderEventNotificationSpec()
        {
            typeID = 244;

        }


        public PARAM_EventNotificationState[] EventNotificationState;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventNotificationState != null)
            {

                len = EventNotificationState.Length;
                for (int i = 0; i < len; i++)
                    EventNotificationState[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReaderEventNotificationSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReaderEventNotificationSpec param = new PARAM_ReaderEventNotificationSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param_list = new ArrayList();
            PARAM_EventNotificationState _param_EventNotificationState = PARAM_EventNotificationState.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_EventNotificationState != null)
            {
                param_list.Add(_param_EventNotificationState);
                while ((_param_EventNotificationState = PARAM_EventNotificationState.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_EventNotificationState);
                if (param_list.Count > 0)
                {
                    param.EventNotificationState = new PARAM_EventNotificationState[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.EventNotificationState[i] = (PARAM_EventNotificationState)param_list[i];
                }
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReaderEventNotificationSpec>";

            if (EventNotificationState != null)
            {

                len = EventNotificationState.Length;
                for (int i = 0; i < len; i++)
                    xml_str += EventNotificationState[i].ToString();

            }

            xml_str += "</ReaderEventNotificationSpec>";
            return xml_str;
        }

        public static PARAM_ReaderEventNotificationSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReaderEventNotificationSpec param = new PARAM_ReaderEventNotificationSpec();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EventNotificationState");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.EventNotificationState = new PARAM_EventNotificationState[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.EventNotificationState[i] = PARAM_EventNotificationState.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter is used to enable or disable notification of a single Reader event type.
    /// </summary>
    public class PARAM_EventNotificationState : Parameter
    {
        public PARAM_EventNotificationState()
        {
            typeID = 245;

        }


        public
      ENUM_NotificationEventType EventType;
        private Int16 EventType_len = 16;
        public bool NotificationState = false;
        private Int16 NotificationState_len = 0;

        private const UInt16 param_reserved_len = 7;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EventType, EventType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NotificationState != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NotificationState, NotificationState_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_EventNotificationState FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_EventNotificationState param = new PARAM_EventNotificationState();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EventType = (
        ENUM_NotificationEventType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.NotificationState = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<EventNotificationState>";

            if (EventType != null)
            {

                xml_str += "<EventType>" + EventType.ToString() + "</EventType>";

            }

            if (NotificationState != null)
            {

                xml_str += "<NotificationState>" + NotificationState.ToString() + "</NotificationState>";

            }

            xml_str += "</EventNotificationState>";
            return xml_str;
        }

        public static PARAM_EventNotificationState FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_EventNotificationState param = new PARAM_EventNotificationState();


            val = XmlUtil.GetNodeValue(node, "EventType");

            param.EventType = (
      ENUM_NotificationEventType)Enum.Parse(typeof(
      ENUM_NotificationEventType), val);

            val = XmlUtil.GetNodeValue(node, "NotificationState");

            param.NotificationState = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter describes the contents of the event notification sent by the Reader, and defines the events that cause the notification to be sent. Event notification messages may be sent by the Reader due to connection establishment/closing event, critical events such as hopping, fault-detection in a Reader functional block, buffer overflow, due to the activation of a Reader accessory trigger input (e.g. motion detection), or due to performance monitoring events such as abnormalities in the RF environment.Timestamp is the time that the events reported occurred.LLRP assumes a reliable stream transport mechanism.  Messages sent through LLRP will arrive in the order that they were sent over the transport and binding utilized. Status events within the same message SHALL be ordered chronologically.Status events delivered by reader event notifications are useful, especially in conjunction with the tag report data.  The following describes the requirements of the reader event notifications ordering with respect to the ordering of tag reports and Reader Event Notifications.  The following requirements are made on the ordering of Event Parameters with respect to each other and to tag report Parameters.  These statements apply if the respective status events and report triggers are enabled. 
    /// </summary>
    public class PARAM_ReaderEventNotificationData : Parameter
    {
        public PARAM_ReaderEventNotificationData()
        {
            typeID = 246;

        }


        public UNION_Timestamp Timestamp = new UNION_Timestamp();

        public PARAM_HoppingEvent HoppingEvent;

        public PARAM_GPIEvent GPIEvent;

        public PARAM_ROSpecEvent ROSpecEvent;

        public PARAM_ReportBufferLevelWarningEvent ReportBufferLevelWarningEvent;

        public PARAM_ReportBufferOverflowErrorEvent ReportBufferOverflowErrorEvent;

        public PARAM_ReaderExceptionEvent ReaderExceptionEvent;

        public PARAM_RFSurveyEvent RFSurveyEvent;

        public PARAM_AISpecEvent AISpecEvent;

        public PARAM_AntennaEvent AntennaEvent;

        public PARAM_ConnectionAttemptEvent ConnectionAttemptEvent;

        public PARAM_ConnectionCloseEvent ConnectionCloseEvent;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IReaderEventNotificationData_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            len = Timestamp.Count;
            for (int i = 0; i < len; i++) Timestamp[i].ToBitArray(ref bit_array, ref cursor);

            if (HoppingEvent != null)
            {
                HoppingEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (GPIEvent != null)
            {
                GPIEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ROSpecEvent != null)
            {
                ROSpecEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ReportBufferLevelWarningEvent != null)
            {
                ReportBufferLevelWarningEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ReportBufferOverflowErrorEvent != null)
            {
                ReportBufferOverflowErrorEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ReaderExceptionEvent != null)
            {
                ReaderExceptionEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (RFSurveyEvent != null)
            {
                RFSurveyEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (AISpecEvent != null)
            {
                AISpecEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaEvent != null)
            {
                AntennaEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ConnectionAttemptEvent != null)
            {
                ConnectionAttemptEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (ConnectionCloseEvent != null)
            {
                ConnectionCloseEvent.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReaderEventNotificationData FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReaderEventNotificationData param = new PARAM_ReaderEventNotificationData();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            PARAM_UTCTimestamp _param_UTCTimestamp = PARAM_UTCTimestamp.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_UTCTimestamp != null)
            {
                param.Timestamp.Add(_param_UTCTimestamp);
                while ((_param_UTCTimestamp = PARAM_UTCTimestamp.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.Timestamp.Add(_param_UTCTimestamp);
            }

            PARAM_Uptime _param_Uptime = PARAM_Uptime.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_Uptime != null)
            {
                param.Timestamp.Add(_param_Uptime);
                while ((_param_Uptime = PARAM_Uptime.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.Timestamp.Add(_param_Uptime);
            }

            param.HoppingEvent = PARAM_HoppingEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.GPIEvent = PARAM_GPIEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ROSpecEvent = PARAM_ROSpecEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ReportBufferLevelWarningEvent = PARAM_ReportBufferLevelWarningEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ReportBufferOverflowErrorEvent = PARAM_ReportBufferOverflowErrorEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ReaderExceptionEvent = PARAM_ReaderExceptionEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.RFSurveyEvent = PARAM_RFSurveyEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.AISpecEvent = PARAM_AISpecEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.AntennaEvent = PARAM_AntennaEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ConnectionAttemptEvent = PARAM_ConnectionAttemptEvent.FromBitArray(ref bit_array, ref cursor, length);

            param.ConnectionCloseEvent = PARAM_ConnectionCloseEvent.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReaderEventNotificationData>";

            if (Timestamp != null)
            {
                len = Timestamp.Count;
                for (int i = 0; i < len; i++) xml_str += Timestamp[i].ToString();
            }

            if (HoppingEvent != null)
            {

                xml_str += HoppingEvent.ToString();

            }

            if (GPIEvent != null)
            {

                xml_str += GPIEvent.ToString();

            }

            if (ROSpecEvent != null)
            {

                xml_str += ROSpecEvent.ToString();

            }

            if (ReportBufferLevelWarningEvent != null)
            {

                xml_str += ReportBufferLevelWarningEvent.ToString();

            }

            if (ReportBufferOverflowErrorEvent != null)
            {

                xml_str += ReportBufferOverflowErrorEvent.ToString();

            }

            if (ReaderExceptionEvent != null)
            {

                xml_str += ReaderExceptionEvent.ToString();

            }

            if (RFSurveyEvent != null)
            {

                xml_str += RFSurveyEvent.ToString();

            }

            if (AISpecEvent != null)
            {

                xml_str += AISpecEvent.ToString();

            }

            if (AntennaEvent != null)
            {

                xml_str += AntennaEvent.ToString();

            }

            if (ConnectionAttemptEvent != null)
            {

                xml_str += ConnectionAttemptEvent.ToString();

            }

            if (ConnectionCloseEvent != null)
            {

                xml_str += ConnectionCloseEvent.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</ReaderEventNotificationData>";
            return xml_str;
        }

        public static PARAM_ReaderEventNotificationData FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReaderEventNotificationData param = new PARAM_ReaderEventNotificationData();


            {

                param.Timestamp = new UNION_Timestamp();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "UTCTimestamp");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.Timestamp.Add(PARAM_UTCTimestamp.FromXmlNode(xnl[i]));
                        }
                    }

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Uptime");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.Timestamp.Add(PARAM_Uptime.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "HoppingEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.HoppingEvent = PARAM_HoppingEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.GPIEvent = PARAM_GPIEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecEvent = PARAM_ROSpecEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReportBufferLevelWarningEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ReportBufferLevelWarningEvent = PARAM_ReportBufferLevelWarningEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReportBufferOverflowErrorEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ReportBufferOverflowErrorEvent = PARAM_ReportBufferOverflowErrorEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderExceptionEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ReaderExceptionEvent = PARAM_ReaderExceptionEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFSurveyEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.RFSurveyEvent = PARAM_RFSurveyEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AISpecEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AISpecEvent = PARAM_AISpecEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AntennaEvent = PARAM_AntennaEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ConnectionAttemptEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ConnectionAttemptEvent = PARAM_ConnectionAttemptEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ConnectionCloseEvent");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ConnectionCloseEvent = PARAM_ConnectionCloseEvent.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// A Reader reports this event every time it hops frequency.NextChannelIndex: This is the one-based ChannelIindex of the next channel to which the Reader is going to hop change to. The channel Ids are listed in the Frequency Hop Table.
    /// </summary>
    public class PARAM_HoppingEvent : Parameter
    {
        public PARAM_HoppingEvent()
        {
            typeID = 247;

        }


        public UInt16 HopTableID = 0;
        private Int16 HopTableID_len = 0;

        public UInt16 NextChannelIndex = 0;
        private Int16 NextChannelIndex_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (HopTableID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(HopTableID, HopTableID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NextChannelIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NextChannelIndex, NextChannelIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_HoppingEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_HoppingEvent param = new PARAM_HoppingEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.HopTableID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NextChannelIndex = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<HoppingEvent>";

            if (HopTableID != null)
            {

                xml_str += "<HopTableID>" + HopTableID.ToString() + "</HopTableID>";

            }

            if (NextChannelIndex != null)
            {

                xml_str += "<NextChannelIndex>" + NextChannelIndex.ToString() + "</NextChannelIndex>";

            }

            xml_str += "</HoppingEvent>";
            return xml_str;
        }

        public static PARAM_HoppingEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_HoppingEvent param = new PARAM_HoppingEvent();


            val = XmlUtil.GetNodeValue(node, "HopTableID");

            param.HopTableID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NextChannelIndex");

            param.NextChannelIndex = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// A reader reports this event every time an enabled GPI changes GPIstate.
    /// </summary>
    public class PARAM_GPIEvent : Parameter
    {
        public PARAM_GPIEvent()
        {
            typeID = 248;

        }


        public UInt16 GPIPortNumber = 0;
        private Int16 GPIPortNumber_len = 0;

        public bool GPIEvent = false;
        private Int16 GPIEvent_len = 0;

        private const UInt16 param_reserved_len = 7;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (GPIPortNumber != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIPortNumber, GPIPortNumber_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (GPIEvent != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIEvent, GPIEvent_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_GPIEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_GPIEvent param = new PARAM_GPIEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.GPIPortNumber = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.GPIEvent = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GPIEvent>";

            if (GPIPortNumber != null)
            {

                xml_str += "<GPIPortNumber>" + GPIPortNumber.ToString() + "</GPIPortNumber>";

            }

            if (GPIEvent != null)
            {

                xml_str += "<GPIEvent>" + GPIEvent.ToString() + "</GPIEvent>";

            }

            xml_str += "</GPIEvent>";
            return xml_str;
        }

        public static PARAM_GPIEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_GPIEvent param = new PARAM_GPIEvent();


            val = XmlUtil.GetNodeValue(node, "GPIPortNumber");

            param.GPIPortNumber = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "GPIEvent");

            param.GPIEvent = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the ROSpec event details. The EventType could be start or end of the ROSpec.ROSpecID:  This is the ID of the ROSpec that started, ended or got preempted.
    /// </summary>
    public class PARAM_ROSpecEvent : Parameter
    {
        public PARAM_ROSpecEvent()
        {
            typeID = 249;

        }


        public
      ENUM_ROSpecEventType EventType;
        private Int16 EventType_len = 8;
        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public UInt32 PreemptingROSpecID = 0;
        private Int16 PreemptingROSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EventType, EventType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (PreemptingROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PreemptingROSpecID, PreemptingROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ROSpecEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ROSpecEvent param = new PARAM_ROSpecEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EventType = (
        ENUM_ROSpecEventType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.PreemptingROSpecID = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ROSpecEvent>";

            if (EventType != null)
            {

                xml_str += "<EventType>" + EventType.ToString() + "</EventType>";

            }

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            if (PreemptingROSpecID != null)
            {

                xml_str += "<PreemptingROSpecID>" + PreemptingROSpecID.ToString() + "</PreemptingROSpecID>";

            }

            xml_str += "</ROSpecEvent>";
            return xml_str;
        }

        public static PARAM_ROSpecEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ROSpecEvent param = new PARAM_ROSpecEvent();


            val = XmlUtil.GetNodeValue(node, "EventType");

            param.EventType = (
      ENUM_ROSpecEventType)Enum.Parse(typeof(
      ENUM_ROSpecEventType), val);

            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "PreemptingROSpecID");

            param.PreemptingROSpecID = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// A Reader can warn the Client that the Reader's report buffer is filling up.  A Client can act upon this warning by requesting report data from the Reader, thereby freeing the Reader's report memory resources.A Reader MAY send a report buffer level warning event whenever the Reader senses that its report memory resources are running short.  The buffer level at which a warning is reported is Reader implementation dependent.  A Client MAY act upon a report buffer level warning event by requesting report data from the Reader and thereby free report memory resources in the Reader.
    /// </summary>
    public class PARAM_ReportBufferLevelWarningEvent : Parameter
    {
        public PARAM_ReportBufferLevelWarningEvent()
        {
            typeID = 250;

        }


        public byte ReportBufferPercentageFull = 0;
        private Int16 ReportBufferPercentageFull_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ReportBufferPercentageFull != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ReportBufferPercentageFull, ReportBufferPercentageFull_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReportBufferLevelWarningEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReportBufferLevelWarningEvent param = new PARAM_ReportBufferLevelWarningEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            param.ReportBufferPercentageFull = (byte)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReportBufferLevelWarningEvent>";

            if (ReportBufferPercentageFull != null)
            {

                xml_str += "<ReportBufferPercentageFull>" + ReportBufferPercentageFull.ToString() + "</ReportBufferPercentageFull>";

            }

            xml_str += "</ReportBufferLevelWarningEvent>";
            return xml_str;
        }

        public static PARAM_ReportBufferLevelWarningEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReportBufferLevelWarningEvent param = new PARAM_ReportBufferLevelWarningEvent();


            val = XmlUtil.GetNodeValue(node, "ReportBufferPercentageFull");

            param.ReportBufferPercentageFull = Convert.ToByte(val);

            return param;
        }

    }

    /// <summary>
    /// A Reader reports a buffer overflow event whenever report data is lost due to lack of memory resources.A Reader SHALL report a buffer overflow event whenever report data is lost due to lack of memory resources.
    /// </summary>
    public class PARAM_ReportBufferOverflowErrorEvent : Parameter
    {
        public PARAM_ReportBufferOverflowErrorEvent()
        {
            typeID = 251;

        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }



            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReportBufferOverflowErrorEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReportBufferOverflowErrorEvent param = new PARAM_ReportBufferOverflowErrorEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReportBufferOverflowErrorEvent>";

            xml_str += "</ReportBufferOverflowErrorEvent>";
            return xml_str;
        }

        public static PARAM_ReportBufferOverflowErrorEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReportBufferOverflowErrorEvent param = new PARAM_ReportBufferOverflowErrorEvent();


            return param;
        }

    }

    /// <summary>
    /// The reader exception status event notifies the client that an unexpected event has occurred on the reader.  Optional parameters provide more detail to the client as to the nature and scope of the event.
    /// </summary>
    public class PARAM_ReaderExceptionEvent : Parameter
    {
        public PARAM_ReaderExceptionEvent()
        {
            typeID = 252;

        }


        public string Message = string.Empty;
        private Int16 Message_len;

        public PARAM_ROSpecID ROSpecID;

        public PARAM_SpecIndex SpecIndex;

        public PARAM_InventoryParameterSpecID InventoryParameterSpecID;

        public PARAM_AntennaID AntennaID;

        public PARAM_AccessSpecID AccessSpecID;

        public PARAM_OpSpecID OpSpecID;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IReaderExceptionEvent_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Message != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(Message.Length), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(Message, Message_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }

            if (ROSpecID != null)
            {
                ROSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (SpecIndex != null)
            {
                SpecIndex.ToBitArray(ref bit_array, ref cursor);

            }

            if (InventoryParameterSpecID != null)
            {
                InventoryParameterSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaID != null)
            {
                AntennaID.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessSpecID != null)
            {
                AccessSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (OpSpecID != null)
            {
                OpSpecID.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ReaderExceptionEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ReaderExceptionEvent param = new PARAM_ReaderExceptionEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            param.Message = (string)obj_val;

            param.ROSpecID = PARAM_ROSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.SpecIndex = PARAM_SpecIndex.FromBitArray(ref bit_array, ref cursor, length);

            param.InventoryParameterSpecID = PARAM_InventoryParameterSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.AntennaID = PARAM_AntennaID.FromBitArray(ref bit_array, ref cursor, length);

            param.AccessSpecID = PARAM_AccessSpecID.FromBitArray(ref bit_array, ref cursor, length);

            param.OpSpecID = PARAM_OpSpecID.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ReaderExceptionEvent>";

            if (Message != null)
            {

                xml_str += "<Message>" + Message.ToString() + "</Message>";

            }

            if (ROSpecID != null)
            {

                xml_str += ROSpecID.ToString();

            }

            if (SpecIndex != null)
            {

                xml_str += SpecIndex.ToString();

            }

            if (InventoryParameterSpecID != null)
            {

                xml_str += InventoryParameterSpecID.ToString();

            }

            if (AntennaID != null)
            {

                xml_str += AntennaID.ToString();

            }

            if (AccessSpecID != null)
            {

                xml_str += AccessSpecID.ToString();

            }

            if (OpSpecID != null)
            {

                xml_str += OpSpecID.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</ReaderExceptionEvent>";
            return xml_str;
        }

        public static PARAM_ReaderExceptionEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ReaderExceptionEvent param = new PARAM_ReaderExceptionEvent();


            val = XmlUtil.GetNodeValue(node, "Message");

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ROSpecID = PARAM_ROSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "SpecIndex");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.SpecIndex = PARAM_SpecIndex.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "InventoryParameterSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.InventoryParameterSpecID = PARAM_InventoryParameterSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AntennaID = PARAM_AntennaID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.AccessSpecID = PARAM_AccessSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "OpSpecID");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.OpSpecID = PARAM_OpSpecID.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Reports the OpSpecID in the reader exception event
    /// </summary>
    public class PARAM_OpSpecID : Parameter
    {
        public PARAM_OpSpecID()
        {
            typeID = 17;
            tvCoding = true;
        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_OpSpecID FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_OpSpecID param = new PARAM_OpSpecID();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<OpSpecID>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            xml_str += "</OpSpecID>";
            return xml_str;
        }

        public static PARAM_OpSpecID FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_OpSpecID param = new PARAM_OpSpecID();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// ROSpecID: The identifier of the ROSpec that contains the RFSurveySpec.
    /// </summary>
    public class PARAM_RFSurveyEvent : Parameter
    {
        public PARAM_RFSurveyEvent()
        {
            typeID = 253;

        }


        public
      ENUM_RFSurveyEventType EventType;
        private Int16 EventType_len = 8;
        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public UInt16 SpecIndex = 0;
        private Int16 SpecIndex_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EventType, EventType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (SpecIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SpecIndex, SpecIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_RFSurveyEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_RFSurveyEvent param = new PARAM_RFSurveyEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EventType = (
        ENUM_RFSurveyEventType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.SpecIndex = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RFSurveyEvent>";

            if (EventType != null)
            {

                xml_str += "<EventType>" + EventType.ToString() + "</EventType>";

            }

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            if (SpecIndex != null)
            {

                xml_str += "<SpecIndex>" + SpecIndex.ToString() + "</SpecIndex>";

            }

            xml_str += "</RFSurveyEvent>";
            return xml_str;
        }

        public static PARAM_RFSurveyEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_RFSurveyEvent param = new PARAM_RFSurveyEvent();


            val = XmlUtil.GetNodeValue(node, "EventType");

            param.EventType = (
      ENUM_RFSurveyEventType)Enum.Parse(typeof(
      ENUM_RFSurveyEventType), val);

            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "SpecIndex");

            param.SpecIndex = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the AISpec event details. The EventType is the end of the AISpec. When reporting the end event, the AirProtocolSingulationDetails MAY be reported if it is supported by the Reader and EventType of 7 has been enabled (Section 13.2.5.1).
    /// </summary>
    public class PARAM_AISpecEvent : Parameter
    {
        public PARAM_AISpecEvent()
        {
            typeID = 254;

        }


        public
      ENUM_AISpecEventType EventType;
        private Int16 EventType_len = 8;
        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;

        public UInt16 SpecIndex = 0;
        private Int16 SpecIndex_len = 0;

        public UNION_AirProtocolSingulationDetails AirProtocolSingulationDetails = new UNION_AirProtocolSingulationDetails();

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EventType, EventType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ROSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (SpecIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SpecIndex, SpecIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            len = AirProtocolSingulationDetails.Count;
            for (int i = 0; i < len; i++) AirProtocolSingulationDetails[i].ToBitArray(ref bit_array, ref cursor);


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AISpecEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AISpecEvent param = new PARAM_AISpecEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EventType = (
        ENUM_AISpecEventType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ROSpecID = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.SpecIndex = (UInt16)obj_val;

            PARAM_C1G2SingulationDetails _param_C1G2SingulationDetails = PARAM_C1G2SingulationDetails.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2SingulationDetails != null)
            {
                param.AirProtocolSingulationDetails.Add(_param_C1G2SingulationDetails);
                while ((_param_C1G2SingulationDetails = PARAM_C1G2SingulationDetails.FromBitArray(ref bit_array, ref cursor, length)) != null)
                    param.AirProtocolSingulationDetails.Add(_param_C1G2SingulationDetails);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AISpecEvent>";

            if (EventType != null)
            {

                xml_str += "<EventType>" + EventType.ToString() + "</EventType>";

            }

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            if (SpecIndex != null)
            {

                xml_str += "<SpecIndex>" + SpecIndex.ToString() + "</SpecIndex>";

            }

            if (AirProtocolSingulationDetails != null)
            {
                len = AirProtocolSingulationDetails.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolSingulationDetails[i].ToString();
            }

            xml_str += "</AISpecEvent>";
            return xml_str;
        }

        public static PARAM_AISpecEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AISpecEvent param = new PARAM_AISpecEvent();


            val = XmlUtil.GetNodeValue(node, "EventType");

            param.EventType = (
      ENUM_AISpecEventType)Enum.Parse(typeof(
      ENUM_AISpecEventType), val);

            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            param.ROSpecID = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "SpecIndex");

            param.SpecIndex = Convert.ToUInt16(val);

            {

                param.AirProtocolSingulationDetails = new UNION_AirProtocolSingulationDetails();

                try
                {

                    {
                        XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2SingulationDetails");
                        if (xnl.Count != 0)
                        {
                            for (int i = 0; i < xnl.Count; i++)
                                param.AirProtocolSingulationDetails.Add(PARAM_C1G2SingulationDetails.FromXmlNode(xnl[i]));
                        }
                    }

                }
                catch { }

            }

            return param;
        }

    }

    /// <summary>
    /// This event is generated when the Reader detects that an antenna is connected or disconnected.
    /// </summary>
    public class PARAM_AntennaEvent : Parameter
    {
        public PARAM_AntennaEvent()
        {
            typeID = 255;

        }


        public
      ENUM_AntennaEventType EventType;
        private Int16 EventType_len = 8;
        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EventType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EventType, EventType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AntennaID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_AntennaEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_AntennaEvent param = new PARAM_AntennaEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.EventType = (
        ENUM_AntennaEventType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.AntennaID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<AntennaEvent>";

            if (EventType != null)
            {

                xml_str += "<EventType>" + EventType.ToString() + "</EventType>";

            }

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            xml_str += "</AntennaEvent>";
            return xml_str;
        }

        public static PARAM_AntennaEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_AntennaEvent param = new PARAM_AntennaEvent();


            val = XmlUtil.GetNodeValue(node, "EventType");

            param.EventType = (
      ENUM_AntennaEventType)Enum.Parse(typeof(
      ENUM_AntennaEventType), val);

            val = XmlUtil.GetNodeValue(node, "AntennaID");

            param.AntennaID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This status report parameter establishes Reader connection status when the Client or Reader initiates a connection.  See section 18.1, TCP Transport, for more details regarding the use of this report.
    /// </summary>
    public class PARAM_ConnectionAttemptEvent : Parameter
    {
        public PARAM_ConnectionAttemptEvent()
        {
            typeID = 256;

        }


        public
      ENUM_ConnectionAttemptStatusType Status;
        private Int16 Status_len = 16;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Status != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Status, Status_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ConnectionAttemptEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ConnectionAttemptEvent param = new PARAM_ConnectionAttemptEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Status = (
        ENUM_ConnectionAttemptStatusType)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ConnectionAttemptEvent>";

            if (Status != null)
            {

                xml_str += "<Status>" + Status.ToString() + "</Status>";

            }

            xml_str += "</ConnectionAttemptEvent>";
            return xml_str;
        }

        public static PARAM_ConnectionAttemptEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ConnectionAttemptEvent param = new PARAM_ConnectionAttemptEvent();


            val = XmlUtil.GetNodeValue(node, "Status");

            param.Status = (
      ENUM_ConnectionAttemptStatusType)Enum.Parse(typeof(
      ENUM_ConnectionAttemptStatusType), val);

            return param;
        }

    }

    /// <summary>
    /// This status report parameter informs the Client that, unsolicited by the Client, the Reader will close the connection between the Reader and Client.  Before the Reader closes a connection with the Client that is not solicited by the Client, the Reader SHALL first attempt to send a READER_EVENT_NOTIFICATION containing this parameter to the Client.Once the Reader sends this event to the Client, the Reader SHALL close the connection to the Client.  This is also to say that, once the Reader sends this event, the Reader SHALL send no additional messages to the Client and the Reader SHALL ignore any messages received from the Client until another new connection is established.
    /// </summary>
    public class PARAM_ConnectionCloseEvent : Parameter
    {
        public PARAM_ConnectionCloseEvent()
        {
            typeID = 257;

        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }



            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ConnectionCloseEvent FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ConnectionCloseEvent param = new PARAM_ConnectionCloseEvent();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ConnectionCloseEvent>";

            xml_str += "</ConnectionCloseEvent>";
            return xml_str;
        }

        public static PARAM_ConnectionCloseEvent FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ConnectionCloseEvent param = new PARAM_ConnectionCloseEvent();


            return param;
        }

    }

    /// <summary>
    /// 
    /// </summary>
    public class PARAM_LLRPStatus : Parameter
    {
        public PARAM_LLRPStatus()
        {
            typeID = 287;

        }


        public
      ENUM_StatusCode StatusCode;
        private Int16 StatusCode_len = 16;
        public string ErrorDescription = string.Empty;
        private Int16 ErrorDescription_len;

        public PARAM_FieldError FieldError;

        public PARAM_ParameterError ParameterError;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (StatusCode != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StatusCode, StatusCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ErrorDescription != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ErrorDescription.Length), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ErrorDescription, ErrorDescription_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }

            if (FieldError != null)
            {
                FieldError.ToBitArray(ref bit_array, ref cursor);

            }

            if (ParameterError != null)
            {
                ParameterError.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_LLRPStatus FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_LLRPStatus param = new PARAM_LLRPStatus();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.StatusCode = (
        ENUM_StatusCode)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(string), field_len);
            param.ErrorDescription = (string)obj_val;

            param.FieldError = PARAM_FieldError.FromBitArray(ref bit_array, ref cursor, length);

            param.ParameterError = PARAM_ParameterError.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<LLRPStatus>";

            if (StatusCode != null)
            {

                xml_str += "<StatusCode>" + StatusCode.ToString() + "</StatusCode>";

            }

            if (ErrorDescription != null)
            {

                xml_str += "<ErrorDescription>" + ErrorDescription.ToString() + "</ErrorDescription>";

            }

            if (FieldError != null)
            {

                xml_str += FieldError.ToString();

            }

            if (ParameterError != null)
            {

                xml_str += ParameterError.ToString();

            }

            xml_str += "</LLRPStatus>";
            return xml_str;
        }

        public static PARAM_LLRPStatus FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_LLRPStatus param = new PARAM_LLRPStatus();


            val = XmlUtil.GetNodeValue(node, "StatusCode");

            param.StatusCode = (
      ENUM_StatusCode)Enum.Parse(typeof(
      ENUM_StatusCode), val);

            val = XmlUtil.GetNodeValue(node, "ErrorDescription");

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FieldError");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FieldError = PARAM_FieldError.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ParameterError");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ParameterError = PARAM_ParameterError.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// FieldNum: Field number for which the error applies. The fields are numbered after the order in which they appear in the parameter or message body.
    /// </summary>
    public class PARAM_FieldError : Parameter
    {
        public PARAM_FieldError()
        {
            typeID = 288;

        }


        public UInt16 FieldNum = 0;
        private Int16 FieldNum_len = 0;

        public
      ENUM_StatusCode ErrorCode;
        private Int16 ErrorCode_len = 16;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (FieldNum != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(FieldNum, FieldNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ErrorCode != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ErrorCode, ErrorCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_FieldError FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_FieldError param = new PARAM_FieldError();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.FieldNum = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ErrorCode = (
        ENUM_StatusCode)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<FieldError>";

            if (FieldNum != null)
            {

                xml_str += "<FieldNum>" + FieldNum.ToString() + "</FieldNum>";

            }

            if (ErrorCode != null)
            {

                xml_str += "<ErrorCode>" + ErrorCode.ToString() + "</ErrorCode>";

            }

            xml_str += "</FieldError>";
            return xml_str;
        }

        public static PARAM_FieldError FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_FieldError param = new PARAM_FieldError();


            val = XmlUtil.GetNodeValue(node, "FieldNum");

            param.FieldNum = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ErrorCode");

            param.ErrorCode = (
      ENUM_StatusCode)Enum.Parse(typeof(
      ENUM_StatusCode), val);

            return param;
        }

    }

    /// <summary>
    /// The parameter type that caused this error.
    /// </summary>
    public class PARAM_ParameterError : Parameter
    {
        public PARAM_ParameterError()
        {
            typeID = 289;

        }


        public UInt16 ParameterType = 0;
        private Int16 ParameterType_len = 0;

        public
      ENUM_StatusCode ErrorCode;
        private Int16 ErrorCode_len = 16;
        public PARAM_FieldError FieldError;

        public PARAM_ParameterError ParameterError;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ParameterType != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ParameterType, ParameterType_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ErrorCode != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ErrorCode, ErrorCode_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (FieldError != null)
            {
                FieldError.ToBitArray(ref bit_array, ref cursor);

            }

            if (ParameterError != null)
            {
                ParameterError.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_ParameterError FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_ParameterError param = new PARAM_ParameterError();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ParameterType = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ErrorCode = (
        ENUM_StatusCode)(UInt32)obj_val;

            param.FieldError = PARAM_FieldError.FromBitArray(ref bit_array, ref cursor, length);

            param.ParameterError = PARAM_ParameterError.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ParameterError>";

            if (ParameterType != null)
            {

                xml_str += "<ParameterType>" + ParameterType.ToString() + "</ParameterType>";

            }

            if (ErrorCode != null)
            {

                xml_str += "<ErrorCode>" + ErrorCode.ToString() + "</ErrorCode>";

            }

            if (FieldError != null)
            {

                xml_str += FieldError.ToString();

            }

            if (ParameterError != null)
            {

                xml_str += ParameterError.ToString();

            }

            xml_str += "</ParameterError>";
            return xml_str;
        }

        public static PARAM_ParameterError FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_ParameterError param = new PARAM_ParameterError();


            val = XmlUtil.GetNodeValue(node, "ParameterType");

            param.ParameterType = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ErrorCode");

            param.ErrorCode = (
      ENUM_StatusCode)Enum.Parse(typeof(
      ENUM_StatusCode), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "FieldError");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.FieldError = PARAM_FieldError.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ParameterError");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.ParameterError = PARAM_ParameterError.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// Readers MAY support BlockErase, and MAY support BlockWrite. Readers SHALL support at least one select filter per query. 
    /// </summary>
    public class PARAM_C1G2LLRPCapabilities : Parameter
    {
        public PARAM_C1G2LLRPCapabilities()
        {
            typeID = 327;

        }


        public bool CanSupportBlockErase = false;
        private Int16 CanSupportBlockErase_len = 0;

        public bool CanSupportBlockWrite = false;
        private Int16 CanSupportBlockWrite_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 MaxNumSelectFiltersPerQuery = 0;
        private Int16 MaxNumSelectFiltersPerQuery_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (CanSupportBlockErase != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanSupportBlockErase, CanSupportBlockErase_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (CanSupportBlockWrite != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CanSupportBlockWrite, CanSupportBlockWrite_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (MaxNumSelectFiltersPerQuery != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxNumSelectFiltersPerQuery, MaxNumSelectFiltersPerQuery_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2LLRPCapabilities FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2LLRPCapabilities param = new PARAM_C1G2LLRPCapabilities();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanSupportBlockErase = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.CanSupportBlockWrite = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.MaxNumSelectFiltersPerQuery = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2LLRPCapabilities>";

            if (CanSupportBlockErase != null)
            {

                xml_str += "<CanSupportBlockErase>" + CanSupportBlockErase.ToString() + "</CanSupportBlockErase>";

            }

            if (CanSupportBlockWrite != null)
            {

                xml_str += "<CanSupportBlockWrite>" + CanSupportBlockWrite.ToString() + "</CanSupportBlockWrite>";

            }

            if (MaxNumSelectFiltersPerQuery != null)
            {

                xml_str += "<MaxNumSelectFiltersPerQuery>" + MaxNumSelectFiltersPerQuery.ToString() + "</MaxNumSelectFiltersPerQuery>";

            }

            xml_str += "</C1G2LLRPCapabilities>";
            return xml_str;
        }

        public static PARAM_C1G2LLRPCapabilities FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2LLRPCapabilities param = new PARAM_C1G2LLRPCapabilities();


            val = XmlUtil.GetNodeValue(node, "CanSupportBlockErase");

            param.CanSupportBlockErase = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "CanSupportBlockWrite");

            param.CanSupportBlockWrite = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "MaxNumSelectFiltersPerQuery");

            param.MaxNumSelectFiltersPerQuery = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the set of C1G2 RF modes that the Reader is capable of operating.
    /// </summary>
    public class PARAM_C1G2UHFRFModeTable : Parameter
    {
        public PARAM_C1G2UHFRFModeTable()
        {
            typeID = 328;

        }


        public PARAM_C1G2UHFRFModeTableEntry[] C1G2UHFRFModeTableEntry;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (C1G2UHFRFModeTableEntry != null)
            {

                len = C1G2UHFRFModeTableEntry.Length;
                for (int i = 0; i < len; i++)
                    C1G2UHFRFModeTableEntry[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2UHFRFModeTable FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2UHFRFModeTable param = new PARAM_C1G2UHFRFModeTable();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param_list = new ArrayList();
            PARAM_C1G2UHFRFModeTableEntry _param_C1G2UHFRFModeTableEntry = PARAM_C1G2UHFRFModeTableEntry.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2UHFRFModeTableEntry != null)
            {
                param_list.Add(_param_C1G2UHFRFModeTableEntry);
                while ((_param_C1G2UHFRFModeTableEntry = PARAM_C1G2UHFRFModeTableEntry.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_C1G2UHFRFModeTableEntry);
                if (param_list.Count > 0)
                {
                    param.C1G2UHFRFModeTableEntry = new PARAM_C1G2UHFRFModeTableEntry[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.C1G2UHFRFModeTableEntry[i] = (PARAM_C1G2UHFRFModeTableEntry)param_list[i];
                }
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2UHFRFModeTable>";

            if (C1G2UHFRFModeTableEntry != null)
            {

                len = C1G2UHFRFModeTableEntry.Length;
                for (int i = 0; i < len; i++)
                    xml_str += C1G2UHFRFModeTableEntry[i].ToString();

            }

            xml_str += "</C1G2UHFRFModeTable>";
            return xml_str;
        }

        public static PARAM_C1G2UHFRFModeTable FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2UHFRFModeTable param = new PARAM_C1G2UHFRFModeTable();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2UHFRFModeTableEntry");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.C1G2UHFRFModeTableEntry = new PARAM_C1G2UHFRFModeTableEntry[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.C1G2UHFRFModeTableEntry[i] = PARAM_C1G2UHFRFModeTableEntry.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter carries the information for each UHFC1G2 RF mode. A mode that has been tested for conformance by the EPCGlobal Hardware Action Group's Testing and Conformance (HAG T and C) group, is indicated using a conformance flag.
    /// </summary>
    public class PARAM_C1G2UHFRFModeTableEntry : Parameter
    {
        public PARAM_C1G2UHFRFModeTableEntry()
        {
            typeID = 329;

        }


        public UInt32 ModeIdentifier = 0;
        private Int16 ModeIdentifier_len = 0;

        public
      ENUM_C1G2DRValue DRValue;
        private Int16 DRValue_len = 1;
        public bool EPCHAGTCConformance = false;
        private Int16 EPCHAGTCConformance_len = 0;

        private const UInt16 param_reserved_len = 6;

        public
      ENUM_C1G2MValue MValue;
        private Int16 MValue_len = 8;
        public
      ENUM_C1G2ForwardLinkModulation ForwardLinkModulation;
        private Int16 ForwardLinkModulation_len = 8;
        public
      ENUM_C1G2SpectralMaskIndicator SpectralMaskIndicator;
        private Int16 SpectralMaskIndicator_len = 8;
        public UInt32 BDRValue = 0;
        private Int16 BDRValue_len = 0;

        public UInt32 PIEValue = 0;
        private Int16 PIEValue_len = 0;

        public UInt32 MinTariValue = 0;
        private Int16 MinTariValue_len = 0;

        public UInt32 MaxTariValue = 0;
        private Int16 MaxTariValue_len = 0;

        public UInt32 StepTariValue = 0;
        private Int16 StepTariValue_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ModeIdentifier != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ModeIdentifier, ModeIdentifier_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (DRValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DRValue, DRValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EPCHAGTCConformance != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EPCHAGTCConformance, EPCHAGTCConformance_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (MValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MValue, MValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ForwardLinkModulation != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ForwardLinkModulation, ForwardLinkModulation_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (SpectralMaskIndicator != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(SpectralMaskIndicator, SpectralMaskIndicator_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (BDRValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(BDRValue, BDRValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (PIEValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PIEValue, PIEValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MinTariValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MinTariValue, MinTariValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MaxTariValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MaxTariValue, MaxTariValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (StepTariValue != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(StepTariValue, StepTariValue_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2UHFRFModeTableEntry FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2UHFRFModeTableEntry param = new PARAM_C1G2UHFRFModeTableEntry();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ModeIdentifier = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DRValue = (
        ENUM_C1G2DRValue)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EPCHAGTCConformance = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MValue = (
        ENUM_C1G2MValue)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.ForwardLinkModulation = (
        ENUM_C1G2ForwardLinkModulation)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.SpectralMaskIndicator = (
        ENUM_C1G2SpectralMaskIndicator)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.BDRValue = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.PIEValue = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MinTariValue = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.MaxTariValue = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.StepTariValue = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2UHFRFModeTableEntry>";

            if (ModeIdentifier != null)
            {

                xml_str += "<ModeIdentifier>" + ModeIdentifier.ToString() + "</ModeIdentifier>";

            }

            if (DRValue != null)
            {

                xml_str += "<DRValue>" + DRValue.ToString() + "</DRValue>";

            }

            if (EPCHAGTCConformance != null)
            {

                xml_str += "<EPCHAGTCConformance>" + EPCHAGTCConformance.ToString() + "</EPCHAGTCConformance>";

            }

            if (MValue != null)
            {

                xml_str += "<MValue>" + MValue.ToString() + "</MValue>";

            }

            if (ForwardLinkModulation != null)
            {

                xml_str += "<ForwardLinkModulation>" + ForwardLinkModulation.ToString() + "</ForwardLinkModulation>";

            }

            if (SpectralMaskIndicator != null)
            {

                xml_str += "<SpectralMaskIndicator>" + SpectralMaskIndicator.ToString() + "</SpectralMaskIndicator>";

            }

            if (BDRValue != null)
            {

                xml_str += "<BDRValue>" + BDRValue.ToString() + "</BDRValue>";

            }

            if (PIEValue != null)
            {

                xml_str += "<PIEValue>" + PIEValue.ToString() + "</PIEValue>";

            }

            if (MinTariValue != null)
            {

                xml_str += "<MinTariValue>" + MinTariValue.ToString() + "</MinTariValue>";

            }

            if (MaxTariValue != null)
            {

                xml_str += "<MaxTariValue>" + MaxTariValue.ToString() + "</MaxTariValue>";

            }

            if (StepTariValue != null)
            {

                xml_str += "<StepTariValue>" + StepTariValue.ToString() + "</StepTariValue>";

            }

            xml_str += "</C1G2UHFRFModeTableEntry>";
            return xml_str;
        }

        public static PARAM_C1G2UHFRFModeTableEntry FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2UHFRFModeTableEntry param = new PARAM_C1G2UHFRFModeTableEntry();


            val = XmlUtil.GetNodeValue(node, "ModeIdentifier");

            param.ModeIdentifier = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "DRValue");

            param.DRValue = (
      ENUM_C1G2DRValue)Enum.Parse(typeof(
      ENUM_C1G2DRValue), val);

            val = XmlUtil.GetNodeValue(node, "EPCHAGTCConformance");

            param.EPCHAGTCConformance = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "MValue");

            param.MValue = (
      ENUM_C1G2MValue)Enum.Parse(typeof(
      ENUM_C1G2MValue), val);

            val = XmlUtil.GetNodeValue(node, "ForwardLinkModulation");

            param.ForwardLinkModulation = (
      ENUM_C1G2ForwardLinkModulation)Enum.Parse(typeof(
      ENUM_C1G2ForwardLinkModulation), val);

            val = XmlUtil.GetNodeValue(node, "SpectralMaskIndicator");

            param.SpectralMaskIndicator = (
      ENUM_C1G2SpectralMaskIndicator)Enum.Parse(typeof(
      ENUM_C1G2SpectralMaskIndicator), val);

            val = XmlUtil.GetNodeValue(node, "BDRValue");

            param.BDRValue = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "PIEValue");

            param.PIEValue = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MinTariValue");

            param.MinTariValue = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MaxTariValue");

            param.MaxTariValue = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "StepTariValue");

            param.StepTariValue = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter defines the C1G2 inventory-specific settings to be used during a particular C1G2 inventory operation. This comprises of C1G2Filter Parameter, C1G2RF Parameter and C1G2Singulation Parameter. It is not necessary that the Filter, RF Control and Singulation Control Parameters be specified in each and every inventory command. They are optional parameters. If not specified, the default values in the Reader are used during the inventory operation. If multiple C1G2Filter parameters are encapsulated by the Client in the C1G2InventoryCommand parameter, the ordering of the filter parameters determine the order of C1G2 air-protocol commands (e.g., Select command) generated by the Reader.The TagInventoryStateAware flag is used to determine how to process all the C1G2Filter and C1G2Singulation parameters in this command. At a functional level, if the Client is managing the tag states during an inventory operation, it would set that flag to true and pass the appropriate fields in the C1G2 Filter and C1G2 Singulation parameters. If a reader set CanDoTagInventoryStateAwareSingulation to False in LLRPCapabilities (section 9.2.2), it SHALL ignore the TagInventoryStateAware flag.
    /// </summary>
    public class PARAM_C1G2InventoryCommand : Parameter
    {
        public PARAM_C1G2InventoryCommand()
        {
            typeID = 330;

        }


        public bool TagInventoryStateAware = false;
        private Int16 TagInventoryStateAware_len = 0;

        private const UInt16 param_reserved_len = 7;

        public PARAM_C1G2Filter[] C1G2Filter;

        public PARAM_C1G2RFControl C1G2RFControl;

        public PARAM_C1G2SingulationControl C1G2SingulationControl;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IC1G2InventoryCommand_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (TagInventoryStateAware != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagInventoryStateAware, TagInventoryStateAware_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (C1G2Filter != null)
            {

                len = C1G2Filter.Length;
                for (int i = 0; i < len; i++)
                    C1G2Filter[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (C1G2RFControl != null)
            {
                C1G2RFControl.ToBitArray(ref bit_array, ref cursor);

            }

            if (C1G2SingulationControl != null)
            {
                C1G2SingulationControl.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2InventoryCommand FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2InventoryCommand param = new PARAM_C1G2InventoryCommand();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.TagInventoryStateAware = (bool)obj_val;

            cursor += param_reserved_len;

            param_list = new ArrayList();
            PARAM_C1G2Filter _param_C1G2Filter = PARAM_C1G2Filter.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2Filter != null)
            {
                param_list.Add(_param_C1G2Filter);
                while ((_param_C1G2Filter = PARAM_C1G2Filter.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_C1G2Filter);
                if (param_list.Count > 0)
                {
                    param.C1G2Filter = new PARAM_C1G2Filter[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.C1G2Filter[i] = (PARAM_C1G2Filter)param_list[i];
                }
            }

            param.C1G2RFControl = PARAM_C1G2RFControl.FromBitArray(ref bit_array, ref cursor, length);

            param.C1G2SingulationControl = PARAM_C1G2SingulationControl.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                param.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) param.Custom.Add(custom);
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2InventoryCommand>";

            if (TagInventoryStateAware != null)
            {

                xml_str += "<TagInventoryStateAware>" + TagInventoryStateAware.ToString() + "</TagInventoryStateAware>";

            }

            if (C1G2Filter != null)
            {

                len = C1G2Filter.Length;
                for (int i = 0; i < len; i++)
                    xml_str += C1G2Filter[i].ToString();

            }

            if (C1G2RFControl != null)
            {

                xml_str += C1G2RFControl.ToString();

            }

            if (C1G2SingulationControl != null)
            {

                xml_str += C1G2SingulationControl.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</C1G2InventoryCommand>";
            return xml_str;
        }

        public static PARAM_C1G2InventoryCommand FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2InventoryCommand param = new PARAM_C1G2InventoryCommand();


            val = XmlUtil.GetNodeValue(node, "TagInventoryStateAware");

            param.TagInventoryStateAware = Convert.ToBoolean(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2Filter");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.C1G2Filter = new PARAM_C1G2Filter[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.C1G2Filter[i] = PARAM_C1G2Filter.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2RFControl");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2RFControl = PARAM_C1G2RFControl.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2SingulationControl");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2SingulationControl = PARAM_C1G2SingulationControl.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) param.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter carries information specific to C1G2 filter (in particular, the parameters for the select command) operation, and are optionally sent with each inventory command from the Client to the Reader. This sets up the target tag population that gets inventoried. For an inventory operation with multiple filters, multiple instances of filter parameters are sent. A filter parameter contains the following fields:
    /// </summary>
    public class PARAM_C1G2Filter : Parameter
    {
        public PARAM_C1G2Filter()
        {
            typeID = 331;

        }


        public
      ENUM_C1G2TruncateAction T;
        private Int16 T_len = 2;
        private const UInt16 param_reserved_len = 6;

        public PARAM_C1G2TagInventoryMask C1G2TagInventoryMask;

        public PARAM_C1G2TagInventoryStateAwareFilterAction C1G2TagInventoryStateAwareFilterAction;

        public PARAM_C1G2TagInventoryStateUnawareFilterAction C1G2TagInventoryStateUnawareFilterAction;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (T != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(T, T_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (C1G2TagInventoryMask != null)
            {
                C1G2TagInventoryMask.ToBitArray(ref bit_array, ref cursor);

            }

            if (C1G2TagInventoryStateAwareFilterAction != null)
            {
                C1G2TagInventoryStateAwareFilterAction.ToBitArray(ref bit_array, ref cursor);

            }

            if (C1G2TagInventoryStateUnawareFilterAction != null)
            {
                C1G2TagInventoryStateUnawareFilterAction.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2Filter FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2Filter param = new PARAM_C1G2Filter();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.T = (
        ENUM_C1G2TruncateAction)(UInt32)obj_val;

            cursor += param_reserved_len;

            param.C1G2TagInventoryMask = PARAM_C1G2TagInventoryMask.FromBitArray(ref bit_array, ref cursor, length);

            param.C1G2TagInventoryStateAwareFilterAction = PARAM_C1G2TagInventoryStateAwareFilterAction.FromBitArray(ref bit_array, ref cursor, length);

            param.C1G2TagInventoryStateUnawareFilterAction = PARAM_C1G2TagInventoryStateUnawareFilterAction.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2Filter>";

            if (T != null)
            {

                xml_str += "<T>" + T.ToString() + "</T>";

            }

            if (C1G2TagInventoryMask != null)
            {

                xml_str += C1G2TagInventoryMask.ToString();

            }

            if (C1G2TagInventoryStateAwareFilterAction != null)
            {

                xml_str += C1G2TagInventoryStateAwareFilterAction.ToString();

            }

            if (C1G2TagInventoryStateUnawareFilterAction != null)
            {

                xml_str += C1G2TagInventoryStateUnawareFilterAction.ToString();

            }

            xml_str += "</C1G2Filter>";
            return xml_str;
        }

        public static PARAM_C1G2Filter FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2Filter param = new PARAM_C1G2Filter();


            val = XmlUtil.GetNodeValue(node, "T");

            param.T = (
      ENUM_C1G2TruncateAction)Enum.Parse(typeof(
      ENUM_C1G2TruncateAction), val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TagInventoryMask");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2TagInventoryMask = PARAM_C1G2TagInventoryMask.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TagInventoryStateAwareFilterAction");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2TagInventoryStateAwareFilterAction = PARAM_C1G2TagInventoryStateAwareFilterAction.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TagInventoryStateUnawareFilterAction");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2TagInventoryStateUnawareFilterAction = PARAM_C1G2TagInventoryStateUnawareFilterAction.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// 
    /// </summary>
    public class PARAM_C1G2TagInventoryMask : Parameter
    {
        public PARAM_C1G2TagInventoryMask()
        {
            typeID = 332;

        }


        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 Pointer = 0;
        private Int16 Pointer_len = 0;

        public LLRPBitArray TagMask = new LLRPBitArray();
        private Int16 TagMask_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (Pointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Pointer, Pointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TagMask != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(TagMask.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(TagMask, TagMask_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TagInventoryMask FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TagInventoryMask param = new PARAM_C1G2TagInventoryMask();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.Pointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(LLRPBitArray), field_len);
            param.TagMask = (LLRPBitArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TagInventoryMask>";

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (Pointer != null)
            {

                xml_str += "<Pointer>" + Pointer.ToString() + "</Pointer>";

            }

            if (TagMask != null)
            {

                xml_str += "<TagMask>" + TagMask.ToHexString() + "</TagMask>";

            }

            xml_str += "</C1G2TagInventoryMask>";
            return xml_str;
        }

        public static PARAM_C1G2TagInventoryMask FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TagInventoryMask param = new PARAM_C1G2TagInventoryMask();


            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "Pointer");

            param.Pointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "TagMask");

            param.TagMask = LLRPBitArray.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter is used by the Client to manage the tag states during an inventory operation.  In order to use this parameter during inventory, the TagInventoryStateAware flag is set to true in the InventoryParameterSpec. This parameter contains:
    /// </summary>
    public class PARAM_C1G2TagInventoryStateAwareFilterAction : Parameter
    {
        public PARAM_C1G2TagInventoryStateAwareFilterAction()
        {
            typeID = 333;

        }


        public
      ENUM_C1G2StateAwareTarget Target;
        private Int16 Target_len = 8;
        public
      ENUM_C1G2StateAwareAction Action;
        private Int16 Action_len = 8;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Target != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Target, Target_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Action != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Action, Action_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TagInventoryStateAwareFilterAction FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TagInventoryStateAwareFilterAction param = new PARAM_C1G2TagInventoryStateAwareFilterAction();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Target = (
        ENUM_C1G2StateAwareTarget)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Action = (
        ENUM_C1G2StateAwareAction)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TagInventoryStateAwareFilterAction>";

            if (Target != null)
            {

                xml_str += "<Target>" + Target.ToString() + "</Target>";

            }

            if (Action != null)
            {

                xml_str += "<Action>" + Action.ToString() + "</Action>";

            }

            xml_str += "</C1G2TagInventoryStateAwareFilterAction>";
            return xml_str;
        }

        public static PARAM_C1G2TagInventoryStateAwareFilterAction FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TagInventoryStateAwareFilterAction param = new PARAM_C1G2TagInventoryStateAwareFilterAction();


            val = XmlUtil.GetNodeValue(node, "Target");

            param.Target = (
      ENUM_C1G2StateAwareTarget)Enum.Parse(typeof(
      ENUM_C1G2StateAwareTarget), val);

            val = XmlUtil.GetNodeValue(node, "Action");

            param.Action = (
      ENUM_C1G2StateAwareAction)Enum.Parse(typeof(
      ENUM_C1G2StateAwareAction), val);

            return param;
        }

    }

    /// <summary>
    /// This parameter is used by the Client if it does not want to manage the tag states during an inventory operation. Using this parameter, the Client instructs the Reader about the tags that should and should not participate in the inventory action.  In order to use this parameter during inventory, the TagInventoryStateAware flag is set to false in the InventoryParameterSpec. This parameter contains:In this parameter, Action=Select means search for pattern in Inventory, and Action=Unselect means do not search for pattern in Inventory.
    /// </summary>
    public class PARAM_C1G2TagInventoryStateUnawareFilterAction : Parameter
    {
        public PARAM_C1G2TagInventoryStateUnawareFilterAction()
        {
            typeID = 334;

        }


        public
      ENUM_C1G2StateUnawareAction Action;
        private Int16 Action_len = 8;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Action != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Action, Action_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TagInventoryStateUnawareFilterAction FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TagInventoryStateUnawareFilterAction param = new PARAM_C1G2TagInventoryStateUnawareFilterAction();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Action = (
        ENUM_C1G2StateUnawareAction)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TagInventoryStateUnawareFilterAction>";

            if (Action != null)
            {

                xml_str += "<Action>" + Action.ToString() + "</Action>";

            }

            xml_str += "</C1G2TagInventoryStateUnawareFilterAction>";
            return xml_str;
        }

        public static PARAM_C1G2TagInventoryStateUnawareFilterAction FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TagInventoryStateUnawareFilterAction param = new PARAM_C1G2TagInventoryStateUnawareFilterAction();


            val = XmlUtil.GetNodeValue(node, "Action");

            param.Action = (
      ENUM_C1G2StateUnawareAction)Enum.Parse(typeof(
      ENUM_C1G2StateUnawareAction), val);

            return param;
        }

    }

    /// <summary>
    /// This Parameter carries the settings relevant to RF forward and reverse link control in the C1G2 air protocol. This is basically the C1G2 RF Mode and the Tari value to use for the inventory operation.Tari: Value of Tari to use for this mode specified in nsec. This is specified if the mode selected has a Tari range. If the selected mode has a range, and the Tari is set to zero, the Reader implementation picks up any Tari value within the range. If the selected mode has a range, and the specified Tari is out of that range and is not set to zero, an error message is generated.
    /// </summary>
    public class PARAM_C1G2RFControl : Parameter
    {
        public PARAM_C1G2RFControl()
        {
            typeID = 335;

        }


        public UInt16 ModeIndex = 0;
        private Int16 ModeIndex_len = 0;

        public UInt16 Tari = 0;
        private Int16 Tari_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (ModeIndex != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ModeIndex, ModeIndex_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Tari != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Tari, Tari_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2RFControl FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2RFControl param = new PARAM_C1G2RFControl();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.ModeIndex = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.Tari = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2RFControl>";

            if (ModeIndex != null)
            {

                xml_str += "<ModeIndex>" + ModeIndex.ToString() + "</ModeIndex>";

            }

            if (Tari != null)
            {

                xml_str += "<Tari>" + Tari.ToString() + "</Tari>";

            }

            xml_str += "</C1G2RFControl>";
            return xml_str;
        }

        public static PARAM_C1G2RFControl FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2RFControl param = new PARAM_C1G2RFControl();


            val = XmlUtil.GetNodeValue(node, "ModeIndex");

            param.ModeIndex = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "Tari");

            param.Tari = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// This C1G2SingulationControl Parameter provides controls particular to the singulation process in the C1G2 air protocol. The singulation process is started using a Query command in the C1G2 protocol. The Query command describes the session number, tag state, the start Q value to use, and the RF link parameters. The RF link parameters are specified using the C1G2RFControl Parameter (see section 15.2.1.2.1.2). This Singulation Parameter specifies the session, tag state and description of the target singulation environment. The following attributes are specified to provide guidance to the Reader for the singulation algorithm:In addition, the Singulation Parameter allows setting of the following:If a reader sets CanDoTagInventoryStateAwareSingulation to False in LLRPCapabilities (section 9.2.2), it SHALL ignore the TagInventoryStateAwareSingulationAction field.
    /// </summary>
    public class PARAM_C1G2SingulationControl : Parameter
    {
        public PARAM_C1G2SingulationControl()
        {
            typeID = 336;

        }


        public TwoBits Session = new TwoBits(0);
        private Int16 Session_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 TagPopulation = 0;
        private Int16 TagPopulation_len = 0;

        public UInt32 TagTransitTime = 0;
        private Int16 TagTransitTime_len = 0;

        public PARAM_C1G2TagInventoryStateAwareSingulationAction C1G2TagInventoryStateAwareSingulationAction;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Session != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Session, Session_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (TagPopulation != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagPopulation, TagPopulation_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TagTransitTime != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(TagTransitTime, TagTransitTime_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (C1G2TagInventoryStateAwareSingulationAction != null)
            {
                C1G2TagInventoryStateAwareSingulationAction.ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2SingulationControl FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2SingulationControl param = new PARAM_C1G2SingulationControl();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.Session = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.TagPopulation = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.TagTransitTime = (UInt32)obj_val;

            param.C1G2TagInventoryStateAwareSingulationAction = PARAM_C1G2TagInventoryStateAwareSingulationAction.FromBitArray(ref bit_array, ref cursor, length);

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2SingulationControl>";

            if (Session != null)
            {

                xml_str += "<Session>" + Session.ToString() + "</Session>";

            }

            if (TagPopulation != null)
            {

                xml_str += "<TagPopulation>" + TagPopulation.ToString() + "</TagPopulation>";

            }

            if (TagTransitTime != null)
            {

                xml_str += "<TagTransitTime>" + TagTransitTime.ToString() + "</TagTransitTime>";

            }

            if (C1G2TagInventoryStateAwareSingulationAction != null)
            {

                xml_str += C1G2TagInventoryStateAwareSingulationAction.ToString();

            }

            xml_str += "</C1G2SingulationControl>";
            return xml_str;
        }

        public static PARAM_C1G2SingulationControl FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2SingulationControl param = new PARAM_C1G2SingulationControl();


            val = XmlUtil.GetNodeValue(node, "Session");

            param.Session = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "TagPopulation");

            param.TagPopulation = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "TagTransitTime");

            param.TagTransitTime = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TagInventoryStateAwareSingulationAction");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        param.C1G2TagInventoryStateAwareSingulationAction = PARAM_C1G2TagInventoryStateAwareSingulationAction.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// 
    /// </summary>
    public class PARAM_C1G2TagInventoryStateAwareSingulationAction : Parameter
    {
        public PARAM_C1G2TagInventoryStateAwareSingulationAction()
        {
            typeID = 337;

        }


        public bool I = false;
        private Int16 I_len = 0;

        public bool S = false;
        private Int16 S_len = 0;

        private const UInt16 param_reserved_len = 6;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (I != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(I, I_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (S != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(S, S_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TagInventoryStateAwareSingulationAction FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TagInventoryStateAwareSingulationAction param = new PARAM_C1G2TagInventoryStateAwareSingulationAction();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.I = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.S = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TagInventoryStateAwareSingulationAction>";

            if (I != null)
            {

                xml_str += "<I>" + I.ToString() + "</I>";

            }

            if (S != null)
            {

                xml_str += "<S>" + S.ToString() + "</S>";

            }

            xml_str += "</C1G2TagInventoryStateAwareSingulationAction>";
            return xml_str;
        }

        public static PARAM_C1G2TagInventoryStateAwareSingulationAction FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TagInventoryStateAwareSingulationAction param = new PARAM_C1G2TagInventoryStateAwareSingulationAction();


            val = XmlUtil.GetNodeValue(node, "I");

            param.I = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "S");

            param.S = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter describes the target tag population on which certain operations have to be performed.  This Parameter is similar to the selection C1G2Filter Parameter described earlier. However, because these tags are stored in the Reader's memory and ternary comparisons are to be allowed for, each bit i in the target tag is represented using 2 bits - bit i in mask, and bit i in tag pattern.  If bit i in the mask is zero, then bit i of the target tag is a don't care (X); if bit i in the mask is one, then bit i of the target tag is bit i of the tag pattern. For example, "all tags" is specified using a mask length of zero.This parameter can carry up to two tag patterns. If more than one pattern is present, a Boolean AND is implied. Each tag pattern has a match or a non-match flag, allowing (A and B,!A and B, !A and !B, A and !B), where A and B are the tag patterns.The tagSpec contains 2 tag patterns.
    /// </summary>
    public class PARAM_C1G2TagSpec : Parameter
    {
        public PARAM_C1G2TagSpec()
        {
            typeID = 338;

        }


        public PARAM_C1G2TargetTag[] C1G2TargetTag;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (C1G2TargetTag != null)
            {

                len = C1G2TargetTag.Length;
                for (int i = 0; i < len; i++)
                    C1G2TargetTag[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TagSpec FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TagSpec param = new PARAM_C1G2TagSpec();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            param_list = new ArrayList();
            PARAM_C1G2TargetTag _param_C1G2TargetTag = PARAM_C1G2TargetTag.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2TargetTag != null)
            {
                param_list.Add(_param_C1G2TargetTag);
                while ((_param_C1G2TargetTag = PARAM_C1G2TargetTag.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_C1G2TargetTag);
                if (param_list.Count > 0)
                {
                    param.C1G2TargetTag = new PARAM_C1G2TargetTag[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.C1G2TargetTag[i] = (PARAM_C1G2TargetTag)param_list[i];
                }
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TagSpec>";

            if (C1G2TargetTag != null)
            {

                len = C1G2TargetTag.Length;
                for (int i = 0; i < len; i++)
                    xml_str += C1G2TargetTag[i].ToString();

            }

            xml_str += "</C1G2TagSpec>";
            return xml_str;
        }

        public static PARAM_C1G2TagSpec FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TagSpec param = new PARAM_C1G2TagSpec();


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2TargetTag");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.C1G2TargetTag = new PARAM_C1G2TargetTag[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.C1G2TargetTag[i] = PARAM_C1G2TargetTag.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// If Length is zero, this pattern will match all tags regardless of MB, pointer, mask and data.
    /// </summary>
    public class PARAM_C1G2TargetTag : Parameter
    {
        public PARAM_C1G2TargetTag()
        {
            typeID = 339;

        }


        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        public bool Match = false;
        private Int16 Match_len = 0;

        private const UInt16 param_reserved_len = 5;

        public UInt16 Pointer = 0;
        private Int16 Pointer_len = 0;

        public LLRPBitArray TagMask = new LLRPBitArray();
        private Int16 TagMask_len;

        public LLRPBitArray TagData = new LLRPBitArray();
        private Int16 TagData_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (Match != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Match, Match_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (Pointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Pointer, Pointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (TagMask != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(TagMask.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(TagMask, TagMask_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }

            if (TagData != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(TagData.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(TagData, TagData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2TargetTag FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2TargetTag param = new PARAM_C1G2TargetTag();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.Match = (bool)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.Pointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(LLRPBitArray), field_len);
            param.TagMask = (LLRPBitArray)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(LLRPBitArray), field_len);
            param.TagData = (LLRPBitArray)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2TargetTag>";

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (Match != null)
            {

                xml_str += "<Match>" + Match.ToString() + "</Match>";

            }

            if (Pointer != null)
            {

                xml_str += "<Pointer>" + Pointer.ToString() + "</Pointer>";

            }

            if (TagMask != null)
            {

                xml_str += "<TagMask>" + TagMask.ToHexString() + "</TagMask>";

            }

            if (TagData != null)
            {

                xml_str += "<TagData>" + TagData.ToHexString() + "</TagData>";

            }

            xml_str += "</C1G2TargetTag>";
            return xml_str;
        }

        public static PARAM_C1G2TargetTag FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2TargetTag param = new PARAM_C1G2TargetTag();


            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "Match");

            param.Match = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "Pointer");

            param.Pointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "TagMask");

            param.TagMask = LLRPBitArray.FromString(val);

            val = XmlUtil.GetNodeValue(node, "TagData");

            param.TagData = LLRPBitArray.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// MB is the memory bank to use. WordPtr is the starting word address. WordCount is the number of 16-bit words to be read. Following is text reproduced from the C1G2 specification regarding WordCount=0. [If WordCount = 0, the tag backscatters the contents of the chosen memory bank starting at WordPtr and ending at the end of the bank, unless MB = 1, in which case the Tag shall backscatter the EPC memory contents starting at WordPtr and ending at the length of the EPC specified by the first 5 bits of the PC if WordPtr lies within the EPC, and shall backscatter the EPC memory contents starting at WordPtr and ending at the end of EPC memory if WordPtr lies outside the EPC.]Access Password is the password used by the Reader to transition the tag to the secure state so that it can read protected tag memory regions. For example, the Tag's Reserved memory is locked but not permalocked, meaning that the Reader must issue the access password and transition the Tag to the secured state before performing the read operation.  
    /// </summary>
    public class PARAM_C1G2Read : Parameter
    {
        public PARAM_C1G2Read()
        {
            typeID = 341;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 AccessPassword = 0;
        private Int16 AccessPassword_len = 0;

        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 WordPointer = 0;
        private Int16 WordPointer_len = 0;

        public UInt16 WordCount = 0;
        private Int16 WordCount_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (WordPointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordPointer, WordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (WordCount != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordCount, WordCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2Read FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2Read param = new PARAM_C1G2Read();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessPassword = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordPointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordCount = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2Read>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (AccessPassword != null)
            {

                xml_str += "<AccessPassword>" + AccessPassword.ToString() + "</AccessPassword>";

            }

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (WordPointer != null)
            {

                xml_str += "<WordPointer>" + WordPointer.ToString() + "</WordPointer>";

            }

            if (WordCount != null)
            {

                xml_str += "<WordCount>" + WordCount.ToString() + "</WordCount>";

            }

            xml_str += "</C1G2Read>";
            return xml_str;
        }

        public static PARAM_C1G2Read FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2Read param = new PARAM_C1G2Read();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AccessPassword");

            param.AccessPassword = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "WordPointer");

            param.WordPointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "WordCount");

            param.WordCount = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// MB is the memory bank to use. WordPtr is the starting word address. Write Data is the data to be written to the tag. Word Count is the number of words to be written. Depending on the word count, the Reader may have to execute multiple C1G2 air protocol Write commands. Access Password is the password used by the Reader to transition the tag to the secure state so that it can write to protected tag memory regions.
    /// </summary>
    public class PARAM_C1G2Write : Parameter
    {
        public PARAM_C1G2Write()
        {
            typeID = 342;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 AccessPassword = 0;
        private Int16 AccessPassword_len = 0;

        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 WordPointer = 0;
        private Int16 WordPointer_len = 0;

        public UInt16Array WriteData = new UInt16Array();
        private Int16 WriteData_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (WordPointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordPointer, WordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (WriteData != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(WriteData.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(WriteData, WriteData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2Write FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2Write param = new PARAM_C1G2Write();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessPassword = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordPointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            param.WriteData = (UInt16Array)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2Write>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (AccessPassword != null)
            {

                xml_str += "<AccessPassword>" + AccessPassword.ToString() + "</AccessPassword>";

            }

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (WordPointer != null)
            {

                xml_str += "<WordPointer>" + WordPointer.ToString() + "</WordPointer>";

            }

            if (WriteData != null)
            {

                xml_str += "<WriteData>" + WriteData.ToHexString() + "</WriteData>";

            }

            xml_str += "</C1G2Write>";
            return xml_str;
        }

        public static PARAM_C1G2Write FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2Write param = new PARAM_C1G2Write();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AccessPassword");

            param.AccessPassword = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "WordPointer");

            param.WordPointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "WriteData");

            param.WriteData = UInt16Array.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// Kill Password is the value of the kill password to be used or set.
    /// </summary>
    public class PARAM_C1G2Kill : Parameter
    {
        public PARAM_C1G2Kill()
        {
            typeID = 343;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 KillPassword = 0;
        private Int16 KillPassword_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (KillPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(KillPassword, KillPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2Kill FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2Kill param = new PARAM_C1G2Kill();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.KillPassword = (UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2Kill>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (KillPassword != null)
            {

                xml_str += "<KillPassword>" + KillPassword.ToString() + "</KillPassword>";

            }

            xml_str += "</C1G2Kill>";
            return xml_str;
        }

        public static PARAM_C1G2Kill FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2Kill param = new PARAM_C1G2Kill();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "KillPassword");

            param.KillPassword = Convert.ToUInt32(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter contains the definition of the access privilege updates (read/write/permalock) to be performed in various locations of the memory. The five data fields for which we can define access control using the lock command are: Kill Password, Access Password, EPC memory, TID memory and User memory. The access privilege updates are expressed as a list of C1G2LockPayload Parameters, one for each memory location.The Access Password provides the password to enter the secured state.  A Reader can perform a lock operation on a tag only if the tag is in the secured state. The tag enters the secured state only using the Access Password (if a non-zero value).
    /// </summary>
    public class PARAM_C1G2Lock : Parameter
    {
        public PARAM_C1G2Lock()
        {
            typeID = 344;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 AccessPassword = 0;
        private Int16 AccessPassword_len = 0;

        public PARAM_C1G2LockPayload[] C1G2LockPayload;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (C1G2LockPayload != null)
            {

                len = C1G2LockPayload.Length;
                for (int i = 0; i < len; i++)
                    C1G2LockPayload[i].ToBitArray(ref bit_array, ref cursor);

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2Lock FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2Lock param = new PARAM_C1G2Lock();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessPassword = (UInt32)obj_val;

            param_list = new ArrayList();
            PARAM_C1G2LockPayload _param_C1G2LockPayload = PARAM_C1G2LockPayload.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2LockPayload != null)
            {
                param_list.Add(_param_C1G2LockPayload);
                while ((_param_C1G2LockPayload = PARAM_C1G2LockPayload.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_C1G2LockPayload);
                if (param_list.Count > 0)
                {
                    param.C1G2LockPayload = new PARAM_C1G2LockPayload[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        param.C1G2LockPayload[i] = (PARAM_C1G2LockPayload)param_list[i];
                }
            }

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2Lock>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (AccessPassword != null)
            {

                xml_str += "<AccessPassword>" + AccessPassword.ToString() + "</AccessPassword>";

            }

            if (C1G2LockPayload != null)
            {

                len = C1G2LockPayload.Length;
                for (int i = 0; i < len; i++)
                    xml_str += C1G2LockPayload[i].ToString();

            }

            xml_str += "</C1G2Lock>";
            return xml_str;
        }

        public static PARAM_C1G2Lock FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2Lock param = new PARAM_C1G2Lock();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AccessPassword");

            param.AccessPassword = Convert.ToUInt32(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2LockPayload");
                if (xnl != null)
                {
                    if (xnl.Count != 0)
                    {
                        param.C1G2LockPayload = new PARAM_C1G2LockPayload[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            param.C1G2LockPayload[i] = PARAM_C1G2LockPayload.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return param;
        }

    }

    /// <summary>
    /// This parameter contains the definition of the access privilege updates (read/write/permalock) to be performed for a single location of the tag memory. The five data fields for which we can define access control using the lock command are: Kill Password, Access Password, EPC memory, TID memory and User memory.
    /// </summary>
    public class PARAM_C1G2LockPayload : Parameter
    {
        public PARAM_C1G2LockPayload()
        {
            typeID = 345;

        }


        public
      ENUM_C1G2LockPrivilege Privilege;
        private Int16 Privilege_len = 8;
        public
      ENUM_C1G2LockDataField DataField;
        private Int16 DataField_len = 8;
        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Privilege != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Privilege, Privilege_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (DataField != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(DataField, DataField_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2LockPayload FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2LockPayload param = new PARAM_C1G2LockPayload();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Privilege = (
        ENUM_C1G2LockPrivilege)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.DataField = (
        ENUM_C1G2LockDataField)(UInt32)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2LockPayload>";

            if (Privilege != null)
            {

                xml_str += "<Privilege>" + Privilege.ToString() + "</Privilege>";

            }

            if (DataField != null)
            {

                xml_str += "<DataField>" + DataField.ToString() + "</DataField>";

            }

            xml_str += "</C1G2LockPayload>";
            return xml_str;
        }

        public static PARAM_C1G2LockPayload FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2LockPayload param = new PARAM_C1G2LockPayload();


            val = XmlUtil.GetNodeValue(node, "Privilege");

            param.Privilege = (
      ENUM_C1G2LockPrivilege)Enum.Parse(typeof(
      ENUM_C1G2LockPrivilege), val);

            val = XmlUtil.GetNodeValue(node, "DataField");

            param.DataField = (
      ENUM_C1G2LockDataField)Enum.Parse(typeof(
      ENUM_C1G2LockDataField), val);

            return param;
        }

    }

    /// <summary>
    /// MB is the memory bank to use. WordPtr is the starting word address. Word Count is the number of 16-bit words to be read. Access Password is the password used by the Reader to transition the tag to the secure state so that it can erase protected tag memory regions.Readers that do not support C1G2BlockErase SHALL set CanSupportBlockErase to false in C1G2LLRPCapabilities. If such a Reader receives an ADD_ACCESSSPEC with an AccessSpec that contained this OpSpec parameter, the Reader SHALL return an error for that message and not add the AccessSpec.
    /// </summary>
    public class PARAM_C1G2BlockErase : Parameter
    {
        public PARAM_C1G2BlockErase()
        {
            typeID = 346;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 AccessPassword = 0;
        private Int16 AccessPassword_len = 0;

        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 WordPointer = 0;
        private Int16 WordPointer_len = 0;

        public UInt16 WordCount = 0;
        private Int16 WordCount_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (WordPointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordPointer, WordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (WordCount != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordCount, WordCount_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2BlockErase FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2BlockErase param = new PARAM_C1G2BlockErase();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessPassword = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordPointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordCount = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2BlockErase>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (AccessPassword != null)
            {

                xml_str += "<AccessPassword>" + AccessPassword.ToString() + "</AccessPassword>";

            }

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (WordPointer != null)
            {

                xml_str += "<WordPointer>" + WordPointer.ToString() + "</WordPointer>";

            }

            if (WordCount != null)
            {

                xml_str += "<WordCount>" + WordCount.ToString() + "</WordCount>";

            }

            xml_str += "</C1G2BlockErase>";
            return xml_str;
        }

        public static PARAM_C1G2BlockErase FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2BlockErase param = new PARAM_C1G2BlockErase();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AccessPassword");

            param.AccessPassword = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "WordPointer");

            param.WordPointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "WordCount");

            param.WordCount = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// MB is the memory bank to use. WordPtr is the starting word address. Word Count is the number of 16-bit words to be written. Depending on the word count, the Reader may have to execute multiple C1G2 air protocol block write commands. Write Data is the data to be written to the tag. Access Password is the password used by the Reader to transition the tag to the secure state so that it can write to protected tag memory regions.Readers that do not support C1G2BlockWrite SHALL set CanSupportBlockWrite to false in C1G2LLRPCapabilities. If such a Reader receives an ADD_ACCESSSPEC with an AccessSpec that contained this OpSpec parameter, the Reader SHALL return an error for that message and not add the AccessSpec.
    /// </summary>
    public class PARAM_C1G2BlockWrite : Parameter
    {
        public PARAM_C1G2BlockWrite()
        {
            typeID = 347;

        }


        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt32 AccessPassword = 0;
        private Int16 AccessPassword_len = 0;

        public TwoBits MB = new TwoBits(0);
        private Int16 MB_len = 0;

        private const UInt16 param_reserved_len = 6;

        public UInt16 WordPointer = 0;
        private Int16 WordPointer_len = 0;

        public UInt16Array WriteData = new UInt16Array();
        private Int16 WriteData_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (AccessPassword != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessPassword, AccessPassword_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (MB != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MB, MB_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;

            if (WordPointer != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(WordPointer, WordPointer_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (WriteData != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(WriteData.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(WriteData, WriteData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2BlockWrite FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2BlockWrite param = new PARAM_C1G2BlockWrite();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.AccessPassword = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 2;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(TwoBits), field_len);
            param.MB = (TwoBits)obj_val;

            cursor += param_reserved_len;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.WordPointer = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            param.WriteData = (UInt16Array)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2BlockWrite>";

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (AccessPassword != null)
            {

                xml_str += "<AccessPassword>" + AccessPassword.ToString() + "</AccessPassword>";

            }

            if (MB != null)
            {

                xml_str += "<MB>" + MB.ToString() + "</MB>";

            }

            if (WordPointer != null)
            {

                xml_str += "<WordPointer>" + WordPointer.ToString() + "</WordPointer>";

            }

            if (WriteData != null)
            {

                xml_str += "<WriteData>" + WriteData.ToHexString() + "</WriteData>";

            }

            xml_str += "</C1G2BlockWrite>";
            return xml_str;
        }

        public static PARAM_C1G2BlockWrite FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2BlockWrite param = new PARAM_C1G2BlockWrite();


            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "AccessPassword");

            param.AccessPassword = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MB");

            param.MB = TwoBits.FromString(val);

            val = XmlUtil.GetNodeValue(node, "WordPointer");

            param.WordPointer = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "WriteData");

            param.WriteData = UInt16Array.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// This parameter is used to determine what contents are of interest in the C1G2EPC memory bank for reporting. If enableCRC and enablePC is set to false, only the EPC is returned in the RO Report. If enablePC is set to true, the PC bits and the EPC are returned in the RO Report. If enablePC and enableCRC is set to true, the EPC, PC bits and CRC are returned in the RO Report.
    /// </summary>
    public class PARAM_C1G2EPCMemorySelector : Parameter
    {
        public PARAM_C1G2EPCMemorySelector()
        {
            typeID = 348;

        }


        public bool EnableCRC = false;
        private Int16 EnableCRC_len = 0;

        public bool EnablePCBits = false;
        private Int16 EnablePCBits_len = 0;

        private const UInt16 param_reserved_len = 6;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (EnableCRC != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnableCRC, EnableCRC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (EnablePCBits != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(EnablePCBits, EnablePCBits_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            cursor += param_reserved_len;


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2EPCMemorySelector FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2EPCMemorySelector param = new PARAM_C1G2EPCMemorySelector();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnableCRC = (bool)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            param.EnablePCBits = (bool)obj_val;

            cursor += param_reserved_len;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2EPCMemorySelector>";

            if (EnableCRC != null)
            {

                xml_str += "<EnableCRC>" + EnableCRC.ToString() + "</EnableCRC>";

            }

            if (EnablePCBits != null)
            {

                xml_str += "<EnablePCBits>" + EnablePCBits.ToString() + "</EnablePCBits>";

            }

            xml_str += "</C1G2EPCMemorySelector>";
            return xml_str;
        }

        public static PARAM_C1G2EPCMemorySelector FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2EPCMemorySelector param = new PARAM_C1G2EPCMemorySelector();


            val = XmlUtil.GetNodeValue(node, "EnableCRC");

            param.EnableCRC = Convert.ToBoolean(val);

            val = XmlUtil.GetNodeValue(node, "EnablePCBits");

            param.EnablePCBits = Convert.ToBoolean(val);

            return param;
        }

    }

    /// <summary>
    /// Protocol control bits from the UHF Gen2 Air Interface protocol
    /// </summary>
    public class PARAM_C1G2_PC : Parameter
    {
        public PARAM_C1G2_PC()
        {
            typeID = 12;
            tvCoding = true;
        }


        public UInt16 PC_Bits = 0;
        private Int16 PC_Bits_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (PC_Bits != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(PC_Bits, PC_Bits_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2_PC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2_PC param = new PARAM_C1G2_PC();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.PC_Bits = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2_PC>";

            if (PC_Bits != null)
            {

                xml_str += "<PC_Bits>" + PC_Bits.ToString() + "</PC_Bits>";

            }

            xml_str += "</C1G2_PC>";
            return xml_str;
        }

        public static PARAM_C1G2_PC FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2_PC param = new PARAM_C1G2_PC();


            val = XmlUtil.GetNodeValue(node, "PC_Bits");

            param.PC_Bits = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// CRC generated by the tag from the UHF Gen2 Air Interface Protocol
    /// </summary>
    public class PARAM_C1G2_CRC : Parameter
    {
        public PARAM_C1G2_CRC()
        {
            typeID = 11;
            tvCoding = true;
        }


        public UInt16 CRC = 0;
        private Int16 CRC_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (CRC != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(CRC, CRC_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2_CRC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2_CRC param = new PARAM_C1G2_CRC();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.CRC = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2_CRC>";

            if (CRC != null)
            {

                xml_str += "<CRC>" + CRC.ToString() + "</CRC>";

            }

            xml_str += "</C1G2_CRC>";
            return xml_str;
        }

        public static PARAM_C1G2_CRC FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2_CRC param = new PARAM_C1G2_CRC();


            val = XmlUtil.GetNodeValue(node, "CRC");

            param.CRC = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// 
    /// </summary>
    public class PARAM_C1G2SingulationDetails : Parameter
    {
        public PARAM_C1G2SingulationDetails()
        {
            typeID = 18;
            tvCoding = true;
        }


        public UInt16 NumCollisionSlots = 0;
        private Int16 NumCollisionSlots_len = 0;

        public UInt16 NumEmptySlots = 0;
        private Int16 NumEmptySlots_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (NumCollisionSlots != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumCollisionSlots, NumCollisionSlots_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NumEmptySlots != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumEmptySlots, NumEmptySlots_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2SingulationDetails FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2SingulationDetails param = new PARAM_C1G2SingulationDetails();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumCollisionSlots = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumEmptySlots = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2SingulationDetails>";

            if (NumCollisionSlots != null)
            {

                xml_str += "<NumCollisionSlots>" + NumCollisionSlots.ToString() + "</NumCollisionSlots>";

            }

            if (NumEmptySlots != null)
            {

                xml_str += "<NumEmptySlots>" + NumEmptySlots.ToString() + "</NumEmptySlots>";

            }

            xml_str += "</C1G2SingulationDetails>";
            return xml_str;
        }

        public static PARAM_C1G2SingulationDetails FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2SingulationDetails param = new PARAM_C1G2SingulationDetails();


            val = XmlUtil.GetNodeValue(node, "NumCollisionSlots");

            param.NumCollisionSlots = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NumEmptySlots");

            param.NumEmptySlots = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Contains the results from a read operation.
    /// </summary>
    public class PARAM_C1G2ReadOpSpecResult : Parameter
    {
        public PARAM_C1G2ReadOpSpecResult()
        {
            typeID = 349;

        }


        public
      ENUM_C1G2ReadResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt16Array ReadData = new UInt16Array();
        private Int16 ReadData_len;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (ReadData != null)
            {

                try
                {
                    int temp_cursor = cursor;

                    BitArray tempBitArr = Util.ConvertIntToBitArray((UInt32)(ReadData.Count), 16);

                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += 16;

                    tempBitArr = Util.ConvertObjToBitArray(ReadData, ReadData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch
                {
                }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2ReadOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2ReadOpSpecResult param = new PARAM_C1G2ReadOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2ReadResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = Util.DetermineFieldLength(ref bit_array, ref cursor);

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16Array), field_len);
            param.ReadData = (UInt16Array)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2ReadOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (ReadData != null)
            {

                xml_str += "<ReadData>" + ReadData.ToHexString() + "</ReadData>";

            }

            xml_str += "</C1G2ReadOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2ReadOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2ReadOpSpecResult param = new PARAM_C1G2ReadOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
      ENUM_C1G2ReadResultType)Enum.Parse(typeof(
      ENUM_C1G2ReadResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "ReadData");

            param.ReadData = UInt16Array.FromString(val);

            return param;
        }

    }

    /// <summary>
    /// Contains the result from a write operation.If the number of words written is not equal to the length of the data pattern to write, the Result  SHALL be non-zero.
    /// </summary>
    public class PARAM_C1G2WriteOpSpecResult : Parameter
    {
        public PARAM_C1G2WriteOpSpecResult()
        {
            typeID = 350;

        }


        public
      ENUM_C1G2WriteResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt16 NumWordsWritten = 0;
        private Int16 NumWordsWritten_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NumWordsWritten != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumWordsWritten, NumWordsWritten_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2WriteOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2WriteOpSpecResult param = new PARAM_C1G2WriteOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2WriteResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumWordsWritten = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2WriteOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (NumWordsWritten != null)
            {

                xml_str += "<NumWordsWritten>" + NumWordsWritten.ToString() + "</NumWordsWritten>";

            }

            xml_str += "</C1G2WriteOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2WriteOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2WriteOpSpecResult param = new PARAM_C1G2WriteOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
      ENUM_C1G2WriteResultType)Enum.Parse(typeof(
      ENUM_C1G2WriteResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NumWordsWritten");

            param.NumWordsWritten = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// 
    /// </summary>
    public class PARAM_C1G2KillOpSpecResult : Parameter
    {
        public PARAM_C1G2KillOpSpecResult()
        {
            typeID = 351;

        }


        public
      ENUM_C1G2KillResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2KillOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2KillOpSpecResult param = new PARAM_C1G2KillOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2KillResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2KillOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            xml_str += "</C1G2KillOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2KillOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2KillOpSpecResult param = new PARAM_C1G2KillOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
      ENUM_C1G2KillResultType)Enum.Parse(typeof(
      ENUM_C1G2KillResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Contains the result of a lock operation.
    /// </summary>
    public class PARAM_C1G2LockOpSpecResult : Parameter
    {
        public PARAM_C1G2LockOpSpecResult()
        {
            typeID = 352;

        }


        public
      ENUM_C1G2LockResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2LockOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2LockOpSpecResult param = new PARAM_C1G2LockOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2LockResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2LockOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            xml_str += "</C1G2LockOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2LockOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2LockOpSpecResult param = new PARAM_C1G2LockOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
      ENUM_C1G2LockResultType)Enum.Parse(typeof(
      ENUM_C1G2LockResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Contains the result of a block erase operation.Readers that do not support C1G2 Block Erase SHALL set CanSupportBlockErase to false in C1G2LLRPCapabilities. If such a Reader receives an ADD_ACCESSSPEC with an AccessSpec that contains this OpSpec parameter, the Reader SHALL return an error for that message and not add the AccessSpec.
    /// </summary>
    public class PARAM_C1G2BlockEraseOpSpecResult : Parameter
    {
        public PARAM_C1G2BlockEraseOpSpecResult()
        {
            typeID = 353;

        }


        public
      ENUM_C1G2BlockEraseResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2BlockEraseOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2BlockEraseOpSpecResult param = new PARAM_C1G2BlockEraseOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2BlockEraseResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2BlockEraseOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            xml_str += "</C1G2BlockEraseOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2BlockEraseOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2BlockEraseOpSpecResult param = new PARAM_C1G2BlockEraseOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
      ENUM_C1G2BlockEraseResultType)Enum.Parse(typeof(
      ENUM_C1G2BlockEraseResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            return param;
        }

    }

    /// <summary>
    /// Contains the result of a block write operationReaders that do not support C1G2 Block Write SHALL set CanSupportBlockWrite to false in C1G2LLRPCapabilities. If such a Reader receives an ADD_ACCESSSPEC with an AccessSpec that contains this OpSpec parameter, the Reader SHALL return an error for that message and not add the AccessSpec.
    /// </summary>
    public class PARAM_C1G2BlockWriteOpSpecResult : Parameter
    {
        public PARAM_C1G2BlockWriteOpSpecResult()
        {
            typeID = 354;

        }


        public
      ENUM_C1G2BlockWriteResultType Result;
        private Int16 Result_len = 8;
        public UInt16 OpSpecID = 0;
        private Int16 OpSpecID_len = 0;

        public UInt16 NumWordsWritten = 0;
        private Int16 NumWordsWritten_len = 0;

        public override void ToBitArray(ref bool[] bit_array, ref int cursor)
        {
            int len;
            int cursor_old = cursor;
            BitArray bArr;

            if (tvCoding)
            {
                bit_array[cursor] = true;
                cursor++;

                bArr = Util.ConvertIntToBitArray(typeID, 7);
                bArr.CopyTo(bit_array, cursor);

                cursor += 7;
            }
            else
            {
                cursor += 6;
                bArr = Util.ConvertIntToBitArray(typeID, 10);
                bArr.CopyTo(bit_array, cursor);

                cursor += 10;
                cursor += 16;     //Omit the parameter length, will be added at the end.
            }


            if (Result != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Result, Result_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (OpSpecID != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(OpSpecID, OpSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }

            if (NumWordsWritten != null)
            {

                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(NumWordsWritten, NumWordsWritten_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { }

            }


            if (!tvCoding)
            {
                UInt32 param_len = (UInt32)(cursor - cursor_old) / 8;
                bArr = Util.ConvertIntToBitArray(param_len, 16);
                bArr.CopyTo(bit_array, cursor_old + 16);
            }
        }

        public new static PARAM_C1G2BlockWriteOpSpecResult FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor >= length) return null;

            int field_len = 0;
            object obj_val;
            int parameter_len = 0;
            ArrayList param_list = new ArrayList();

            PARAM_C1G2BlockWriteOpSpecResult param = new PARAM_C1G2BlockWriteOpSpecResult();

            int param_type = 0;

            if (bit_array[cursor]) param.tvCoding = true;
            if (param.tvCoding)
            {
                cursor++;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 7);

                if (param_type != param.TypeID)
                {
                    cursor -= 8;
                    return null;
                }
            }
            else
            {
                cursor += 6;
                param_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

                if (param_type != param.TypeID)
                {
                    cursor -= 16;
                    return null;
                }
                param.length = (UInt16)(int)Util.DetermineFieldLength(ref bit_array, ref cursor);
            }


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            param.Result = (
        ENUM_C1G2BlockWriteResultType)(UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.OpSpecID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            param.NumWordsWritten = (UInt16)obj_val;

            return param;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<C1G2BlockWriteOpSpecResult>";

            if (Result != null)
            {

                xml_str += "<Result>" + Result.ToString() + "</Result>";

            }

            if (OpSpecID != null)
            {

                xml_str += "<OpSpecID>" + OpSpecID.ToString() + "</OpSpecID>";

            }

            if (NumWordsWritten != null)
            {

                xml_str += "<NumWordsWritten>" + NumWordsWritten.ToString() + "</NumWordsWritten>";

            }

            xml_str += "</C1G2BlockWriteOpSpecResult>";
            return xml_str;
        }

        public static PARAM_C1G2BlockWriteOpSpecResult FromXmlNode(XmlNode node)
        {
            string val;
            PARAM_C1G2BlockWriteOpSpecResult param = new PARAM_C1G2BlockWriteOpSpecResult();


            val = XmlUtil.GetNodeValue(node, "Result");

            param.Result = (
                ENUM_C1G2BlockWriteResultType)Enum.Parse(typeof(
                ENUM_C1G2BlockWriteResultType), val);

            val = XmlUtil.GetNodeValue(node, "OpSpecID");

            param.OpSpecID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "NumWordsWritten");

            param.NumWordsWritten = Convert.ToUInt16(val);

            return param;
        }

    }

}
