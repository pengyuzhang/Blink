<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
	xmlns:llrp="http://www.llrp.org/ltk/schema/core/encoding/binary/1.0">
  <xsl:output omit-xml-declaration='yes' method='text' indent='yes'/>
  <xsl:template match="/llrp:llrpdef">
    /*
    ***************************************************************************
    *  Copyright 2008 Impinj, Inc.
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    *
    ***************************************************************************
    */

    /*
    ***************************************************************************
    *
    *  This code is generated by Impinj LLRP .Net generator. Modification is
    *  not recommended.
    *
    ***************************************************************************
    */

    /*
    ***************************************************************************
    * File Name:       LLRPClient.cs
    *
    * Version:         1.0
    * Author:          Impinj
    * Organization:    Impinj
    * Date:            Jan. 18, 2008
    *
    * Description:     This file contains implementation of LLRP client. LLRP
    *                 client is used to build LLRP based application
    ***************************************************************************
    */


    using System;
    using System.Collections.Generic;
    using System.Text;
    using System.Net;
    using System.Net.Sockets;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Collections;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Data;

    using LLRP.DataType;

    namespace LLRP
    {

    //delegates for sending asyn. messages
    public delegate void delegateReaderEventNotification(MSG_READER_EVENT_NOTIFICATION msg);
    public delegate void delegateRoAccessReport(MSG_RO_ACCESS_REPORT msg);
    public delegate void delegateKeepAlive(MSG_KEEPALIVE msg);
    
    //Delegates for sending encapsulated asyn. messages
    public delegate void delegateEncapReaderEventNotification(ENCAPED_READER_EVENT_NOTIFICATION msg);
    public delegate void delegateEncapRoAccessReport(ENCAPED_RO_ACCESS_REPORT msg);
    public delegate void delegateEncapKeepAlive(ENCAPED_KEEP_ALIVE msg);

    [Serializable]
    public class ClientManualResetEvent
    {
    public ManualResetEvent evt;
    public byte[] data;
    public UInt32 msg_id;

    public ClientManualResetEvent(bool status)
    {
    evt = new ManualResetEvent(status);
    }
    }

    //add comments
    public class LLRPClient : IDisposable
    {
    #region Network Parameters
    private CommunicationInterface cI;
    private int LLRP_TCP_PORT = 5084;
    private int MSG_TIME_OUT = 10000;
    #endregion

    #region Private Members
    private ManualResetEvent conn_evt;
    private ENUM_ConnectionAttemptStatusType conn_status_type;
    private string reader_name;
    #endregion


    public event delegateReaderEventNotification OnReaderEventNotification;
    public event delegateRoAccessReport OnRoAccessReportReceived;
    public event delegateKeepAlive OnKeepAlive;

    public event delegateEncapReaderEventNotification OnEncapedReaderEventNotification;
    public event delegateEncapRoAccessReport OnEncapedRoAccessReportReceived;
    public event delegateEncapKeepAlive OnEncapedKeepAlive;

    protected void TriggerReaderEventNotification(MSG_READER_EVENT_NOTIFICATION msg)
    {
    try {
    if (OnReaderEventNotification != null) OnReaderEventNotification(msg);
    if (OnEncapedReaderEventNotification != null)
    {
    ENCAPED_READER_EVENT_NOTIFICATION ntf = new ENCAPED_READER_EVENT_NOTIFICATION();
    ntf.reader = reader_name;
    ntf.ntf = msg;
    }
    }
    catch { }
    }

    protected void TriggerRoAccessReport(MSG_RO_ACCESS_REPORT msg)
    {
    try
    {
    if (OnRoAccessReportReceived != null) OnRoAccessReportReceived(msg);
    if (OnEncapedRoAccessReportReceived != null)
    {
    ENCAPED_RO_ACCESS_REPORT report = new ENCAPED_RO_ACCESS_REPORT();
    report.reader = reader_name;
    report.report = msg;

    OnEncapedRoAccessReportReceived(report);
    }
    }
    catch { }
    }

    protected void TriggerKeepAlive(MSG_KEEPALIVE msg)
    {
    try {
    if (OnKeepAlive != null) OnKeepAlive(msg);
    if (OnEncapedKeepAlive != null)
    {
    ENCAPED_KEEP_ALIVE keepalive = new ENCAPED_KEEP_ALIVE();
    keepalive.reader = reader_name;
    keepalive.keep_alive = msg;

    OnEncapedKeepAlive(keepalive);
    }
    }
    catch { }
    }

    #region Properties
    public string ReaderName
    {
    get{return reader_name;}
    }
    #endregion

    #region Assistance Functions
    public void SetMessageTimeOut(int time_out)
    {
    this.MSG_TIME_OUT = time_out;
    }

    public int GetMessageTimeOut()
    {
    return MSG_TIME_OUT;
    }

    #endregion

    #region Private Events
    <xsl:for-each select="llrp:messageDefinition">ClientManualResetEvent _event_<xsl:value-of select="@name"/>;
    </xsl:for-each>

    #endregion

    #region Methods
    public LLRPClient()
    {
    cI = new TCPIPClient();
    }

    public bool Open(string llrp_reader_name, int timeout, out ENUM_ConnectionAttemptStatusType status)
    {
    reader_name = llrp_reader_name;
    
    status = ENUM_ConnectionAttemptStatusType.Failed_Reason_Other_Than_A_Connection_Already_Exists;
    cI.OnMessageReceived += new delegateMessageReceived(ProcesssMessage);

    try{ cI.Open(llrp_reader_name, LLRP_TCP_PORT);}
    catch{cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage);return false;}


    conn_evt = new ManualResetEvent(false);
    if (conn_evt.WaitOne(timeout, false))
    {
    status = conn_status_type;
    if(status== ENUM_ConnectionAttemptStatusType.Success)return true;
    }

    reader_name = llrp_reader_name;

    try
    {
    cI.Close();
    cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage);
    }
    catch
    {
    }
    return false;
    }

    public bool Close()
    {
    try
    {
    MSG_CLOSE_CONNECTION msg = new MSG_CLOSE_CONNECTION();
    MSG_ERROR_MESSAGE msg_err;
    MSG_CLOSE_CONNECTION_RESPONSE rsp = this.CLOSE_CONNECTION(msg, out msg_err, MSG_TIME_OUT);

    if (rsp == null || rsp.LLRPStatus.StatusCode != ENUM_StatusCode.M_Success) return false;

    cI.Close();
    cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage);

    return true;
    }
    catch
    {
    return false;
    }
    }

    public void Dispose()
    {
    this.Close();
    }

    private void ProcesssMessage(Int16 ver, Int16 msg_type, Int32 msg_id, byte[] data)
    {
    BitArray bArr;
    int cursor = 0;
    int length;

    switch((ENUM_LLRP_MSG_TYPE)msg_type)
    {
    <xsl:for-each select="llrp:messageDefinition">
      <xsl:choose>
        <xsl:when test="@name ='KEEPALIVE'">
          case ENUM_LLRP_MSG_TYPE.KEEPALIVE:
          try
          {
          bArr = Util.ConvertByteArrayToBitArray(data);
          length = bArr.Count;
          MSG_KEEPALIVE msg = MSG_KEEPALIVE.FromBitArray(ref bArr, ref cursor, length);
          delegateKeepAlive rMsg = new delegateKeepAlive(TriggerKeepAlive);
          rMsg.BeginInvoke(msg, null, null);
          }
          catch
          {
          }
          break;
        </xsl:when>
        <xsl:when test="@name = 'READER_EVENT_NOTIFICATION'">
          case ENUM_LLRP_MSG_TYPE.READER_EVENT_NOTIFICATION:
          try
          {
          bArr = Util.ConvertByteArrayToBitArray(data);
          length = bArr.Count;
          MSG_READER_EVENT_NOTIFICATION ntf = MSG_READER_EVENT_NOTIFICATION.FromBitArray(ref bArr, ref cursor, length);
          if (conn_evt != null <xsl:text disable-output-escaping="yes">&amp;&amp;</xsl:text> ntf.ReaderEventNotificationData.ConnectionAttemptEvent != null)
          {
          conn_status_type = ntf.ReaderEventNotificationData.ConnectionAttemptEvent.Status;
          conn_evt.Set();
          }
          else
          {
          delegateReaderEventNotification rEvent = new delegateReaderEventNotification(TriggerReaderEventNotification);
          rEvent.BeginInvoke(ntf, null, null);
          }
          }
          catch
          {
          }
          break;
        </xsl:when>
        <xsl:when test="@name = 'RO_ACCESS_REPORT'">
          case ENUM_LLRP_MSG_TYPE.RO_ACCESS_REPORT:
          try
          {
          bArr = Util.ConvertByteArrayToBitArray(data);
          length = bArr.Count;
          MSG_RO_ACCESS_REPORT rpt = MSG_RO_ACCESS_REPORT.FromBitArray(ref bArr, ref cursor, length);
          delegateRoAccessReport roaccess = new delegateRoAccessReport(TriggerRoAccessReport);
          roaccess.BeginInvoke(rpt, null, null);
          }
          catch
          {
          }
          break;
        </xsl:when>        
        <xsl:otherwise>
       case ENUM_LLRP_MSG_TYPE.<xsl:value-of select="@name"/>:
      _event_<xsl:value-of select="@name"/>.data = new byte[data.Length];
      if(data.Length<xsl:text disable-output-escaping="yes">&gt;</xsl:text>0)Array.Copy(data, _event_<xsl:value-of select="@name"/>.data, data.Length);
      _event_<xsl:value-of select="@name"/>.evt.Set();
      break;         
        </xsl:otherwise>
      </xsl:choose>

    </xsl:for-each>
    default:
    break;
    }
    }

    #endregion

    <xsl:for-each select="llrp:messageDefinition">
      <xsl:variable name="msgName">
        <xsl:value-of select="@name"/>
      </xsl:variable>
      <xsl:variable name="shorten_msgName">
        <xsl:if test="contains($msgName, '_RESPONSE')">
          <xsl:value-of select="substring-before($msgName, '_RESPONSE')"/>
        </xsl:if>
        <xsl:if test="contains($msgName, '_ACK')">
          <xsl:value-of select="substring-before($msgName, '_ACK')"/>
        </xsl:if>
      </xsl:variable>
      <xsl:if test ="contains($msgName, '_RESPONSE')">
        public MSG_<xsl:value-of select="@name"/><xsl:text> </xsl:text> <xsl:value-of select="$shorten_msgName"/>(MSG_<xsl:value-of select="$shorten_msgName"/> msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
         msg_err = null;
        //Add your code here
        _event_<xsl:value-of select="@name"/> = new ClientManualResetEvent(false);
        _event_<xsl:value-of select="@name"/>.msg_id = msg.MSG_ID;
        _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

        WaitHandle[] waitHandles = new WaitHandle[] {_event_<xsl:value-of select="@name"/>.evt, _event_ERROR_MESSAGE.evt};

        bool[] bit_array = msg.ToBitArray();
        byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

        cI.Send(data);

        int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

        int cursor = 0;
        int length;
        BitArray bArr;

        try
        {
        switch(wait_result)
        {
        case 0:
        bArr = Util.ConvertByteArrayToBitArray(_event_<xsl:value-of select="@name"/>.data);
        length = bArr.Count;
        MSG_<xsl:value-of select="@name"/> msg_rsp = MSG_<xsl:value-of select="@name"/>.FromBitArray(ref bArr, ref cursor, length);
        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
        else
          return msg_rsp;
        case 1:
        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
        length = bArr.Count;
        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
        return null;
        default:
        return null;
        }
        }
        catch
        {
        return null;
        }
        }
      </xsl:if>
      <xsl:if test="contains($msgName, 'ENABLE_EVENTS_AND_REPORTS')">
        public void <xsl:value-of select="$msgName"/>(MSG_<xsl:value-of select="$msgName"/> msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
        msg_err = null;
        _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

        bool[] bit_array = msg.ToBitArray();
        byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

        cI.Send(data);

        bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
        if(wait_result)
        {
        BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
        int cursor = 0;
        int length = bArr.Count;
        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
        return;
        }
        }
      </xsl:if>
      <xsl:if test="contains($msgName, 'KEEPALIVE_ACK')">
        public void <xsl:value-of select="$msgName"/>(MSG_<xsl:value-of select="$msgName"/> msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
        msg_err = null;
        _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

        bool[] bit_array = msg.ToBitArray();
        byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

        cI.Send(data);

        bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
        if(wait_result)
        {
        BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
        int cursor = 0;
        int length = bArr.Count;
        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
        return;
        }
        }
      </xsl:if>
      <xsl:if test="@name='GET_REPORT'">
        public void <xsl:value-of select="$msgName"/>(MSG_<xsl:value-of select="$msgName"/> msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
        msg_err = null;
        _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

        bool[] bit_array = msg.ToBitArray();
        byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

        cI.Send(data);

        bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
        if(wait_result)
        {
        BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
        int cursor = 0;
        int length = bArr.Count;
        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
        return;
        }
        }
      </xsl:if>
      <xsl:if test="contains($msgName, 'CUSTOM_MESSAGE')">
        public MSG_CUSTOM_MESSAGE<xsl:text>  </xsl:text><xsl:value-of select="$msgName"/>(MSG_<xsl:value-of select="$msgName"/> msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
        msg_err = null;
        //Add your code here
        _event_<xsl:value-of select="@name"/> = new ClientManualResetEvent(false);
        _event_<xsl:value-of select="@name"/>.msg_id = msg.MSG_ID;
        _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

        WaitHandle[] waitHandles = new WaitHandle[] {_event_<xsl:value-of select="@name"/>.evt, _event_ERROR_MESSAGE.evt};

        bool[] bit_array = msg.ToBitArray();
        byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

        cI.Send(data);

        int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

        int cursor = 0;
        int length;
        BitArray bArr;

        try
        {
        switch(wait_result)
        {
        case 0:
        bArr = Util.ConvertByteArrayToBitArray(_event_<xsl:value-of select="@name"/>.data);
        length = bArr.Count;
        MSG_<xsl:value-of select="@name"/> msg_rsp = MSG_<xsl:value-of select="@name"/>.FromBitArray(ref bArr, ref cursor, length);
        return msg_rsp;
        case 1:
        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
        length = bArr.Count;
        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
        return null;
        default:
        return null;
        }
        }
        catch
        {
        return null;
        }
        }

      </xsl:if>

    </xsl:for-each>
    }
    }
  </xsl:template>
</xsl:stylesheet>