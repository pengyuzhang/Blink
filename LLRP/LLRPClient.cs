
/*
***************************************************************************
*  Copyright 2008 Impinj, Inc.
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
***************************************************************************
*/

/*
***************************************************************************
*
*  This code is generated by Impinj LLRP .Net generator. Modification is
*  not recommended.
*
***************************************************************************
*/

/*
***************************************************************************
* File Name:       LLRPClient.cs
*
* Version:         1.0
* Author:          Impinj
* Organization:    Impinj
* Date:            Jan. 18, 2008
*
* Description:     This file contains implementation of LLRP client. LLRP
*                 client is used to build LLRP based application
***************************************************************************
*/


using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Runtime.Remoting;
using System.Collections;
using System.Xml;
using System.Xml.Serialization;
using System.Data;

using LLRP.DataType;

namespace LLRP
{

    //delegates for sending asyn. messages
    public delegate void delegateReaderEventNotification(MSG_READER_EVENT_NOTIFICATION msg);
    public delegate void delegateRoAccessReport(MSG_RO_ACCESS_REPORT msg);
    public delegate void delegateKeepAlive(MSG_KEEPALIVE msg);

    //Delegates for sending encapsulated asyn. messages
    public delegate void delegateEncapReaderEventNotification(ENCAPED_READER_EVENT_NOTIFICATION msg);
    public delegate void delegateEncapRoAccessReport(ENCAPED_RO_ACCESS_REPORT msg);
    public delegate void delegateEncapKeepAlive(ENCAPED_KEEP_ALIVE msg);

    [Serializable]
    public class ClientManualResetEvent
    {
        public ManualResetEvent evt;
        public byte[] data;
        public UInt32 msg_id;

        public ClientManualResetEvent(bool status)
        {
            evt = new ManualResetEvent(status);
        }
    }

    //add comments
    public class LLRPClient : IDisposable
    {
        #region Network Parameters
        private CommunicationInterface cI;
        private int LLRP_TCP_PORT = 5084;
        private int MSG_TIME_OUT = 10000;
        #endregion

        #region Private Members
        private ManualResetEvent conn_evt;
        private ENUM_ConnectionAttemptStatusType conn_status_type;
        private string reader_name;
        #endregion


        public event delegateReaderEventNotification OnReaderEventNotification;
        public event delegateRoAccessReport OnRoAccessReportReceived;
        public event delegateKeepAlive OnKeepAlive;

        public event delegateEncapReaderEventNotification OnEncapedReaderEventNotification;
        public event delegateEncapRoAccessReport OnEncapedRoAccessReportReceived;
        public event delegateEncapKeepAlive OnEncapedKeepAlive;

        protected void TriggerReaderEventNotification(MSG_READER_EVENT_NOTIFICATION msg)
        {
            try
            {
                if (OnReaderEventNotification != null) OnReaderEventNotification(msg);
                if (OnEncapedReaderEventNotification != null)
                {
                    ENCAPED_READER_EVENT_NOTIFICATION ntf = new ENCAPED_READER_EVENT_NOTIFICATION();
                    ntf.reader = reader_name;
                    ntf.ntf = msg;
                }
            }
            catch { }
        }

        protected void TriggerRoAccessReport(MSG_RO_ACCESS_REPORT msg)
        {
            try
            {
                if (OnRoAccessReportReceived != null) OnRoAccessReportReceived(msg);
                if (OnEncapedRoAccessReportReceived != null)
                {
                    ENCAPED_RO_ACCESS_REPORT report = new ENCAPED_RO_ACCESS_REPORT();
                    report.reader = reader_name;
                    report.report = msg;

                    OnEncapedRoAccessReportReceived(report);
                }
            }
            catch { }
        }

        protected void TriggerKeepAlive(MSG_KEEPALIVE msg)
        {
            try
            {
                if (OnKeepAlive != null) OnKeepAlive(msg);
                if (OnEncapedKeepAlive != null)
                {
                    ENCAPED_KEEP_ALIVE keepalive = new ENCAPED_KEEP_ALIVE();
                    keepalive.reader = reader_name;
                    keepalive.keep_alive = msg;

                    OnEncapedKeepAlive(keepalive);
                }
            }
            catch { }
        }

        #region Properties
        public string ReaderName
        {
            get { return reader_name; }
        }
        #endregion

        #region Assistance Functions
        public void SetMessageTimeOut(int time_out)
        {
            this.MSG_TIME_OUT = time_out;
        }

        public int GetMessageTimeOut()
        {
            return MSG_TIME_OUT;
        }

        #endregion

        #region Private Events
        ClientManualResetEvent _event_CUSTOM_MESSAGE;
        ClientManualResetEvent _event_GET_READER_CAPABILITIES;
        ClientManualResetEvent _event_GET_READER_CAPABILITIES_RESPONSE;
        ClientManualResetEvent _event_ADD_ROSPEC;
        ClientManualResetEvent _event_ADD_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_DELETE_ROSPEC;
        ClientManualResetEvent _event_DELETE_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_START_ROSPEC;
        ClientManualResetEvent _event_START_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_STOP_ROSPEC;
        ClientManualResetEvent _event_STOP_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_ENABLE_ROSPEC;
        ClientManualResetEvent _event_ENABLE_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_DISABLE_ROSPEC;
        ClientManualResetEvent _event_DISABLE_ROSPEC_RESPONSE;
        ClientManualResetEvent _event_GET_ROSPECS;
        ClientManualResetEvent _event_GET_ROSPECS_RESPONSE;
        ClientManualResetEvent _event_ADD_ACCESSSPEC;
        ClientManualResetEvent _event_ADD_ACCESSSPEC_RESPONSE;
        ClientManualResetEvent _event_DELETE_ACCESSSPEC;
        ClientManualResetEvent _event_DELETE_ACCESSSPEC_RESPONSE;
        ClientManualResetEvent _event_ENABLE_ACCESSSPEC;
        ClientManualResetEvent _event_ENABLE_ACCESSSPEC_RESPONSE;
        ClientManualResetEvent _event_DISABLE_ACCESSSPEC;
        ClientManualResetEvent _event_DISABLE_ACCESSSPEC_RESPONSE;
        ClientManualResetEvent _event_GET_ACCESSSPECS;
        ClientManualResetEvent _event_GET_ACCESSSPECS_RESPONSE;
        ClientManualResetEvent _event_GET_READER_CONFIG;
        ClientManualResetEvent _event_GET_READER_CONFIG_RESPONSE;
        ClientManualResetEvent _event_SET_READER_CONFIG;
        ClientManualResetEvent _event_SET_READER_CONFIG_RESPONSE;
        ClientManualResetEvent _event_CLOSE_CONNECTION;
        ClientManualResetEvent _event_CLOSE_CONNECTION_RESPONSE;
        ClientManualResetEvent _event_GET_REPORT;
        ClientManualResetEvent _event_RO_ACCESS_REPORT;
        ClientManualResetEvent _event_KEEPALIVE;
        ClientManualResetEvent _event_KEEPALIVE_ACK;
        ClientManualResetEvent _event_READER_EVENT_NOTIFICATION;
        ClientManualResetEvent _event_ENABLE_EVENTS_AND_REPORTS;
        ClientManualResetEvent _event_ERROR_MESSAGE;


        #endregion

        #region Methods
        public LLRPClient()
        {
            cI = new TCPIPClient();
        }

        public bool Open(string llrp_reader_name, int timeout, out ENUM_ConnectionAttemptStatusType status)
        {
            reader_name = llrp_reader_name;

            status = ENUM_ConnectionAttemptStatusType.Failed_Reason_Other_Than_A_Connection_Already_Exists;
            cI.OnMessageReceived += new delegateMessageReceived(ProcesssMessage);

            try { cI.Open(llrp_reader_name, LLRP_TCP_PORT); }
            catch { cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage); return false; }


            conn_evt = new ManualResetEvent(false);
            if (conn_evt.WaitOne(timeout, false))
            {
                status = conn_status_type;
                if (status == ENUM_ConnectionAttemptStatusType.Success) return true;
            }

            reader_name = llrp_reader_name;

            try
            {
                cI.Close();
                cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage);
            }
            catch
            {
            }
            return false;
        }

        public bool Close()
        {
            try
            {
                MSG_CLOSE_CONNECTION msg = new MSG_CLOSE_CONNECTION();
                MSG_ERROR_MESSAGE msg_err;
                MSG_CLOSE_CONNECTION_RESPONSE rsp = this.CLOSE_CONNECTION(msg, out msg_err, MSG_TIME_OUT);

                if (rsp == null || rsp.LLRPStatus.StatusCode != ENUM_StatusCode.M_Success) return false;

                cI.Close();
                cI.OnMessageReceived -= new delegateMessageReceived(ProcesssMessage);

                return true;
            }
            catch
            {
                return false;
            }
        }

        public void Dispose()
        {
            this.Close();
        }

        private void ProcesssMessage(Int16 ver, Int16 msg_type, Int32 msg_id, byte[] data)
        {
            BitArray bArr;
            int cursor = 0;
            int length;

            switch ((ENUM_LLRP_MSG_TYPE)msg_type)
            {

                case ENUM_LLRP_MSG_TYPE.CUSTOM_MESSAGE:
                    _event_CUSTOM_MESSAGE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_CUSTOM_MESSAGE.data, data.Length);
                    _event_CUSTOM_MESSAGE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_READER_CAPABILITIES:
                    _event_GET_READER_CAPABILITIES.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_READER_CAPABILITIES.data, data.Length);
                    _event_GET_READER_CAPABILITIES.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_READER_CAPABILITIES_RESPONSE:
                    _event_GET_READER_CAPABILITIES_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_READER_CAPABILITIES_RESPONSE.data, data.Length);
                    _event_GET_READER_CAPABILITIES_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ADD_ROSPEC:
                    _event_ADD_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ADD_ROSPEC.data, data.Length);
                    _event_ADD_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ADD_ROSPEC_RESPONSE:
                    _event_ADD_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ADD_ROSPEC_RESPONSE.data, data.Length);
                    _event_ADD_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DELETE_ROSPEC:
                    _event_DELETE_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DELETE_ROSPEC.data, data.Length);
                    _event_DELETE_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DELETE_ROSPEC_RESPONSE:
                    _event_DELETE_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DELETE_ROSPEC_RESPONSE.data, data.Length);
                    _event_DELETE_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.START_ROSPEC:
                    _event_START_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_START_ROSPEC.data, data.Length);
                    _event_START_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.START_ROSPEC_RESPONSE:
                    _event_START_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_START_ROSPEC_RESPONSE.data, data.Length);
                    _event_START_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.STOP_ROSPEC:
                    _event_STOP_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_STOP_ROSPEC.data, data.Length);
                    _event_STOP_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.STOP_ROSPEC_RESPONSE:
                    _event_STOP_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_STOP_ROSPEC_RESPONSE.data, data.Length);
                    _event_STOP_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ENABLE_ROSPEC:
                    _event_ENABLE_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ENABLE_ROSPEC.data, data.Length);
                    _event_ENABLE_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ENABLE_ROSPEC_RESPONSE:
                    _event_ENABLE_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ENABLE_ROSPEC_RESPONSE.data, data.Length);
                    _event_ENABLE_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DISABLE_ROSPEC:
                    _event_DISABLE_ROSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DISABLE_ROSPEC.data, data.Length);
                    _event_DISABLE_ROSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DISABLE_ROSPEC_RESPONSE:
                    _event_DISABLE_ROSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DISABLE_ROSPEC_RESPONSE.data, data.Length);
                    _event_DISABLE_ROSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_ROSPECS:
                    _event_GET_ROSPECS.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_ROSPECS.data, data.Length);
                    _event_GET_ROSPECS.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_ROSPECS_RESPONSE:
                    _event_GET_ROSPECS_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_ROSPECS_RESPONSE.data, data.Length);
                    _event_GET_ROSPECS_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ADD_ACCESSSPEC:
                    _event_ADD_ACCESSSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ADD_ACCESSSPEC.data, data.Length);
                    _event_ADD_ACCESSSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ADD_ACCESSSPEC_RESPONSE:
                    _event_ADD_ACCESSSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ADD_ACCESSSPEC_RESPONSE.data, data.Length);
                    _event_ADD_ACCESSSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DELETE_ACCESSSPEC:
                    _event_DELETE_ACCESSSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DELETE_ACCESSSPEC.data, data.Length);
                    _event_DELETE_ACCESSSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DELETE_ACCESSSPEC_RESPONSE:
                    _event_DELETE_ACCESSSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DELETE_ACCESSSPEC_RESPONSE.data, data.Length);
                    _event_DELETE_ACCESSSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ENABLE_ACCESSSPEC:
                    _event_ENABLE_ACCESSSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ENABLE_ACCESSSPEC.data, data.Length);
                    _event_ENABLE_ACCESSSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ENABLE_ACCESSSPEC_RESPONSE:
                    _event_ENABLE_ACCESSSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ENABLE_ACCESSSPEC_RESPONSE.data, data.Length);
                    _event_ENABLE_ACCESSSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DISABLE_ACCESSSPEC:
                    _event_DISABLE_ACCESSSPEC.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DISABLE_ACCESSSPEC.data, data.Length);
                    _event_DISABLE_ACCESSSPEC.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.DISABLE_ACCESSSPEC_RESPONSE:
                    _event_DISABLE_ACCESSSPEC_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_DISABLE_ACCESSSPEC_RESPONSE.data, data.Length);
                    _event_DISABLE_ACCESSSPEC_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_ACCESSSPECS:
                    _event_GET_ACCESSSPECS.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_ACCESSSPECS.data, data.Length);
                    _event_GET_ACCESSSPECS.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_ACCESSSPECS_RESPONSE:
                    _event_GET_ACCESSSPECS_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_ACCESSSPECS_RESPONSE.data, data.Length);
                    _event_GET_ACCESSSPECS_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_READER_CONFIG:
                    _event_GET_READER_CONFIG.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_READER_CONFIG.data, data.Length);
                    _event_GET_READER_CONFIG.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_READER_CONFIG_RESPONSE:
                    _event_GET_READER_CONFIG_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_READER_CONFIG_RESPONSE.data, data.Length);
                    _event_GET_READER_CONFIG_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.SET_READER_CONFIG:
                    _event_SET_READER_CONFIG.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_SET_READER_CONFIG.data, data.Length);
                    _event_SET_READER_CONFIG.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.SET_READER_CONFIG_RESPONSE:
                    _event_SET_READER_CONFIG_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_SET_READER_CONFIG_RESPONSE.data, data.Length);
                    _event_SET_READER_CONFIG_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.CLOSE_CONNECTION:
                    _event_CLOSE_CONNECTION.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_CLOSE_CONNECTION.data, data.Length);
                    _event_CLOSE_CONNECTION.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.CLOSE_CONNECTION_RESPONSE:
                    _event_CLOSE_CONNECTION_RESPONSE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_CLOSE_CONNECTION_RESPONSE.data, data.Length);
                    _event_CLOSE_CONNECTION_RESPONSE.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.GET_REPORT:
                    _event_GET_REPORT.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_GET_REPORT.data, data.Length);
                    _event_GET_REPORT.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.RO_ACCESS_REPORT:
                    try
                    {
                        bArr = Util.ConvertByteArrayToBitArray(data);
                        length = bArr.Count;
                        MSG_RO_ACCESS_REPORT rpt = MSG_RO_ACCESS_REPORT.FromBitArray(ref bArr, ref cursor, length);
                        delegateRoAccessReport roaccess = new delegateRoAccessReport(TriggerRoAccessReport);
                        roaccess.BeginInvoke(rpt, null, null);
                    }
                    catch
                    {
                    }
                    break;

                case ENUM_LLRP_MSG_TYPE.KEEPALIVE:
                    try
                    {
                        bArr = Util.ConvertByteArrayToBitArray(data);
                        length = bArr.Count;
                        MSG_KEEPALIVE msg = MSG_KEEPALIVE.FromBitArray(ref bArr, ref cursor, length);
                        delegateKeepAlive rMsg = new delegateKeepAlive(TriggerKeepAlive);
                        rMsg.BeginInvoke(msg, null, null);
                    }
                    catch
                    {
                    }
                    break;

                case ENUM_LLRP_MSG_TYPE.KEEPALIVE_ACK:
                    _event_KEEPALIVE_ACK.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_KEEPALIVE_ACK.data, data.Length);
                    _event_KEEPALIVE_ACK.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.READER_EVENT_NOTIFICATION:
                    try
                    {
                        bArr = Util.ConvertByteArrayToBitArray(data);
                        length = bArr.Count;
                        MSG_READER_EVENT_NOTIFICATION ntf = MSG_READER_EVENT_NOTIFICATION.FromBitArray(ref bArr, ref cursor, length);
                        if (conn_evt != null && ntf.ReaderEventNotificationData.ConnectionAttemptEvent != null)
                        {
                            conn_status_type = ntf.ReaderEventNotificationData.ConnectionAttemptEvent.Status;
                            conn_evt.Set();
                        }
                        else
                        {
                            delegateReaderEventNotification rEvent = new delegateReaderEventNotification(TriggerReaderEventNotification);
                            rEvent.BeginInvoke(ntf, null, null);
                        }
                    }
                    catch
                    {
                    }
                    break;

                case ENUM_LLRP_MSG_TYPE.ENABLE_EVENTS_AND_REPORTS:
                    _event_ENABLE_EVENTS_AND_REPORTS.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ENABLE_EVENTS_AND_REPORTS.data, data.Length);
                    _event_ENABLE_EVENTS_AND_REPORTS.evt.Set();
                    break;

                case ENUM_LLRP_MSG_TYPE.ERROR_MESSAGE:
                    _event_ERROR_MESSAGE.data = new byte[data.Length];
                    if (data.Length > 0) Array.Copy(data, _event_ERROR_MESSAGE.data, data.Length);
                    _event_ERROR_MESSAGE.evt.Set();
                    break;

                default:
                    break;
            }
        }

        #endregion


        public MSG_CUSTOM_MESSAGE CUSTOM_MESSAGE(MSG_CUSTOM_MESSAGE msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_CUSTOM_MESSAGE = new ClientManualResetEvent(false);
            _event_CUSTOM_MESSAGE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_CUSTOM_MESSAGE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_CUSTOM_MESSAGE.data);
                        length = bArr.Count;
                        MSG_CUSTOM_MESSAGE msg_rsp = MSG_CUSTOM_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }


        public MSG_GET_READER_CAPABILITIES_RESPONSE GET_READER_CAPABILITIES(MSG_GET_READER_CAPABILITIES msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_GET_READER_CAPABILITIES_RESPONSE = new ClientManualResetEvent(false);
            _event_GET_READER_CAPABILITIES_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_GET_READER_CAPABILITIES_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_GET_READER_CAPABILITIES_RESPONSE.data);
                        length = bArr.Count;
                        MSG_GET_READER_CAPABILITIES_RESPONSE msg_rsp = MSG_GET_READER_CAPABILITIES_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_ADD_ROSPEC_RESPONSE ADD_ROSPEC(MSG_ADD_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_ADD_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_ADD_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_ADD_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ADD_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_ADD_ROSPEC_RESPONSE msg_rsp = MSG_ADD_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_DELETE_ROSPEC_RESPONSE DELETE_ROSPEC(MSG_DELETE_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_DELETE_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_DELETE_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_DELETE_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_DELETE_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_DELETE_ROSPEC_RESPONSE msg_rsp = MSG_DELETE_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_START_ROSPEC_RESPONSE START_ROSPEC(MSG_START_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_START_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_START_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_START_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_START_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_START_ROSPEC_RESPONSE msg_rsp = MSG_START_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_STOP_ROSPEC_RESPONSE STOP_ROSPEC(MSG_STOP_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;

            //Add your code here

            _event_STOP_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_STOP_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_STOP_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_STOP_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_STOP_ROSPEC_RESPONSE msg_rsp = MSG_STOP_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID)
                            return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_ENABLE_ROSPEC_RESPONSE ENABLE_ROSPEC(MSG_ENABLE_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_ENABLE_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_ENABLE_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_ENABLE_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_ENABLE_ROSPEC_RESPONSE msg_rsp = MSG_ENABLE_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_DISABLE_ROSPEC_RESPONSE DISABLE_ROSPEC(MSG_DISABLE_ROSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_DISABLE_ROSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_DISABLE_ROSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_DISABLE_ROSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_DISABLE_ROSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_DISABLE_ROSPEC_RESPONSE msg_rsp = MSG_DISABLE_ROSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_GET_ROSPECS_RESPONSE GET_ROSPECS(MSG_GET_ROSPECS msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_GET_ROSPECS_RESPONSE = new ClientManualResetEvent(false);
            _event_GET_ROSPECS_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_GET_ROSPECS_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_GET_ROSPECS_RESPONSE.data);
                        length = bArr.Count;
                        MSG_GET_ROSPECS_RESPONSE msg_rsp = MSG_GET_ROSPECS_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_ADD_ACCESSSPEC_RESPONSE ADD_ACCESSSPEC(MSG_ADD_ACCESSSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_ADD_ACCESSSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_ADD_ACCESSSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_ADD_ACCESSSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ADD_ACCESSSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_ADD_ACCESSSPEC_RESPONSE msg_rsp = MSG_ADD_ACCESSSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_DELETE_ACCESSSPEC_RESPONSE DELETE_ACCESSSPEC(MSG_DELETE_ACCESSSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_DELETE_ACCESSSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_DELETE_ACCESSSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_DELETE_ACCESSSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_DELETE_ACCESSSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_DELETE_ACCESSSPEC_RESPONSE msg_rsp = MSG_DELETE_ACCESSSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_ENABLE_ACCESSSPEC_RESPONSE ENABLE_ACCESSSPEC(MSG_ENABLE_ACCESSSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_ENABLE_ACCESSSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_ENABLE_ACCESSSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_ENABLE_ACCESSSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_ACCESSSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_ENABLE_ACCESSSPEC_RESPONSE msg_rsp = MSG_ENABLE_ACCESSSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_DISABLE_ACCESSSPEC_RESPONSE DISABLE_ACCESSSPEC(MSG_DISABLE_ACCESSSPEC msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_DISABLE_ACCESSSPEC_RESPONSE = new ClientManualResetEvent(false);
            _event_DISABLE_ACCESSSPEC_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_DISABLE_ACCESSSPEC_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_DISABLE_ACCESSSPEC_RESPONSE.data);
                        length = bArr.Count;
                        MSG_DISABLE_ACCESSSPEC_RESPONSE msg_rsp = MSG_DISABLE_ACCESSSPEC_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_GET_ACCESSSPECS_RESPONSE GET_ACCESSSPECS(MSG_GET_ACCESSSPECS msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_GET_ACCESSSPECS_RESPONSE = new ClientManualResetEvent(false);
            _event_GET_ACCESSSPECS_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_GET_ACCESSSPECS_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_GET_ACCESSSPECS_RESPONSE.data);
                        length = bArr.Count;
                        MSG_GET_ACCESSSPECS_RESPONSE msg_rsp = MSG_GET_ACCESSSPECS_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_GET_READER_CONFIG_RESPONSE GET_READER_CONFIG(MSG_GET_READER_CONFIG msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_GET_READER_CONFIG_RESPONSE = new ClientManualResetEvent(false);
            _event_GET_READER_CONFIG_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_GET_READER_CONFIG_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_GET_READER_CONFIG_RESPONSE.data);
                        length = bArr.Count;
                        MSG_GET_READER_CONFIG_RESPONSE msg_rsp = MSG_GET_READER_CONFIG_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_SET_READER_CONFIG_RESPONSE SET_READER_CONFIG(MSG_SET_READER_CONFIG msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_SET_READER_CONFIG_RESPONSE = new ClientManualResetEvent(false);
            _event_SET_READER_CONFIG_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_SET_READER_CONFIG_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_SET_READER_CONFIG_RESPONSE.data);
                        length = bArr.Count;
                        MSG_SET_READER_CONFIG_RESPONSE msg_rsp = MSG_SET_READER_CONFIG_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public MSG_CLOSE_CONNECTION_RESPONSE CLOSE_CONNECTION(MSG_CLOSE_CONNECTION msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            //Add your code here
            _event_CLOSE_CONNECTION_RESPONSE = new ClientManualResetEvent(false);
            _event_CLOSE_CONNECTION_RESPONSE.msg_id = msg.MSG_ID;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            WaitHandle[] waitHandles = new WaitHandle[] { _event_CLOSE_CONNECTION_RESPONSE.evt, _event_ERROR_MESSAGE.evt };

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            int wait_result = WaitHandle.WaitAny(waitHandles, time_out, false);

            int cursor = 0;
            int length;
            BitArray bArr;

            try
            {
                switch (wait_result)
                {
                    case 0:
                        bArr = Util.ConvertByteArrayToBitArray(_event_CLOSE_CONNECTION_RESPONSE.data);
                        length = bArr.Count;
                        MSG_CLOSE_CONNECTION_RESPONSE msg_rsp = MSG_CLOSE_CONNECTION_RESPONSE.FromBitArray(ref bArr, ref cursor, length);
                        if (msg_rsp.MSG_ID != msg.MSG_ID) return null;
                        else
                            return msg_rsp;
                    case 1:
                        bArr = Util.ConvertByteArrayToBitArray(_event_ERROR_MESSAGE.data);
                        length = bArr.Count;
                        msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                        return null;
                    default:
                        return null;
                }
            }
            catch
            {
                return null;
            }
        }

        public void GET_REPORT(MSG_GET_REPORT msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
            if (wait_result)
            {
                BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
                int cursor = 0;
                int length = bArr.Count;
                msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                return;
            }
        }

        public void KEEPALIVE_ACK(MSG_KEEPALIVE_ACK msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
            if (wait_result)
            {
                BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
                int cursor = 0;
                int length = bArr.Count;
                msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                return;
            }
        }

        public void ENABLE_EVENTS_AND_REPORTS(MSG_ENABLE_EVENTS_AND_REPORTS msg, out MSG_ERROR_MESSAGE msg_err, int time_out)
        {
            msg_err = null;
            _event_ERROR_MESSAGE = new ClientManualResetEvent(false);

            bool[] bit_array = msg.ToBitArray();
            byte[] data = Util.ConvertBitArrayToByteArray(bit_array);

            cI.Send(data);

            bool wait_result = _event_ERROR_MESSAGE.evt.WaitOne(time_out, false);
            if (wait_result)
            {
                BitArray bArr = Util.ConvertByteArrayToBitArray(_event_ENABLE_EVENTS_AND_REPORTS.data);
                int cursor = 0;
                int length = bArr.Count;
                msg_err = MSG_ERROR_MESSAGE.FromBitArray(ref bArr, ref cursor, length);
                return;
            }
        }

    }
}
