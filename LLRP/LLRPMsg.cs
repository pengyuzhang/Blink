
/*
***************************************************************************
*  Copyright 2007 Impinj, Inc.
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
***************************************************************************
*/


/*
***************************************************************************
*
*  This code is generated by Impinj LLRP .Net generator. Modification is
*  not recommended.
*
***************************************************************************
*/

/*
***************************************************************************
* File Name:       LLRPMsg.cs
*
* Version:         1.0
* Author:          Impinj
* Organization:    Impinj
* Date:            Jan. 18, 2008
*
* Description:     This file contains LLRP message definitions
***************************************************************************
*/

using System;
using System.IO;
using System.Text;
using System.Collections;
using System.ComponentModel;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Runtime.InteropServices;

using LLRP.DataType;

namespace LLRP
{

    #region Custom Parameter Interface

    public interface IGET_READER_CAPABILITIES_Custom_Param : ICustom_Parameter { }

    public interface IGET_READER_CAPABILITIES_RESPONSE_Custom_Param : ICustom_Parameter { }

    public interface IGET_READER_CONFIG_Custom_Param : ICustom_Parameter { }

    public interface IGET_READER_CONFIG_RESPONSE_Custom_Param : ICustom_Parameter { }

    public interface ISET_READER_CONFIG_Custom_Param : ICustom_Parameter { }

    public interface IRO_ACCESS_REPORT_Custom_Param : ICustom_Parameter { }

    #endregion

    //LLRP message definitions

    /// <summary>
    /// This message carries a vendor defined format from Reader to Client or Client to Reader. No requirements are made as to the content or parameters contained within the Data portion of these messages. Clients MAY ignore CUSTOM_MESSAGEs. Readers SHALL accept CUSTOM_MESSAGE and return an ERROR_MESSAGE if CUSTOM_MESSAGE is unsupported by the Reader or the CUSTOM_MESSAGE contains fields and/or parameters that are unsupported by the Reader. 
    /// </summary>
    public class MSG_CUSTOM_MESSAGE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 VendorIdentifier = 0;
        private Int16 VendorIdentifier_len = 0;

        public byte MessageSubtype = 0;
        private Int16 MessageSubtype_len = 0;

        public ByteArray Data = new ByteArray();
        private Int16 Data_len;


        public MSG_CUSTOM_MESSAGE() { msgType = 1023; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (VendorIdentifier != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(VendorIdentifier, VendorIdentifier_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += VendorIdentifier_len; }
            }

            if (MessageSubtype != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(MessageSubtype, MessageSubtype_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += MessageSubtype_len; }
            }

            if (Data != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(Data, Data_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += Data_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_CUSTOM_MESSAGE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_CUSTOM_MESSAGE obj = new MSG_CUSTOM_MESSAGE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.VendorIdentifier = (UInt32)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(byte), field_len);
            obj.MessageSubtype = (byte)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = (bit_array.Length - cursor) / 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(ByteArray), field_len);
            obj.Data = (ByteArray)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<CUSTOM_MESSAGE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (VendorIdentifier != null)
            {

                xml_str += "<VendorIdentifier>" + VendorIdentifier.ToString() + "</VendorIdentifier>";

            }

            if (MessageSubtype != null)
            {

                xml_str += "<MessageSubtype>" + MessageSubtype.ToString() + "</MessageSubtype>";

            }

            if (Data != null)
            {

                xml_str += "<Data>" + Data.ToHexString() + "</Data>";

            }

            xml_str += "</CUSTOM_MESSAGE>";
            return xml_str;
        }

        public new static MSG_CUSTOM_MESSAGE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_CUSTOM_MESSAGE msg = new MSG_CUSTOM_MESSAGE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "VendorIdentifier");

            msg.VendorIdentifier = Convert.ToUInt32(val);

            val = XmlUtil.GetNodeValue(node, "MessageSubtype");

            msg.MessageSubtype = Convert.ToByte(val);

            val = XmlUtil.GetNodeValue(node, "Data");

            msg.Data = ByteArray.FromString(val);

            return msg;
        }


    }

    /// <summary>
    /// This message is sent from the Client to the Reader. The Client is able to request only a subset or all the capabilities from the Reader. 
    /// </summary>
    public class MSG_GET_READER_CAPABILITIES : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public
      ENUM_GetReaderCapabilitiesRequestedData RequestedData;
        private Int16 RequestedData_len = 8;
        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IGET_READER_CAPABILITIES_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_GET_READER_CAPABILITIES() { msgType = 1; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (RequestedData != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += RequestedData_len; }
            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_READER_CAPABILITIES FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CAPABILITIES obj = new MSG_GET_READER_CAPABILITIES();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(
        ENUM_GetReaderCapabilitiesRequestedData), field_len);
            obj.RequestedData = (
        ENUM_GetReaderCapabilitiesRequestedData)obj_val;

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_READER_CAPABILITIES" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (RequestedData != null)
            {

                xml_str += "<RequestedData>" + RequestedData.ToString() + "</RequestedData>";

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</GET_READER_CAPABILITIES>";
            return xml_str;
        }

        public new static MSG_GET_READER_CAPABILITIES FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_READER_CAPABILITIES msg = new MSG_GET_READER_CAPABILITIES();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "RequestedData");

            msg.RequestedData = (
      ENUM_GetReaderCapabilitiesRequestedData)Enum.Parse(typeof(
      ENUM_GetReaderCapabilitiesRequestedData), val);

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the response from the Reader to the GET_READER_CAPABILITIES message. The response contains the LLRPStatus Parameter and the list of parameters for the requested capabilities conveyed via RequestedData in the GET_READER_CAPABILITIES message.  
    /// </summary>
    public class MSG_GET_READER_CAPABILITIES_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;

        public PARAM_GeneralDeviceCapabilities GeneralDeviceCapabilities;

        public PARAM_LLRPCapabilities LLRPCapabilities;

        public PARAM_RegulatoryCapabilities RegulatoryCapabilities;

        public UNION_AirProtocolLLRPCapabilities AirProtocolLLRPCapabilities = new UNION_AirProtocolLLRPCapabilities();

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IGET_READER_CAPABILITIES_RESPONSE_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_GET_READER_CAPABILITIES_RESPONSE() { msgType = 11; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }

            if (GeneralDeviceCapabilities != null)
            {
                GeneralDeviceCapabilities.ToBitArray(ref bit_array, ref cursor);

            }

            if (LLRPCapabilities != null)
            {
                LLRPCapabilities.ToBitArray(ref bit_array, ref cursor);

            }

            if (RegulatoryCapabilities != null)
            {
                RegulatoryCapabilities.ToBitArray(ref bit_array, ref cursor);

            }

            len = AirProtocolLLRPCapabilities.Count;
            for (int i = 0; i < len; i++) AirProtocolLLRPCapabilities[i].ToBitArray(ref bit_array, ref cursor);

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_READER_CAPABILITIES_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CAPABILITIES_RESPONSE obj = new MSG_GET_READER_CAPABILITIES_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            obj.GeneralDeviceCapabilities = PARAM_GeneralDeviceCapabilities.FromBitArray(ref bit_array, ref cursor, length);

            obj.LLRPCapabilities = PARAM_LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length);

            obj.RegulatoryCapabilities = PARAM_RegulatoryCapabilities.FromBitArray(ref bit_array, ref cursor, length);

            PARAM_C1G2LLRPCapabilities _param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_C1G2LLRPCapabilities != null) obj.AirProtocolLLRPCapabilities.Add(_param_C1G2LLRPCapabilities);

            while ((_param_C1G2LLRPCapabilities = PARAM_C1G2LLRPCapabilities.FromBitArray(ref bit_array, ref cursor, length)) != null)
            {
                obj.AirProtocolLLRPCapabilities.Add(_param_C1G2LLRPCapabilities);
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_READER_CAPABILITIES_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            if (GeneralDeviceCapabilities != null)
            {

                xml_str += GeneralDeviceCapabilities.ToString();

            }

            if (LLRPCapabilities != null)
            {

                xml_str += LLRPCapabilities.ToString();

            }

            if (RegulatoryCapabilities != null)
            {

                xml_str += RegulatoryCapabilities.ToString();

            }

            if (AirProtocolLLRPCapabilities != null)
            {
                len = AirProtocolLLRPCapabilities.Count;
                for (int i = 0; i < len; i++) xml_str += AirProtocolLLRPCapabilities[i].ToString();
            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</GET_READER_CAPABILITIES_RESPONSE>";
            return xml_str;
        }

        public new static MSG_GET_READER_CAPABILITIES_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_READER_CAPABILITIES_RESPONSE msg = new MSG_GET_READER_CAPABILITIES_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GeneralDeviceCapabilities");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.GeneralDeviceCapabilities = PARAM_GeneralDeviceCapabilities.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPCapabilities");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPCapabilities = PARAM_LLRPCapabilities.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RegulatoryCapabilities");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.RegulatoryCapabilities = PARAM_RegulatoryCapabilities.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            {

                msg.AirProtocolLLRPCapabilities = new UNION_AirProtocolLLRPCapabilities();

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "C1G2LLRPCapabilities");
                if (xnl.Count != 0)
                {

                    for (int i = 0; i < xnl.Count; i++)
                        msg.AirProtocolLLRPCapabilities.Add(PARAM_C1G2LLRPCapabilities.FromXmlNode(xnl[i]));
                }

            }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// An ADD_ROSPEC message communicates the information of a ROSpec to the Reader. LLRP supports configuration of multiple ROSpecs. Each ROSpec is uniquely identified using a ROSpecID, generated by the Client. The ROSpec starts at the Disabled state waiting for the ENABLE_ROSPEC message for the ROSpec from the Client, upon which it transitions to the Inactive state.The Client SHALL add a ROSpec in a Disabled State - i.e., CurrentState field in the ROSpec Parameter (section 10.2.1) SHALL be set to disabled. If the CurrentState value is different than disabled, an error SHALL be returned in the ADD_ROSPEC_RESPONSE (e.g. P_FieldError). 
    /// </summary>
    public class MSG_ADD_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_ROSpec ROSpec;


        public MSG_ADD_ROSPEC() { msgType = 20; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpec != null)
            {
                ROSpec.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ADD_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ROSPEC obj = new MSG_ADD_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.ROSpec = PARAM_ROSpec.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ADD_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpec != null)
            {

                xml_str += ROSpec.ToString();

            }

            xml_str += "</ADD_ROSPEC>";
            return xml_str;
        }

        public new static MSG_ADD_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ADD_ROSPEC msg = new MSG_ADD_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ROSpec = PARAM_ROSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to an ADD_ROSPEC message. If all the parameters specified in the ADD_ROSPEC command are successfully set, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_ADD_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_ADD_ROSPEC_RESPONSE() { msgType = 30; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ADD_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ROSPEC_RESPONSE obj = new MSG_ADD_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ADD_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</ADD_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_ADD_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ADD_ROSPEC_RESPONSE msg = new MSG_ADD_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command is issued by the Client to the Reader. This command deletes the ROSpec at the Reader corresponding to ROSpecID passed in this message.ROSpecID: Zero indicates to delete all ROSpecs. 
    /// </summary>
    public class MSG_DELETE_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;


        public MSG_DELETE_ROSPEC() { msgType = 21; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ROSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DELETE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ROSPEC obj = new MSG_DELETE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DELETE_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</DELETE_ROSPEC>";
            return xml_str;
        }

        public new static MSG_DELETE_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DELETE_ROSPEC msg = new MSG_DELETE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            msg.ROSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a DELETE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID that the Reader was presently executing, and the Reader was successful in stopping that execution, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_DELETE_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_DELETE_ROSPEC_RESPONSE() { msgType = 31; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DELETE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ROSPEC_RESPONSE obj = new MSG_DELETE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DELETE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</DELETE_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_DELETE_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DELETE_ROSPEC_RESPONSE msg = new MSG_DELETE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader starts the ROSpec corresponding to ROSpecID passed in this message, if the ROSpec is in the enabled state.ROSpecID: Zero is disallowed. 
    /// </summary>
    public class MSG_START_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;


        public MSG_START_ROSPEC() { msgType = 22; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ROSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_START_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_START_ROSPEC obj = new MSG_START_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<START_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</START_ROSPEC>";
            return xml_str;
        }

        public new static MSG_START_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_START_ROSPEC msg = new MSG_START_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            msg.ROSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a START_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID in the enabled state, and the Reader was able to start executing that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_START_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_START_ROSPEC_RESPONSE() { msgType = 32; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_START_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_START_ROSPEC_RESPONSE obj = new MSG_START_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<START_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</START_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_START_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_START_ROSPEC_RESPONSE msg = new MSG_START_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader stops the execution of the ROSpec corresponding to the ROSpecID passed in this message. STOP_ROSPEC overrides all other priorities and stops the execution. This basically moves the ROSpec's state to Inactive. This message does not the delete the ROSpec.ROSpecID: Zero is disallowed. 
    /// </summary>
    public class MSG_STOP_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;


        public MSG_STOP_ROSPEC() { msgType = 23; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ROSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_STOP_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_STOP_ROSPEC obj = new MSG_STOP_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<STOP_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</STOP_ROSPEC>";
            return xml_str;
        }

        public new static MSG_STOP_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_STOP_ROSPEC msg = new MSG_STOP_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            msg.ROSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a STOP_ROSPEC command. If the Reader was currently executing the ROSpec corresponding to the ROSpecID, and the Reader was able to stop executing that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_STOP_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_STOP_ROSPEC_RESPONSE() { msgType = 33; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_STOP_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_STOP_ROSPEC_RESPONSE obj = new MSG_STOP_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<STOP_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</STOP_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_STOP_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_STOP_ROSPEC_RESPONSE msg = new MSG_STOP_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the ROSpec corresponding to the ROSpecID passed in this message from the disabled to the enabled state.ROSpecID:  If set to zero, all ROSpecs are enabled. 
    /// </summary>
    public class MSG_ENABLE_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;


        public MSG_ENABLE_ROSPEC() { msgType = 24; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ROSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ENABLE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ROSPEC obj = new MSG_ENABLE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ENABLE_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</ENABLE_ROSPEC>";
            return xml_str;
        }

        public new static MSG_ENABLE_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ENABLE_ROSPEC msg = new MSG_ENABLE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            msg.ROSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a ENABLE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID, and the Reader was able to enable that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_ENABLE_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_ENABLE_ROSPEC_RESPONSE() { msgType = 34; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ENABLE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ROSPEC_RESPONSE obj = new MSG_ENABLE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ENABLE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</ENABLE_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_ENABLE_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ENABLE_ROSPEC_RESPONSE msg = new MSG_ENABLE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the ROSpec corresponding to the ROSpecID passed in this message to the disabled state.ROSpecID:  If set to Zero, all ROSpecs are disabled. 
    /// </summary>
    public class MSG_DISABLE_ROSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 ROSpecID = 0;
        private Int16 ROSpecID_len = 0;


        public MSG_DISABLE_ROSPEC() { msgType = 25; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ROSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ROSpecID, ROSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ROSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DISABLE_ROSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ROSPEC obj = new MSG_DISABLE_ROSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.ROSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DISABLE_ROSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ROSpecID != null)
            {

                xml_str += "<ROSpecID>" + ROSpecID.ToString() + "</ROSpecID>";

            }

            xml_str += "</DISABLE_ROSPEC>";
            return xml_str;
        }

        public new static MSG_DISABLE_ROSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DISABLE_ROSPEC msg = new MSG_DISABLE_ROSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ROSpecID");

            msg.ROSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a DISABLE_ROSPEC command. If there was a ROSpec corresponding to the ROSpecID, and the Reader was able to disable that ROSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_DISABLE_ROSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_DISABLE_ROSPEC_RESPONSE() { msgType = 35; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DISABLE_ROSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ROSPEC_RESPONSE obj = new MSG_DISABLE_ROSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DISABLE_ROSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</DISABLE_ROSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_DISABLE_ROSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DISABLE_ROSPEC_RESPONSE msg = new MSG_DISABLE_ROSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the request from the Client to the Reader to retrieve all the ROSpecs that have been configured at the Reader. 
    /// </summary>
    public class MSG_GET_ROSPECS : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_GET_ROSPECS() { msgType = 26; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_ROSPECS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ROSPECS obj = new MSG_GET_ROSPECS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_ROSPECS" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</GET_ROSPECS>";
            return xml_str;
        }

        public new static MSG_GET_ROSPECS FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_ROSPECS msg = new MSG_GET_ROSPECS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a GET_ROSPECS command. If there are no ROSpecs configured at the Reader, the response is just the LLRPStatus parameter with the success code. Else, a list of ROSpec parameter is returned by the Reader, along with the success code in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_GET_ROSPECS_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;

        public PARAM_ROSpec[] ROSpec;


        public MSG_GET_ROSPECS_RESPONSE() { msgType = 36; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }

            if (ROSpec != null)
            {

                len = ROSpec.Length;
                for (int i = 0; i < len; i++)
                    ROSpec[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_ROSPECS_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ROSPECS_RESPONSE obj = new MSG_GET_ROSPECS_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_ROSpec _param_ROSpec = PARAM_ROSpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_ROSpec != null)
            {
                param_list.Add(_param_ROSpec);
                while ((_param_ROSpec = PARAM_ROSpec.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_ROSpec);
                if (param_list.Count > 0)
                {
                    obj.ROSpec = new PARAM_ROSpec[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.ROSpec[i] = (PARAM_ROSpec)param_list[i];
                }
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_ROSPECS_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            if (ROSpec != null)
            {

                len = ROSpec.Length;
                for (int i = 0; i < len; i++)
                    xml_str += ROSpec[i].ToString();

            }

            xml_str += "</GET_ROSPECS_RESPONSE>";
            return xml_str;
        }

        public new static MSG_GET_ROSPECS_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_ROSPECS_RESPONSE msg = new MSG_GET_ROSPECS_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.ROSpec = new PARAM_ROSpec[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.ROSpec[i] = PARAM_ROSpec.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command creates a new AccessSpec at the Reader. The AccessSpec starts at the Disabled state waiting for the ENABLE_ACCESSSPEC message for the AccessSpec from the Client, upon which it transitions to the Active state. The AccessSpecID is generated by the Client.The Client SHALL add an AccessSpec in a Disabled State i.e., CurrentState field in the AccessSpec Parameter (section 11.2.1) SHALL be set to false. If the CurrentState value is different than false, an error SHALL be returned in the ADD_ACCESSSPEC_RESPONSE (e.g. P_FieldError). 
    /// </summary>
    public class MSG_ADD_ACCESSSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_AccessSpec AccessSpec;


        public MSG_ADD_ACCESSSPEC() { msgType = 40; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (AccessSpec != null)
            {
                AccessSpec.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ADD_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ACCESSSPEC obj = new MSG_ADD_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.AccessSpec = PARAM_AccessSpec.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ADD_ACCESSSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (AccessSpec != null)
            {

                xml_str += AccessSpec.ToString();

            }

            xml_str += "</ADD_ACCESSSPEC>";
            return xml_str;
        }

        public new static MSG_ADD_ACCESSSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ADD_ACCESSSPEC msg = new MSG_ADD_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.AccessSpec = PARAM_AccessSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to an ADD_ACCESSSPEC command. If the parameters passed in that ADD_ACCESSSPEC command were successfully accepted and set at the Reader, then the success code is returned in the LLRPStatus parameter. However, if the AccessSpec was not successfully created at the Reader, the Reader sends a LLRPStatus parameter describing the error in the message. 
    /// </summary>
    public class MSG_ADD_ACCESSSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_ADD_ACCESSSPEC_RESPONSE() { msgType = 50; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ADD_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ADD_ACCESSSPEC_RESPONSE obj = new MSG_ADD_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ADD_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</ADD_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_ADD_ACCESSSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ADD_ACCESSSPEC_RESPONSE msg = new MSG_ADD_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command is issued by the Client to the Reader. The Reader deletes the AccessSpec corresponding to the AccessSpecId, and this AccessSpec will stop taking effect from the next inventory round.AccessSpecID: If set to Zero, all AccessSpecs are deleted. 
    /// </summary>
    public class MSG_DELETE_ACCESSSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 AccessSpecID = 0;
        private Int16 AccessSpecID_len = 0;


        public MSG_DELETE_ACCESSSPEC() { msgType = 41; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (AccessSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += AccessSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DELETE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ACCESSSPEC obj = new MSG_DELETE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DELETE_ACCESSSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (AccessSpecID != null)
            {

                xml_str += "<AccessSpecID>" + AccessSpecID.ToString() + "</AccessSpecID>";

            }

            xml_str += "</DELETE_ACCESSSPEC>";
            return xml_str;
        }

        public new static MSG_DELETE_ACCESSSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DELETE_ACCESSSPEC msg = new MSG_DELETE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "AccessSpecID");

            msg.AccessSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a DELETE_ACCESSSPEC command. If there was an AccessSpec at the Reader corresponding to the AccessSpecID passed in the DELETE_ACCESSSPEC command, and the Reader was successful in deleting that AccessSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_DELETE_ACCESSSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_DELETE_ACCESSSPEC_RESPONSE() { msgType = 51; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DELETE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DELETE_ACCESSSPEC_RESPONSE obj = new MSG_DELETE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DELETE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</DELETE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_DELETE_ACCESSSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DELETE_ACCESSSPEC_RESPONSE msg = new MSG_DELETE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader moves the AccessSpec corresponding to the AccessSpecID in this message from the Disabled state to the Active state. The Reader executes this access-spec until it gets a DISABLE_ACCESSSPEC or a DELETE_ACCESSSPEC from the Client. The AccessSpec takes effect with the next (and subsequent) inventory rounds.AccessSpecID: If set to 0, all AccessSpecs are enabled. 
    /// </summary>
    public class MSG_ENABLE_ACCESSSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 AccessSpecID = 0;
        private Int16 AccessSpecID_len = 0;


        public MSG_ENABLE_ACCESSSPEC() { msgType = 42; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (AccessSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += AccessSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ENABLE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ACCESSSPEC obj = new MSG_ENABLE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ENABLE_ACCESSSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (AccessSpecID != null)
            {

                xml_str += "<AccessSpecID>" + AccessSpecID.ToString() + "</AccessSpecID>";

            }

            xml_str += "</ENABLE_ACCESSSPEC>";
            return xml_str;
        }

        public new static MSG_ENABLE_ACCESSSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ENABLE_ACCESSSPEC msg = new MSG_ENABLE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "AccessSpecID");

            msg.AccessSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to an ENABLE_ACCESSSPEC command. If there was an AccessSpec corresponding to the AccessSpecID, and the Reader was able to move that AccessSpec from the disabled to the active state, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_ENABLE_ACCESSSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_ENABLE_ACCESSSPEC_RESPONSE() { msgType = 52; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ENABLE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_ACCESSSPEC_RESPONSE obj = new MSG_ENABLE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ENABLE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</ENABLE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_ENABLE_ACCESSSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ENABLE_ACCESSSPEC_RESPONSE msg = new MSG_ENABLE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader. Upon receiving the message, the Reader stops the execution of the AccessSpec corresponding to AccessSpecID in this message. This basically moves the AccessSpec's state to Disabled. This message does not delete the AccessSpec. The AccessSpec will stop taking effect from the next inventory round.AccessSpecID: If set to zero, all AccessSpecs are disabled. 
    /// </summary>
    public class MSG_DISABLE_ACCESSSPEC : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt32 AccessSpecID = 0;
        private Int16 AccessSpecID_len = 0;


        public MSG_DISABLE_ACCESSSPEC() { msgType = 43; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (AccessSpecID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AccessSpecID, AccessSpecID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += AccessSpecID_len; }
            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DISABLE_ACCESSSPEC FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ACCESSSPEC obj = new MSG_DISABLE_ACCESSSPEC();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 32;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt32), field_len);
            obj.AccessSpecID = (UInt32)obj_val;

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DISABLE_ACCESSSPEC" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (AccessSpecID != null)
            {

                xml_str += "<AccessSpecID>" + AccessSpecID.ToString() + "</AccessSpecID>";

            }

            xml_str += "</DISABLE_ACCESSSPEC>";
            return xml_str;
        }

        public new static MSG_DISABLE_ACCESSSPEC FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DISABLE_ACCESSSPEC msg = new MSG_DISABLE_ACCESSSPEC();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "AccessSpecID");

            msg.AccessSpecID = Convert.ToUInt32(val);

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a STOP_ACCESSSPEC command. If the Reader was currently executing the AccessSpec corresponding to the AccessSpecID, and the Reader was able to disable that AccessSpec, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_DISABLE_ACCESSSPEC_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_DISABLE_ACCESSSPEC_RESPONSE() { msgType = 53; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_DISABLE_ACCESSSPEC_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_DISABLE_ACCESSSPEC_RESPONSE obj = new MSG_DISABLE_ACCESSSPEC_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<DISABLE_ACCESSSPEC_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</DISABLE_ACCESSSPEC_RESPONSE>";
            return xml_str;
        }

        public new static MSG_DISABLE_ACCESSSPEC_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_DISABLE_ACCESSSPEC_RESPONSE msg = new MSG_DISABLE_ACCESSSPEC_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the request from the Client to the Reader to retrieve all the AccessSpecs that have been configured at the Reader. 
    /// </summary>
    public class MSG_GET_ACCESSSPECS : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_GET_ACCESSSPECS() { msgType = 44; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_ACCESSSPECS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ACCESSSPECS obj = new MSG_GET_ACCESSSPECS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_ACCESSSPECS" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</GET_ACCESSSPECS>";
            return xml_str;
        }

        public new static MSG_GET_ACCESSSPECS FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_ACCESSSPECS msg = new MSG_GET_ACCESSSPECS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a GET_ACCESSSPECS command. If there are no AccessSpecs configured at the Reader, the response is just the LLRPStatus parameter with the success code. Else, a list of (AccessSpecID, AccessSpec parameter) is returned by the Reader, along with the LLRPStatus parameter containing the success code. The order of the AccessSpecs listed in the message is normatively the order in which the AccessSpecs were created at the Reader. 
    /// </summary>
    public class MSG_GET_ACCESSSPECS_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;

        public PARAM_AccessSpec[] AccessSpec;


        public MSG_GET_ACCESSSPECS_RESPONSE() { msgType = 54; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessSpec != null)
            {

                len = AccessSpec.Length;
                for (int i = 0; i < len; i++)
                    AccessSpec[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_ACCESSSPECS_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_ACCESSSPECS_RESPONSE obj = new MSG_GET_ACCESSSPECS_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_AccessSpec _param_AccessSpec = PARAM_AccessSpec.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AccessSpec != null)
            {
                param_list.Add(_param_AccessSpec);
                while ((_param_AccessSpec = PARAM_AccessSpec.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AccessSpec);
                if (param_list.Count > 0)
                {
                    obj.AccessSpec = new PARAM_AccessSpec[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.AccessSpec[i] = (PARAM_AccessSpec)param_list[i];
                }
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_ACCESSSPECS_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            if (AccessSpec != null)
            {

                len = AccessSpec.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AccessSpec[i].ToString();

            }

            xml_str += "</GET_ACCESSSPECS_RESPONSE>";
            return xml_str;
        }

        public new static MSG_GET_ACCESSSPECS_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_ACCESSSPECS_RESPONSE msg = new MSG_GET_ACCESSSPECS_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AccessSpec = new PARAM_AccessSpec[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.AccessSpec[i] = PARAM_AccessSpec.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command is issued by the Client to get the current configuration information of the Reader. The Requested Data passed in the command represents the parameter(s) of interest to the Client that has to be returned by the Reader. 
    /// </summary>
    public class MSG_GET_READER_CONFIG : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public UInt16 AntennaID = 0;
        private Int16 AntennaID_len = 0;

        public
      ENUM_GetReaderConfigRequestedData RequestedData;
        private Int16 RequestedData_len = 8;
        public UInt16 GPIPortNum = 0;
        private Int16 GPIPortNum_len = 0;

        public UInt16 GPOPortNum = 0;
        private Int16 GPOPortNum_len = 0;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IGET_READER_CONFIG_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_GET_READER_CONFIG() { msgType = 2; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (AntennaID != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(AntennaID, AntennaID_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += AntennaID_len; }
            }

            if (RequestedData != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(RequestedData, RequestedData_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += RequestedData_len; }
            }

            if (GPIPortNum != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPIPortNum, GPIPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += GPIPortNum_len; }
            }

            if (GPOPortNum != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(GPOPortNum, GPOPortNum_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += GPOPortNum_len; }
            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_READER_CONFIG FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CONFIG obj = new MSG_GET_READER_CONFIG();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.AntennaID = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 8;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(
        ENUM_GetReaderConfigRequestedData), field_len);
            obj.RequestedData = (
        ENUM_GetReaderConfigRequestedData)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.GPIPortNum = (UInt16)obj_val;

            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 16;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(UInt16), field_len);
            obj.GPOPortNum = (UInt16)obj_val;

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_READER_CONFIG" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (AntennaID != null)
            {

                xml_str += "<AntennaID>" + AntennaID.ToString() + "</AntennaID>";

            }

            if (RequestedData != null)
            {

                xml_str += "<RequestedData>" + RequestedData.ToString() + "</RequestedData>";

            }

            if (GPIPortNum != null)
            {

                xml_str += "<GPIPortNum>" + GPIPortNum.ToString() + "</GPIPortNum>";

            }

            if (GPOPortNum != null)
            {

                xml_str += "<GPOPortNum>" + GPOPortNum.ToString() + "</GPOPortNum>";

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</GET_READER_CONFIG>";
            return xml_str;
        }

        public new static MSG_GET_READER_CONFIG FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_READER_CONFIG msg = new MSG_GET_READER_CONFIG();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "AntennaID");

            msg.AntennaID = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "RequestedData");

            msg.RequestedData = (
      ENUM_GetReaderConfigRequestedData)Enum.Parse(typeof(
      ENUM_GetReaderConfigRequestedData), val);

            val = XmlUtil.GetNodeValue(node, "GPIPortNum");

            msg.GPIPortNum = Convert.ToUInt16(val);

            val = XmlUtil.GetNodeValue(node, "GPOPortNum");

            msg.GPOPortNum = Convert.ToUInt16(val);

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to the GET_READER_CONFIG message. The response is the LLRPStatus Parameter and the list of configuration parameters based on the RequestedData in GET_READER_CONFIG. If the GET_READER_CONFIG message did not have any errors, the success code is returned in the LLRPStatus parameter, and in addition the requested configuration parameters are returned. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. The response contains at most one instance of each configuration parameter except for two cases, which are as follows: 
    /// </summary>
    public class MSG_GET_READER_CONFIG_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;

        public PARAM_Identification Identification;

        public PARAM_AntennaProperties[] AntennaProperties;

        public PARAM_AntennaConfiguration[] AntennaConfiguration;

        public PARAM_ReaderEventNotificationSpec ReaderEventNotificationSpec;

        public PARAM_ROReportSpec ROReportSpec;

        public PARAM_AccessReportSpec AccessReportSpec;

        public PARAM_LLRPConfigurationStateValue LLRPConfigurationStateValue;

        public PARAM_KeepaliveSpec KeepaliveSpec;

        public PARAM_GPIPortCurrentState[] GPIPortCurrentState;

        public PARAM_GPOWriteData[] GPOWriteData;

        public PARAM_EventsAndReports EventsAndReports;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IGET_READER_CONFIG_RESPONSE_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_GET_READER_CONFIG_RESPONSE() { msgType = 12; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }

            if (Identification != null)
            {
                Identification.ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaProperties != null)
            {

                len = AntennaProperties.Length;
                for (int i = 0; i < len; i++)
                    AntennaProperties[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    AntennaConfiguration[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (ReaderEventNotificationSpec != null)
            {
                ReaderEventNotificationSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (ROReportSpec != null)
            {
                ROReportSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessReportSpec != null)
            {
                AccessReportSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (LLRPConfigurationStateValue != null)
            {
                LLRPConfigurationStateValue.ToBitArray(ref bit_array, ref cursor);

            }

            if (KeepaliveSpec != null)
            {
                KeepaliveSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (GPIPortCurrentState != null)
            {

                len = GPIPortCurrentState.Length;
                for (int i = 0; i < len; i++)
                    GPIPortCurrentState[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (GPOWriteData != null)
            {

                len = GPOWriteData.Length;
                for (int i = 0; i < len; i++)
                    GPOWriteData[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (EventsAndReports != null)
            {
                EventsAndReports.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_READER_CONFIG_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_READER_CONFIG_RESPONSE obj = new MSG_GET_READER_CONFIG_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            obj.Identification = PARAM_Identification.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_AntennaProperties _param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AntennaProperties != null)
            {
                param_list.Add(_param_AntennaProperties);
                while ((_param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AntennaProperties);
                if (param_list.Count > 0)
                {
                    obj.AntennaProperties = new PARAM_AntennaProperties[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.AntennaProperties[i] = (PARAM_AntennaProperties)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AntennaConfiguration != null)
            {
                param_list.Add(_param_AntennaConfiguration);
                while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AntennaConfiguration);
                if (param_list.Count > 0)
                {
                    obj.AntennaConfiguration = new PARAM_AntennaConfiguration[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.AntennaConfiguration[i] = (PARAM_AntennaConfiguration)param_list[i];
                }
            }

            obj.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromBitArray(ref bit_array, ref cursor, length);

            obj.ROReportSpec = PARAM_ROReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            obj.AccessReportSpec = PARAM_AccessReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            obj.LLRPConfigurationStateValue = PARAM_LLRPConfigurationStateValue.FromBitArray(ref bit_array, ref cursor, length);

            obj.KeepaliveSpec = PARAM_KeepaliveSpec.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_GPIPortCurrentState _param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_GPIPortCurrentState != null)
            {
                param_list.Add(_param_GPIPortCurrentState);
                while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_GPIPortCurrentState);
                if (param_list.Count > 0)
                {
                    obj.GPIPortCurrentState = new PARAM_GPIPortCurrentState[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.GPIPortCurrentState[i] = (PARAM_GPIPortCurrentState)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_GPOWriteData _param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_GPOWriteData != null)
            {
                param_list.Add(_param_GPOWriteData);
                while ((_param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_GPOWriteData);
                if (param_list.Count > 0)
                {
                    obj.GPOWriteData = new PARAM_GPOWriteData[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.GPOWriteData[i] = (PARAM_GPOWriteData)param_list[i];
                }
            }

            obj.EventsAndReports = PARAM_EventsAndReports.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_READER_CONFIG_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            if (Identification != null)
            {

                xml_str += Identification.ToString();

            }

            if (AntennaProperties != null)
            {

                len = AntennaProperties.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AntennaProperties[i].ToString();

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AntennaConfiguration[i].ToString();

            }

            if (ReaderEventNotificationSpec != null)
            {

                xml_str += ReaderEventNotificationSpec.ToString();

            }

            if (ROReportSpec != null)
            {

                xml_str += ROReportSpec.ToString();

            }

            if (AccessReportSpec != null)
            {

                xml_str += AccessReportSpec.ToString();

            }

            if (LLRPConfigurationStateValue != null)
            {

                xml_str += LLRPConfigurationStateValue.ToString();

            }

            if (KeepaliveSpec != null)
            {

                xml_str += KeepaliveSpec.ToString();

            }

            if (GPIPortCurrentState != null)
            {

                len = GPIPortCurrentState.Length;
                for (int i = 0; i < len; i++)
                    xml_str += GPIPortCurrentState[i].ToString();

            }

            if (GPOWriteData != null)
            {

                len = GPOWriteData.Length;
                for (int i = 0; i < len; i++)
                    xml_str += GPOWriteData[i].ToString();

            }

            if (EventsAndReports != null)
            {

                xml_str += EventsAndReports.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</GET_READER_CONFIG_RESPONSE>";
            return xml_str;
        }

        public new static MSG_GET_READER_CONFIG_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_READER_CONFIG_RESPONSE msg = new MSG_GET_READER_CONFIG_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "Identification");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.Identification = PARAM_Identification.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaProperties");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaProperties = new PARAM_AntennaProperties[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.AntennaProperties[i] = PARAM_AntennaProperties.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaConfiguration");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaConfiguration = new PARAM_AntennaConfiguration[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.AntennaConfiguration[i] = PARAM_AntennaConfiguration.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ROReportSpec = PARAM_ROReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.AccessReportSpec = PARAM_AccessReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPConfigurationStateValue");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPConfigurationStateValue = PARAM_LLRPConfigurationStateValue.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "KeepaliveSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.KeepaliveSpec = PARAM_KeepaliveSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIPortCurrentState");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPIPortCurrentState = new PARAM_GPIPortCurrentState[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.GPIPortCurrentState[i] = PARAM_GPIPortCurrentState.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPOWriteData");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPOWriteData = new PARAM_GPOWriteData[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.GPOWriteData[i] = PARAM_GPOWriteData.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EventsAndReports");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.EventsAndReports = PARAM_EventsAndReports.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command is issued by the Client to the Reader. This command sets the Reader configuration using the parameters specified in this command.  Values passed by the SET_READER_CONFIG SHALL apply for the duration of the LLRP connection, or until the values are changed by additional SET_READER_CONFIG messages.For example, ROReportSpec defines the reporting of ROReport format and trigger for a ROSpec. ROReportSpec sent as part of SET_READER_CONFIG becomes the default ROReportSpec for the Reader. A ROReportSpec sent as part of ROSpec in the ADD_ROSPEC command overrides the default value for that ROSpec. However, in cases where there is no ROReportSpec specified in a ROSpec sent as part of ADD_ROSPEC, that particular ROSpec inherits the default ROReportSpec.The data field ResetToFactoryDefault informs the Reader to set all configurable values to factory defaults before applying the remaining parameters. 
    /// </summary>
    public class MSG_SET_READER_CONFIG : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public bool ResetToFactoryDefault = false;
        private Int16 ResetToFactoryDefault_len = 0;

        private const UInt16 param_reserved_len = 7;

        public PARAM_ReaderEventNotificationSpec ReaderEventNotificationSpec;

        public PARAM_AntennaProperties[] AntennaProperties;

        public PARAM_AntennaConfiguration[] AntennaConfiguration;

        public PARAM_ROReportSpec ROReportSpec;

        public PARAM_AccessReportSpec AccessReportSpec;

        public PARAM_KeepaliveSpec KeepaliveSpec;

        public PARAM_GPOWriteData[] GPOWriteData;

        public PARAM_GPIPortCurrentState[] GPIPortCurrentState;

        public PARAM_EventsAndReports EventsAndReports;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(ISET_READER_CONFIG_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_SET_READER_CONFIG() { msgType = 3; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ResetToFactoryDefault != null)
            {
                try
                {
                    BitArray tempBitArr = Util.ConvertObjToBitArray(ResetToFactoryDefault, ResetToFactoryDefault_len);
                    tempBitArr.CopyTo(bit_array, cursor);
                    cursor += tempBitArr.Length;
                }
                catch { cursor += ResetToFactoryDefault_len; }
            }

            cursor += param_reserved_len;

            if (ReaderEventNotificationSpec != null)
            {
                ReaderEventNotificationSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaProperties != null)
            {

                len = AntennaProperties.Length;
                for (int i = 0; i < len; i++)
                    AntennaProperties[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    AntennaConfiguration[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (ROReportSpec != null)
            {
                ROReportSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (AccessReportSpec != null)
            {
                AccessReportSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (KeepaliveSpec != null)
            {
                KeepaliveSpec.ToBitArray(ref bit_array, ref cursor);

            }

            if (GPOWriteData != null)
            {

                len = GPOWriteData.Length;
                for (int i = 0; i < len; i++)
                    GPOWriteData[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (GPIPortCurrentState != null)
            {

                len = GPIPortCurrentState.Length;
                for (int i = 0; i < len; i++)
                    GPIPortCurrentState[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (EventsAndReports != null)
            {
                EventsAndReports.ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_SET_READER_CONFIG FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_SET_READER_CONFIG obj = new MSG_SET_READER_CONFIG();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            if (cursor > length) throw new Exception("Input data is not complete message");

            field_len = 1;

            Util.ConvertBitArrayToObj(ref bit_array, ref cursor, out obj_val, typeof(bool), field_len);
            obj.ResetToFactoryDefault = (bool)obj_val;

            cursor += param_reserved_len;

            obj.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_AntennaProperties _param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AntennaProperties != null)
            {
                param_list.Add(_param_AntennaProperties);
                while ((_param_AntennaProperties = PARAM_AntennaProperties.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AntennaProperties);
                if (param_list.Count > 0)
                {
                    obj.AntennaProperties = new PARAM_AntennaProperties[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.AntennaProperties[i] = (PARAM_AntennaProperties)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_AntennaConfiguration _param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_AntennaConfiguration != null)
            {
                param_list.Add(_param_AntennaConfiguration);
                while ((_param_AntennaConfiguration = PARAM_AntennaConfiguration.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_AntennaConfiguration);
                if (param_list.Count > 0)
                {
                    obj.AntennaConfiguration = new PARAM_AntennaConfiguration[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.AntennaConfiguration[i] = (PARAM_AntennaConfiguration)param_list[i];
                }
            }

            obj.ROReportSpec = PARAM_ROReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            obj.AccessReportSpec = PARAM_AccessReportSpec.FromBitArray(ref bit_array, ref cursor, length);

            obj.KeepaliveSpec = PARAM_KeepaliveSpec.FromBitArray(ref bit_array, ref cursor, length);

            param_list = new ArrayList();
            PARAM_GPOWriteData _param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_GPOWriteData != null)
            {
                param_list.Add(_param_GPOWriteData);
                while ((_param_GPOWriteData = PARAM_GPOWriteData.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_GPOWriteData);
                if (param_list.Count > 0)
                {
                    obj.GPOWriteData = new PARAM_GPOWriteData[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.GPOWriteData[i] = (PARAM_GPOWriteData)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_GPIPortCurrentState _param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_GPIPortCurrentState != null)
            {
                param_list.Add(_param_GPIPortCurrentState);
                while ((_param_GPIPortCurrentState = PARAM_GPIPortCurrentState.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_GPIPortCurrentState);
                if (param_list.Count > 0)
                {
                    obj.GPIPortCurrentState = new PARAM_GPIPortCurrentState[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.GPIPortCurrentState[i] = (PARAM_GPIPortCurrentState)param_list[i];
                }
            }

            obj.EventsAndReports = PARAM_EventsAndReports.FromBitArray(ref bit_array, ref cursor, length);

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<SET_READER_CONFIG" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ResetToFactoryDefault != null)
            {

                xml_str += "<ResetToFactoryDefault>" + ResetToFactoryDefault.ToString() + "</ResetToFactoryDefault>";

            }

            if (ReaderEventNotificationSpec != null)
            {

                xml_str += ReaderEventNotificationSpec.ToString();

            }

            if (AntennaProperties != null)
            {

                len = AntennaProperties.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AntennaProperties[i].ToString();

            }

            if (AntennaConfiguration != null)
            {

                len = AntennaConfiguration.Length;
                for (int i = 0; i < len; i++)
                    xml_str += AntennaConfiguration[i].ToString();

            }

            if (ROReportSpec != null)
            {

                xml_str += ROReportSpec.ToString();

            }

            if (AccessReportSpec != null)
            {

                xml_str += AccessReportSpec.ToString();

            }

            if (KeepaliveSpec != null)
            {

                xml_str += KeepaliveSpec.ToString();

            }

            if (GPOWriteData != null)
            {

                len = GPOWriteData.Length;
                for (int i = 0; i < len; i++)
                    xml_str += GPOWriteData[i].ToString();

            }

            if (GPIPortCurrentState != null)
            {

                len = GPIPortCurrentState.Length;
                for (int i = 0; i < len; i++)
                    xml_str += GPIPortCurrentState[i].ToString();

            }

            if (EventsAndReports != null)
            {

                xml_str += EventsAndReports.ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</SET_READER_CONFIG>";
            return xml_str;
        }

        public new static MSG_SET_READER_CONFIG FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_SET_READER_CONFIG msg = new MSG_SET_READER_CONFIG();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            val = XmlUtil.GetNodeValue(node, "ResetToFactoryDefault");

            msg.ResetToFactoryDefault = Convert.ToBoolean(val);

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ReaderEventNotificationSpec = PARAM_ReaderEventNotificationSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaProperties");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaProperties = new PARAM_AntennaProperties[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.AntennaProperties[i] = PARAM_AntennaProperties.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AntennaConfiguration");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.AntennaConfiguration = new PARAM_AntennaConfiguration[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.AntennaConfiguration[i] = PARAM_AntennaConfiguration.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ROReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ROReportSpec = PARAM_ROReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "AccessReportSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.AccessReportSpec = PARAM_AccessReportSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "KeepaliveSpec");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.KeepaliveSpec = PARAM_KeepaliveSpec.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPOWriteData");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPOWriteData = new PARAM_GPOWriteData[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.GPOWriteData[i] = PARAM_GPOWriteData.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "GPIPortCurrentState");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.GPIPortCurrentState = new PARAM_GPIPortCurrentState[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.GPIPortCurrentState[i] = PARAM_GPIPortCurrentState.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "EventsAndReports");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.EventsAndReports = PARAM_EventsAndReports.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a SET_READER_CONFIG command. If all the parameters specified in the SET_READER_CONFIG command are successfully set, then the success code is returned in the LLRPStatus parameter. If there is an error, the appropriate error code is returned in the LLRPStatus parameter. 
    /// </summary>
    public class MSG_SET_READER_CONFIG_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_SET_READER_CONFIG_RESPONSE() { msgType = 13; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_SET_READER_CONFIG_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_SET_READER_CONFIG_RESPONSE obj = new MSG_SET_READER_CONFIG_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<SET_READER_CONFIG_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</SET_READER_CONFIG_RESPONSE>";
            return xml_str;
        }

        public new static MSG_SET_READER_CONFIG_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_SET_READER_CONFIG_RESPONSE msg = new MSG_SET_READER_CONFIG_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This command is issued by the Client to the Reader.  This command instructs the Reader to gracefully close its connection with the Client.  Under normal operating conditions, a Client SHALL attempt to send this command before closing an LLRP connection.  A Client should wait briefly for the Reader to respond with a CLOSE_CONNECTION_RESPONSE.Upon receipt of this command, the Reader SHALL respond with the CLOSE_CONNECTION_REPONSE message and it should then attempt to close the connection between the Reader and Client.Having executed a CLOSE_CONNECTION command, a Reader MAY persist its configuration state as defined by the ReaderConfigurationStateValue parameter specified in section 12.2.1. 
    /// </summary>
    public class MSG_CLOSE_CONNECTION : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_CLOSE_CONNECTION() { msgType = 14; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_CLOSE_CONNECTION FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_CLOSE_CONNECTION obj = new MSG_CLOSE_CONNECTION();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<CLOSE_CONNECTION" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</CLOSE_CONNECTION>";
            return xml_str;
        }

        public new static MSG_CLOSE_CONNECTION FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_CLOSE_CONNECTION msg = new MSG_CLOSE_CONNECTION();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// This is the response by the Reader to a CLOSE_CONNECTON command from the Client.  Upon receiving a CLOSE_CONNECTION command, the Reader SHALL attempt to send this response to the Client.  After attempting to send this response, the Reader SHALL close its connection with the Client. 
    /// </summary>
    public class MSG_CLOSE_CONNECTION_RESPONSE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_CLOSE_CONNECTION_RESPONSE() { msgType = 4; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_CLOSE_CONNECTION_RESPONSE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_CLOSE_CONNECTION_RESPONSE obj = new MSG_CLOSE_CONNECTION_RESPONSE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<CLOSE_CONNECTION_RESPONSE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</CLOSE_CONNECTION_RESPONSE>";
            return xml_str;
        }

        public new static MSG_CLOSE_CONNECTION_RESPONSE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_CLOSE_CONNECTION_RESPONSE msg = new MSG_CLOSE_CONNECTION_RESPONSE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Client to the Reader to get the tag reports. In response to this message, the Reader SHALL return tag reports accumulated. 
    /// </summary>
    public class MSG_GET_REPORT : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_GET_REPORT() { msgType = 60; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_GET_REPORT FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_GET_REPORT obj = new MSG_GET_REPORT();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<GET_REPORT" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</GET_REPORT>";
            return xml_str;
        }

        public new static MSG_GET_REPORT FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_GET_REPORT msg = new MSG_GET_REPORT();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Reader to the Client, and it contains the results of the RO and Access operations. The ROReportSpec and AccessReportSpec parameters define the contents and triggers for this message. 
    /// </summary>
    public class MSG_RO_ACCESS_REPORT : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_TagReportData[] TagReportData;

        public PARAM_RFSurveyReportData[] RFSurveyReportData;

        public readonly CustomParameterArrayList Custom = new CustomParameterArrayList();
        public void AddCustomParameter(IRO_ACCESS_REPORT_Custom_Param param)
        {
            Custom.Add(param);
        }
        private void AddCustomParameter(ICustom_Parameter param)
        {
            Custom.Add(param);
        }


        public MSG_RO_ACCESS_REPORT() { msgType = 61; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (TagReportData != null)
            {

                len = TagReportData.Length;
                for (int i = 0; i < len; i++)
                    TagReportData[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (RFSurveyReportData != null)
            {

                len = RFSurveyReportData.Length;
                for (int i = 0; i < len; i++)
                    RFSurveyReportData[i].ToBitArray(ref bit_array, ref cursor);

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    Custom[i].ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_RO_ACCESS_REPORT FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_RO_ACCESS_REPORT obj = new MSG_RO_ACCESS_REPORT();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            param_list = new ArrayList();
            PARAM_TagReportData _param_TagReportData = PARAM_TagReportData.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_TagReportData != null)
            {
                param_list.Add(_param_TagReportData);
                while ((_param_TagReportData = PARAM_TagReportData.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_TagReportData);
                if (param_list.Count > 0)
                {
                    obj.TagReportData = new PARAM_TagReportData[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.TagReportData[i] = (PARAM_TagReportData)param_list[i];
                }
            }

            param_list = new ArrayList();
            PARAM_RFSurveyReportData _param_RFSurveyReportData = PARAM_RFSurveyReportData.FromBitArray(ref bit_array, ref cursor, length);
            if (_param_RFSurveyReportData != null)
            {
                param_list.Add(_param_RFSurveyReportData);
                while ((_param_RFSurveyReportData = PARAM_RFSurveyReportData.FromBitArray(ref bit_array, ref cursor, length)) != null) param_list.Add(_param_RFSurveyReportData);
                if (param_list.Count > 0)
                {
                    obj.RFSurveyReportData = new PARAM_RFSurveyReportData[param_list.Count];
                    for (int i = 0; i < param_list.Count; i++)
                        obj.RFSurveyReportData[i] = (PARAM_RFSurveyReportData)param_list[i];
                }
            }

            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length);
            if (custom != null)
            {
                obj.Custom.Add(custom);
                while ((custom = CustomParamDecodeFactory.DecodeCustomParameter(ref bit_array, ref cursor, length)) != null) obj.Custom.Add(custom);
            }

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<RO_ACCESS_REPORT" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (TagReportData != null)
            {

                len = TagReportData.Length;
                for (int i = 0; i < len; i++)
                    xml_str += TagReportData[i].ToString();

            }

            if (RFSurveyReportData != null)
            {

                len = RFSurveyReportData.Length;
                for (int i = 0; i < len; i++)
                    xml_str += RFSurveyReportData[i].ToString();

            }

            if (Custom != null)
            {

                len = Custom.Length;
                for (int i = 0; i < len; i++)
                    xml_str += Custom[i].ToString();

            }

            xml_str += "</RO_ACCESS_REPORT>";
            return xml_str;
        }

        public new static MSG_RO_ACCESS_REPORT FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_RO_ACCESS_REPORT msg = new MSG_RO_ACCESS_REPORT();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "TagReportData");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.TagReportData = new PARAM_TagReportData[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.TagReportData[i] = PARAM_TagReportData.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch
            {
                //int i = 0;
            }

            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "RFSurveyReportData");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        msg.RFSurveyReportData = new PARAM_RFSurveyReportData[xnl.Count];
                        for (int i = 0; i < xnl.Count; i++)
                            msg.RFSurveyReportData[i] = PARAM_RFSurveyReportData.FromXmlNode(xnl[i]);
                    }
                }

            }
            catch { }

            try
            {

                ArrayList xnl = XmlUtil.GetXmlNodeCustomChildren(node);
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                    {
                        for (int i = 0; i < xnl.Count; i++)
                        {
                            ICustom_Parameter custom = CustomParamDecodeFactory.DecodeXmlNodeToCustomParameter((XmlNode)xnl[i]);
                            if (custom != null) msg.AddCustomParameter(custom);
                        }
                    }
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Reader to the Client. This message can be used by the Client to monitor the LLRP-layer connectivity with the Reader. The Client configures the trigger at the Reader to send the Keepalive message. The configuration is done using the KeepaliveSpec parameter (section 12.2.4). 
    /// </summary>
    public class MSG_KEEPALIVE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_KEEPALIVE() { msgType = 62; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_KEEPALIVE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_KEEPALIVE obj = new MSG_KEEPALIVE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<KEEPALIVE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</KEEPALIVE>";
            return xml_str;
        }

        public new static MSG_KEEPALIVE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_KEEPALIVE msg = new MSG_KEEPALIVE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// A Client SHALL generate a KEEPALIVE_ACK in response to each KEEPALIVE received by the reader. 
    /// </summary>
    public class MSG_KEEPALIVE_ACK : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_KEEPALIVE_ACK() { msgType = 72; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_KEEPALIVE_ACK FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_KEEPALIVE_ACK obj = new MSG_KEEPALIVE_ACK();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<KEEPALIVE_ACK" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</KEEPALIVE_ACK>";
            return xml_str;
        }

        public new static MSG_KEEPALIVE_ACK FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_KEEPALIVE_ACK msg = new MSG_KEEPALIVE_ACK();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// This message is issued by the Reader to the Client whenever an event that the Client subscribed to occurs. The pertinent event data is conveyed using the ReaderEventNotificationData parameter. 
    /// </summary>
    public class MSG_READER_EVENT_NOTIFICATION : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_ReaderEventNotificationData ReaderEventNotificationData;


        public MSG_READER_EVENT_NOTIFICATION() { msgType = 63; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (ReaderEventNotificationData != null)
            {
                ReaderEventNotificationData.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_READER_EVENT_NOTIFICATION FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_READER_EVENT_NOTIFICATION obj = new MSG_READER_EVENT_NOTIFICATION();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.ReaderEventNotificationData = PARAM_ReaderEventNotificationData.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<READER_EVENT_NOTIFICATION" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (ReaderEventNotificationData != null)
            {

                xml_str += ReaderEventNotificationData.ToString();

            }

            xml_str += "</READER_EVENT_NOTIFICATION>";
            return xml_str;
        }

        public new static MSG_READER_EVENT_NOTIFICATION FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_READER_EVENT_NOTIFICATION msg = new MSG_READER_EVENT_NOTIFICATION();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "ReaderEventNotificationData");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.ReaderEventNotificationData = PARAM_ReaderEventNotificationData.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

    /// <summary>
    /// This message can be issued by the Client to the Reader after a LLRP connection is established. The Client uses this message to inform the Reader that it can remove its hold on event and report messages.  Readers that are configured to hold events and reports on reconnection (See Section 12.2.6.4) respond to this message by returning the tag reports accumulated (same way they respond to GET_REPORT (See Section 13.1.1)). 
    /// </summary>
    public class MSG_ENABLE_EVENTS_AND_REPORTS : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically



        public MSG_ENABLE_EVENTS_AND_REPORTS() { msgType = 64; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ENABLE_EVENTS_AND_REPORTS FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ENABLE_EVENTS_AND_REPORTS obj = new MSG_ENABLE_EVENTS_AND_REPORTS();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ENABLE_EVENTS_AND_REPORTS" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            xml_str += "</ENABLE_EVENTS_AND_REPORTS>";
            return xml_str;
        }

        public new static MSG_ENABLE_EVENTS_AND_REPORTS FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ENABLE_EVENTS_AND_REPORTS msg = new MSG_ENABLE_EVENTS_AND_REPORTS();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            return msg;
        }


    }

    /// <summary>
    /// The Reader SHALL discard the message if there is at least one error in the message, or cannot be fully processed. In addition, no portion of the message containing an error SHALL be executed by the Reader. In case the message has one or more errors, the Reader SHALL return at least one error parameter for one of the errors. The Reader MAY return more than one error parameter, one for each error. The errors are conveyed using a combination of "generic error codes", a pointer to the culprit parameter/field, and a description of the error encoded as a string of UTF-8 characters.Typically the errors in the LLRP defined messages are conveyed inside of the responses from the Reader. However, in cases where the message received by the Reader contains an unsupported message type, or a CUSTOM_MESSAGE with unsupported parameters or fields, the Reader SHALL respond with the ERROR_MESSAGE.When a Reader or Client receives a command or notification with a version that is not supported, the receiver SHALL send an ERROR_MESSAGE in reply consisting of:  A version that is the same as the received message, the message ID that matches the received message, and an LLRPStatusParameter with the ErrorCode set to M_UnsupportedVersion. This message SHALL contain no sub-parameters (such as Field Error, Parameter Error).Readers and Clients SHALL not respond to an ERROR_MESSAGE. This message is issued by the Reader to the Client, and it contains the LLRPStatus parameter that describes the error in the message. 
    /// </summary>
    public class MSG_ERROR_MESSAGE : Message
    {
        protected static UInt32 sequence_num = 0;                     //used for generating message id automatically


        public PARAM_LLRPStatus LLRPStatus;


        public MSG_ERROR_MESSAGE() { msgType = 100; sequence_num++; }


        public override bool[] ToBitArray()
        {
            int len = 0;
            int cursor = 0;
            bool[] bit_array = new bool[500 * 1024 * 8];

            msgID = sequence_num;

            BitArray bArr = Util.ConvertIntToBitArray(version, 3);
            cursor += 3;
            bArr.CopyTo(bit_array, cursor);

            cursor += 3;
            bArr = Util.ConvertIntToBitArray(msgType, 10);
            bArr.CopyTo(bit_array, cursor);

            cursor += 10;
            bArr = Util.ConvertIntToBitArray(msgLen, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;
            bArr = Util.ConvertIntToBitArray(msgID, 32);
            bArr.CopyTo(bit_array, cursor);

            cursor += 32;

            if (LLRPStatus != null)
            {
                LLRPStatus.ToBitArray(ref bit_array, ref cursor);

            }


            UInt32 msg_len = (UInt32)cursor / 8;
            bArr = Util.ConvertIntToBitArray(msg_len, 32);
            bArr.CopyTo(bit_array, 16);

            bool[] boolArr = new bool[cursor];
            Array.Copy(bit_array, 0, boolArr, 0, cursor);
            return boolArr;
        }

        public new static MSG_ERROR_MESSAGE FromBitArray(ref BitArray bit_array, ref int cursor, int length)
        {
            if (cursor > length) return null;

            int field_len = 0;
            object obj_val;
            ArrayList param_list = new ArrayList();

            MSG_ERROR_MESSAGE obj = new MSG_ERROR_MESSAGE();

            int msg_type = 0;
            cursor += 6;
            msg_type = (int)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 10);

            if (msg_type != obj.msgType)
            {
                cursor -= 16;
                return null;
            }

            obj.msgLen = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);
            obj.msgID = (UInt32)(UInt64)Util.CalculateVal(ref bit_array, ref cursor, 32);


            obj.LLRPStatus = PARAM_LLRPStatus.FromBitArray(ref bit_array, ref cursor, length);

            return obj;
        }

        public override string ToString()
        {
            int len;
            string xml_str = "<ERROR_MESSAGE" + " Version=\"" + version.ToString() + "\" MessageID=\"" + MSG_ID.ToString() + "\"" + ">";

            if (LLRPStatus != null)
            {

                xml_str += LLRPStatus.ToString();

            }

            xml_str += "</ERROR_MESSAGE>";
            return xml_str;
        }

        public new static MSG_ERROR_MESSAGE FromString(string str)
        {
            string val;

            XmlDocument xdoc = new XmlDocument();
            xdoc.LoadXml(str);
            XmlNode node = (XmlNode)xdoc.DocumentElement;

            MSG_ERROR_MESSAGE msg = new MSG_ERROR_MESSAGE();
            try { msg.MSG_ID = Convert.ToUInt32(XmlUtil.GetNodeAttrValue(node, "MessageID")); }
            catch { }


            try
            {

                XmlNodeList xnl = XmlUtil.GetXmlNodes(node, "LLRPStatus");
                if (null != xnl)
                {
                    if (xnl.Count != 0)
                        msg.LLRPStatus = PARAM_LLRPStatus.FromXmlNode(xnl[0]);
                }

            }
            catch { }

            return msg;
        }


    }

}
